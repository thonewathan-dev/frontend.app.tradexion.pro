import "./chunk-G3PMV62Z.js";

// node_modules/klinecharts/dist/index.esm.js
var DEV = true;
function log(templateText, tagStyle, messageStyle, api, invalidParam, append) {
  if (DEV) {
    var apiStr = api !== "" ? "Call api `".concat(api, "`").concat(invalidParam !== "" || append !== "" ? ", " : ".") : "";
    var invalidParamStr = invalidParam !== "" ? "invalid parameter `".concat(invalidParam, "`").concat(append !== "" ? ", " : ".") : "";
    var appendStr = append !== "" ? append : "";
    console.log(templateText, tagStyle, messageStyle, apiStr, invalidParamStr, appendStr);
  }
}
function logWarn(api, invalidParam, append) {
  log("%cüòë klinecharts warning%c %s%s%s", "padding:3px 4px;border-radius:2px;color:#ffffff;background-color:#FF9600", "color:#FF9600", api, invalidParam, append !== null && append !== void 0 ? append : "");
}
function logError(api, invalidParam, append) {
  log("%cüòü klinecharts error%c %s%s%s", "padding:3px 4px;border-radius:2px;color:#ffffff;background-color:#F92855;", "color:#F92855;", api, invalidParam, append);
}
function logTag() {
  log("%c‚ù§Ô∏è Welcome to klinecharts. Version is 10.0.0-beta1", "border-radius:4px;border:dashed 1px #1677FF;line-height:70px;padding:0 20px;margin:16px 0;font-size:14px;color:#1677FF;", "", "", "", "");
}
function merge(target, source) {
  if (!isObject(target) && !isObject(source)) {
    return;
  }
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      var targetProp = target[key];
      var sourceProp = source[key];
      if (isObject(sourceProp) && isObject(targetProp)) {
        merge(targetProp, sourceProp);
      } else {
        target[key] = clone(sourceProp);
      }
    }
  }
}
function clone(target) {
  if (!isObject(target)) {
    return target;
  }
  var copy = null;
  if (isArray(target)) {
    copy = [];
  } else {
    copy = {};
  }
  for (var key in target) {
    if (Object.prototype.hasOwnProperty.call(target, key)) {
      var v = target[key];
      if (isObject(v)) {
        copy[key] = clone(v);
      } else {
        copy[key] = v;
      }
    }
  }
  return copy;
}
function isArray(value) {
  return Object.prototype.toString.call(value) === "[object Array]";
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return typeof value === "object" && isValid(value);
}
function isNumber(value) {
  return typeof value === "number" && Number.isFinite(value);
}
function isValid(value) {
  return value !== null && value !== void 0;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isString(value) {
  return typeof value === "string";
}
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(`[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`, "g");
function formatValue(data, key, defaultValue) {
  if (isValid(data)) {
    var path_1 = [];
    key.replace(rePropName, function(subString) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var k = subString;
      if (isValid(args[1])) {
        k = args[2].replace(reEscapeChar, "$1");
      } else if (isValid(args[0])) {
        k = args[0].trim();
      }
      path_1.push(k);
      return "";
    });
    var value = data;
    var index = 0;
    var length_1 = path_1.length;
    while (isValid(value) && index < length_1) {
      value = value === null || value === void 0 ? void 0 : value[path_1[index++]];
    }
    return isValid(value) ? value : defaultValue !== null && defaultValue !== void 0 ? defaultValue : "--";
  }
  return defaultValue !== null && defaultValue !== void 0 ? defaultValue : "--";
}
function formatTimestampToDateTime(dateTimeFormat, timestamp) {
  var date = {};
  dateTimeFormat.formatToParts(new Date(timestamp)).forEach(function(_a) {
    var type = _a.type, value = _a.value;
    switch (type) {
      case "year": {
        date.YYYY = value;
        break;
      }
      case "month": {
        date.MM = value;
        break;
      }
      case "day": {
        date.DD = value;
        break;
      }
      case "hour": {
        date.HH = value === "24" ? "00" : value;
        break;
      }
      case "minute": {
        date.mm = value;
        break;
      }
      case "second": {
        date.ss = value;
        break;
      }
    }
  });
  return date;
}
function formatTimestampByTemplate(dateTimeFormat, timestamp, template) {
  var date = formatTimestampToDateTime(dateTimeFormat, timestamp);
  return template.replace(/YYYY|MM|DD|HH|mm|ss/g, function(key) {
    return date[key];
  });
}
function formatPrecision(value, precision) {
  var v = +value;
  if (isNumber(v)) {
    return v.toFixed(precision !== null && precision !== void 0 ? precision : 2);
  }
  return "".concat(value);
}
function formatBigNumber(value) {
  var v = +value;
  if (isNumber(v)) {
    if (v > 1e9) {
      return "".concat(+(v / 1e9).toFixed(3), "B");
    }
    if (v > 1e6) {
      return "".concat(+(v / 1e6).toFixed(3), "M");
    }
    if (v > 1e3) {
      return "".concat(+(v / 1e3).toFixed(3), "K");
    }
  }
  return "".concat(value);
}
function formatThousands(value, sign) {
  var vl = "".concat(value);
  if (sign.length === 0) {
    return vl;
  }
  if (vl.includes(".")) {
    var arr = vl.split(".");
    return "".concat(arr[0].replace(/(\d)(?=(\d{3})+$)/g, function($1) {
      return "".concat($1).concat(sign);
    }), ".").concat(arr[1]);
  }
  return vl.replace(/(\d)(?=(\d{3})+$)/g, function($1) {
    return "".concat($1).concat(sign);
  });
}
function formatFoldDecimal(value, threshold) {
  var vl = "".concat(value);
  var reg = new RegExp("\\.0{" + threshold + ",}[1-9][0-9]*$");
  if (reg.test(vl)) {
    var result = vl.split(".");
    var lastIndex = result.length - 1;
    var v = result[lastIndex];
    var match = /0*/.exec(v);
    if (isValid(match)) {
      var count = match[0].length;
      result[lastIndex] = v.replace(/0*/, "0{".concat(count, "}"));
      return result.join(".");
    }
  }
  return vl;
}
function formatTemplateString(template, params) {
  return template.replace(/\{(\w+)\}/g, function(_, key) {
    var value = params[key];
    if (isValid(value)) {
      return value;
    }
    return "{".concat(key, "}");
  });
}
var measureCtx = null;
function getPixelRatio(canvas) {
  var _a, _b;
  return (_b = (_a = canvas.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
}
function createFont(size, weight, family) {
  return "".concat(weight !== null && weight !== void 0 ? weight : "normal", " ").concat(size !== null && size !== void 0 ? size : 12, "px ").concat(family !== null && family !== void 0 ? family : "Helvetica Neue");
}
function calcTextWidth(text2, size, weight, family) {
  if (!isValid(measureCtx)) {
    var canvas = document.createElement("canvas");
    var pixelRatio = getPixelRatio(canvas);
    measureCtx = canvas.getContext("2d");
    measureCtx.scale(pixelRatio, pixelRatio);
  }
  measureCtx.font = createFont(size, weight, family);
  return Math.round(measureCtx.measureText(text2).width);
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function createDefaultBounding(bounding) {
  var defaultBounding = {
    width: 0,
    height: 0,
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  if (isValid(bounding)) {
    merge(defaultBounding, bounding);
  }
  return defaultBounding;
}
var DEFAULT_REQUEST_ID = -1;
function requestAnimationFrame(fn) {
  if (isFunction(window.requestAnimationFrame)) {
    return window.requestAnimationFrame(fn);
  }
  return window.setTimeout(fn, 20);
}
function cancelAnimationFrame(id) {
  if (isFunction(window.cancelAnimationFrame)) {
    window.cancelAnimationFrame(id);
  } else {
    window.clearTimeout(id);
  }
}
var Animation = (
  /** @class */
  function() {
    function Animation2(options) {
      this._options = { duration: 500, iterationCount: 1 };
      this._currentIterationCount = 0;
      this._running = false;
      this._time = 0;
      merge(this._options, options);
    }
    Animation2.prototype._loop = function() {
      var _this = this;
      this._running = true;
      var step = function() {
        var _a;
        if (_this._running) {
          var diffTime = (/* @__PURE__ */ new Date()).getTime() - _this._time;
          if (diffTime < _this._options.duration) {
            (_a = _this._doFrameCallback) === null || _a === void 0 ? void 0 : _a.call(_this, diffTime);
            requestAnimationFrame(step);
          } else {
            _this.stop();
            _this._currentIterationCount++;
            if (_this._currentIterationCount < _this._options.iterationCount) {
              _this.start();
            }
          }
        }
      };
      requestAnimationFrame(step);
    };
    Animation2.prototype.doFrame = function(callback) {
      this._doFrameCallback = callback;
      return this;
    };
    Animation2.prototype.setDuration = function(duration) {
      this._options.duration = duration;
      return this;
    };
    Animation2.prototype.setIterationCount = function(iterationCount) {
      this._options.iterationCount = iterationCount;
      return this;
    };
    Animation2.prototype.start = function() {
      if (!this._running) {
        this._time = (/* @__PURE__ */ new Date()).getTime();
        this._loop();
      }
    };
    Animation2.prototype.stop = function() {
      var _a;
      if (this._running) {
        (_a = this._doFrameCallback) === null || _a === void 0 ? void 0 : _a.call(this, this._options.duration);
      }
      this._running = false;
    };
    return Animation2;
  }()
);
var baseId = 1;
var prevIdTimestamp = (/* @__PURE__ */ new Date()).getTime();
function createId(prefix) {
  var timestamp = (/* @__PURE__ */ new Date()).getTime();
  if (timestamp === prevIdTimestamp) {
    ++baseId;
  } else {
    baseId = 1;
  }
  prevIdTimestamp = timestamp;
  return "".concat(prefix !== null && prefix !== void 0 ? prefix : "").concat(timestamp, "_").concat(baseId);
}
function createDom(tagName, styles2) {
  var _a;
  var dom = document.createElement(tagName);
  var s = styles2 !== null && styles2 !== void 0 ? styles2 : {};
  for (var key in s) {
    dom.style[key] = (_a = s[key]) !== null && _a !== void 0 ? _a : "";
  }
  return dom;
}
function binarySearchNearest(dataList, valueKey, targetValue) {
  var left = 0;
  var right = 0;
  for (right = dataList.length - 1; left !== right; ) {
    var midIndex = Math.floor((right + left) / 2);
    var mid = right - left;
    var midValue = dataList[midIndex][valueKey];
    if (targetValue === dataList[left][valueKey]) {
      return left;
    }
    if (targetValue === dataList[right][valueKey]) {
      return right;
    }
    if (targetValue === midValue) {
      return midIndex;
    }
    if (targetValue > midValue) {
      left = midIndex;
    } else {
      right = midIndex;
    }
    if (mid <= 2) {
      break;
    }
  }
  return left;
}
function nice(value) {
  var exponent = Math.floor(log10(value));
  var exp10 = index10(exponent);
  var f = value / exp10;
  var nf = 0;
  if (f < 1.5) {
    nf = 1;
  } else if (f < 2.5) {
    nf = 2;
  } else if (f < 3.5) {
    nf = 3;
  } else if (f < 4.5) {
    nf = 4;
  } else if (f < 5.5) {
    nf = 5;
  } else if (f < 6.5) {
    nf = 6;
  } else {
    nf = 8;
  }
  value = nf * exp10;
  return +value.toFixed(Math.abs(exponent));
}
function round(value, precision) {
  precision = Math.max(0, precision !== null && precision !== void 0 ? precision : 0);
  var pow = Math.pow(10, precision);
  return Math.round(value * pow) / pow;
}
function getPrecision(value) {
  var str = value.toString();
  var eIndex = str.indexOf("e");
  if (eIndex > 0) {
    var precision = +str.slice(eIndex + 1);
    return precision < 0 ? -precision : 0;
  }
  var dotIndex = str.indexOf(".");
  return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
}
function getMaxMin(dataList, maxKey, minKey) {
  var _a, _b;
  var maxMin = [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER];
  var dataLength = dataList.length;
  var index = 0;
  while (index < dataLength) {
    var data = dataList[index];
    maxMin[0] = Math.max((_a = data[maxKey]) !== null && _a !== void 0 ? _a : Number.MIN_SAFE_INTEGER, maxMin[0]);
    maxMin[1] = Math.min((_b = data[minKey]) !== null && _b !== void 0 ? _b : Number.MAX_SAFE_INTEGER, maxMin[1]);
    ++index;
  }
  return maxMin;
}
function log10(value) {
  if (value === 0) {
    return 0;
  }
  return Math.log10(value);
}
function index10(value) {
  return Math.pow(10, value);
}
function getDefaultVisibleRange() {
  return { from: 0, to: 0, realFrom: 0, realTo: 0 };
}
var TaskScheduler = (
  /** @class */
  function() {
    function TaskScheduler2(callback) {
      this._holdingTasks = null;
      this._running = false;
      this._callback = callback;
    }
    TaskScheduler2.prototype.add = function(tasks) {
      if (!this._running) {
        void this._runTask(tasks);
      } else {
        if (isValid(this._holdingTasks)) {
          this._holdingTasks = __assign(__assign({}, this._holdingTasks), tasks);
        } else {
          this._holdingTasks = tasks;
        }
      }
    };
    TaskScheduler2.prototype._runTask = function(tasks) {
      return __awaiter(this, void 0, void 0, function() {
        var next;
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              this._running = true;
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 3, 4]);
              return [4, Promise.all(Object.values(tasks))];
            case 2:
              _b.sent();
              return [3, 4];
            case 3:
              this._running = false;
              (_a = this._callback) === null || _a === void 0 ? void 0 : _a.call(this);
              if (isValid(this._holdingTasks)) {
                next = this._holdingTasks;
                void this._runTask(next);
                this._holdingTasks = null;
              }
              return [
                7
                /*endfinally*/
              ];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    TaskScheduler2.prototype.clear = function() {
      this._holdingTasks = null;
    };
    return TaskScheduler2;
  }()
);
var SymbolDefaultPrecisionConstants = {
  PRICE: 2,
  VOLUME: 0
};
var Action = (
  /** @class */
  function() {
    function Action2() {
      this._callbacks = [];
    }
    Action2.prototype.subscribe = function(callback) {
      var index = this._callbacks.indexOf(callback);
      if (index < 0) {
        this._callbacks.push(callback);
      }
    };
    Action2.prototype.unsubscribe = function(callback) {
      if (isFunction(callback)) {
        var index = this._callbacks.indexOf(callback);
        if (index > -1) {
          this._callbacks.splice(index, 1);
        }
      } else {
        this._callbacks = [];
      }
    };
    Action2.prototype.execute = function(data) {
      this._callbacks.forEach(function(callback) {
        callback(data);
      });
    };
    Action2.prototype.isEmpty = function() {
      return this._callbacks.length === 0;
    };
    return Action2;
  }()
);
function isTransparent(color) {
  return color === "transparent" || color === "none" || /^[rR][gG][Bb][Aa]\(([\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\s]*,){3}[\s]*0[\s]*\)$/.test(color) || /^[hH][Ss][Ll][Aa]\(([\s]*(360ÔΩú3[0-5][0-9]|[012]?[0-9][0-9]?)[\s]*,)([\s]*((100|[0-9][0-9]?)%|0)[\s]*,){2}([\s]*0[\s]*)\)$/.test(color);
}
function hexToRgb(hex, alpha) {
  var h = hex.replace(/^#/, "");
  var i = parseInt(h, 16);
  var r = i >> 16 & 255;
  var g = i >> 8 & 255;
  var b = i & 255;
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(alpha !== null && alpha !== void 0 ? alpha : 1, ")");
}
var Color = {
  RED: "#F92855",
  GREEN: "#2DC08E",
  WHITE: "#FFFFFF",
  GREY: "#76808F",
  BLUE: "#1677FF"
};
function getDefaultGridStyle() {
  return {
    show: true,
    horizontal: {
      show: true,
      size: 1,
      color: "#EDEDED",
      style: "dashed",
      dashedValue: [2, 2]
    },
    vertical: {
      show: true,
      size: 1,
      color: "#EDEDED",
      style: "dashed",
      dashedValue: [2, 2]
    }
  };
}
function getDefaultCandleStyle() {
  var highLow = {
    show: true,
    color: Color.GREY,
    textOffset: 5,
    textSize: 10,
    textFamily: "Helvetica Neue",
    textWeight: "normal"
  };
  return {
    type: "candle_solid",
    bar: {
      compareRule: "current_open",
      upColor: Color.GREEN,
      downColor: Color.RED,
      noChangeColor: Color.GREY,
      upBorderColor: Color.GREEN,
      downBorderColor: Color.RED,
      noChangeBorderColor: Color.GREY,
      upWickColor: Color.GREEN,
      downWickColor: Color.RED,
      noChangeWickColor: Color.GREY
    },
    area: {
      lineSize: 2,
      lineColor: Color.BLUE,
      smooth: false,
      value: "close",
      backgroundColor: [{
        offset: 0,
        color: hexToRgb(Color.BLUE, 0.01)
      }, {
        offset: 1,
        color: hexToRgb(Color.BLUE, 0.2)
      }],
      point: {
        show: true,
        color: Color.BLUE,
        radius: 4,
        rippleColor: hexToRgb(Color.BLUE, 0.3),
        rippleRadius: 8,
        animation: true,
        animationDuration: 1e3
      }
    },
    priceMark: {
      show: true,
      high: __assign({}, highLow),
      low: __assign({}, highLow),
      last: {
        show: true,
        compareRule: "current_open",
        upColor: Color.GREEN,
        downColor: Color.RED,
        noChangeColor: Color.GREY,
        line: {
          show: true,
          style: "dashed",
          dashedValue: [4, 4],
          size: 1
        },
        text: {
          show: true,
          style: "fill",
          size: 12,
          paddingLeft: 4,
          paddingTop: 4,
          paddingRight: 4,
          paddingBottom: 4,
          borderColor: "transparent",
          borderStyle: "solid",
          borderSize: 0,
          borderDashedValue: [2, 2],
          color: Color.WHITE,
          family: "Helvetica Neue",
          weight: "normal",
          borderRadius: 2
        },
        extendTexts: []
      }
    },
    tooltip: {
      offsetLeft: 4,
      offsetTop: 6,
      offsetRight: 4,
      offsetBottom: 6,
      showRule: "always",
      showType: "standard",
      rect: {
        position: "fixed",
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 4,
        paddingBottom: 4,
        offsetLeft: 4,
        offsetTop: 4,
        offsetRight: 4,
        offsetBottom: 4,
        borderRadius: 4,
        borderSize: 1,
        borderColor: "#F2F3F5",
        color: "#FEFEFE"
      },
      title: {
        show: true,
        size: 14,
        family: "Helvetica Neue",
        weight: "normal",
        color: Color.GREY,
        marginLeft: 8,
        marginTop: 4,
        marginRight: 8,
        marginBottom: 4,
        template: "{ticker} ¬∑ {period}"
      },
      legend: {
        size: 12,
        family: "Helvetica Neue",
        weight: "normal",
        color: Color.GREY,
        marginLeft: 8,
        marginTop: 4,
        marginRight: 8,
        marginBottom: 4,
        defaultValue: "n/a",
        template: [
          { title: "time", value: "{time}" },
          { title: "open", value: "{open}" },
          { title: "high", value: "{high}" },
          { title: "low", value: "{low}" },
          { title: "close", value: "{close}" },
          { title: "volume", value: "{volume}" }
        ]
      },
      features: []
    }
  };
}
function getDefaultIndicatorStyle() {
  var alphaGreen = hexToRgb(Color.GREEN, 0.7);
  var alphaRed = hexToRgb(Color.RED, 0.7);
  return {
    ohlc: {
      compareRule: "current_open",
      upColor: alphaGreen,
      downColor: alphaRed,
      noChangeColor: Color.GREY
    },
    bars: [{
      style: "fill",
      borderStyle: "solid",
      borderSize: 1,
      borderDashedValue: [2, 2],
      upColor: alphaGreen,
      downColor: alphaRed,
      noChangeColor: Color.GREY
    }],
    lines: ["#FF9600", "#935EBD", Color.BLUE, "#E11D74", "#01C5C4"].map(function(color) {
      return {
        style: "solid",
        smooth: false,
        size: 1,
        dashedValue: [2, 2],
        color
      };
    }),
    circles: [{
      style: "fill",
      borderStyle: "solid",
      borderSize: 1,
      borderDashedValue: [2, 2],
      upColor: alphaGreen,
      downColor: alphaRed,
      noChangeColor: Color.GREY
    }],
    lastValueMark: {
      show: false,
      text: {
        show: false,
        style: "fill",
        color: Color.WHITE,
        size: 12,
        family: "Helvetica Neue",
        weight: "normal",
        borderStyle: "solid",
        borderColor: "transparent",
        borderSize: 0,
        borderDashedValue: [2, 2],
        paddingLeft: 4,
        paddingTop: 4,
        paddingRight: 4,
        paddingBottom: 4,
        borderRadius: 2
      }
    },
    tooltip: {
      offsetLeft: 4,
      offsetTop: 6,
      offsetRight: 4,
      offsetBottom: 6,
      showRule: "always",
      showType: "standard",
      title: {
        show: true,
        showName: true,
        showParams: true,
        size: 12,
        family: "Helvetica Neue",
        weight: "normal",
        color: Color.GREY,
        marginLeft: 8,
        marginTop: 4,
        marginRight: 8,
        marginBottom: 4
      },
      legend: {
        size: 12,
        family: "Helvetica Neue",
        weight: "normal",
        color: Color.GREY,
        marginLeft: 8,
        marginTop: 4,
        marginRight: 8,
        marginBottom: 4,
        defaultValue: "n/a"
      },
      features: []
    }
  };
}
function getDefaultAxisStyle() {
  return {
    show: true,
    size: "auto",
    axisLine: {
      show: true,
      color: "#DDDDDD",
      size: 1
    },
    tickText: {
      show: true,
      color: Color.GREY,
      size: 12,
      family: "Helvetica Neue",
      weight: "normal",
      marginStart: 4,
      marginEnd: 6
    },
    tickLine: {
      show: true,
      size: 1,
      length: 3,
      color: "#DDDDDD"
    }
  };
}
function getDefaultCrosshairStyle() {
  return {
    show: true,
    horizontal: {
      show: true,
      line: {
        show: true,
        style: "dashed",
        dashedValue: [4, 2],
        size: 1,
        color: Color.GREY
      },
      text: {
        show: true,
        style: "fill",
        color: Color.WHITE,
        size: 12,
        family: "Helvetica Neue",
        weight: "normal",
        borderStyle: "solid",
        borderDashedValue: [2, 2],
        borderSize: 1,
        borderColor: Color.GREY,
        borderRadius: 2,
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 4,
        paddingBottom: 4,
        backgroundColor: Color.GREY
      },
      features: []
    },
    vertical: {
      show: true,
      line: {
        show: true,
        style: "dashed",
        dashedValue: [4, 2],
        size: 1,
        color: Color.GREY
      },
      text: {
        show: true,
        style: "fill",
        color: Color.WHITE,
        size: 12,
        family: "Helvetica Neue",
        weight: "normal",
        borderStyle: "solid",
        borderDashedValue: [2, 2],
        borderSize: 1,
        borderColor: Color.GREY,
        borderRadius: 2,
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 4,
        paddingBottom: 4,
        backgroundColor: Color.GREY
      }
    }
  };
}
function getDefaultOverlayStyle() {
  var pointBorderColor = hexToRgb(Color.BLUE, 0.35);
  var alphaBg = hexToRgb(Color.BLUE, 0.25);
  function text2() {
    return {
      style: "fill",
      color: Color.WHITE,
      size: 12,
      family: "Helvetica Neue",
      weight: "normal",
      borderStyle: "solid",
      borderDashedValue: [2, 2],
      borderSize: 1,
      borderRadius: 2,
      borderColor: Color.BLUE,
      paddingLeft: 4,
      paddingRight: 4,
      paddingTop: 4,
      paddingBottom: 4,
      backgroundColor: Color.BLUE
    };
  }
  return {
    point: {
      color: Color.BLUE,
      borderColor: pointBorderColor,
      borderSize: 1,
      radius: 5,
      activeColor: Color.BLUE,
      activeBorderColor: pointBorderColor,
      activeBorderSize: 3,
      activeRadius: 5
    },
    line: {
      style: "solid",
      smooth: false,
      color: Color.BLUE,
      size: 1,
      dashedValue: [2, 2]
    },
    rect: {
      style: "fill",
      color: alphaBg,
      borderColor: Color.BLUE,
      borderSize: 1,
      borderRadius: 0,
      borderStyle: "solid",
      borderDashedValue: [2, 2]
    },
    polygon: {
      style: "fill",
      color: Color.BLUE,
      borderColor: Color.BLUE,
      borderSize: 1,
      borderStyle: "solid",
      borderDashedValue: [2, 2]
    },
    circle: {
      style: "fill",
      color: alphaBg,
      borderColor: Color.BLUE,
      borderSize: 1,
      borderStyle: "solid",
      borderDashedValue: [2, 2]
    },
    arc: {
      style: "solid",
      color: Color.BLUE,
      size: 1,
      dashedValue: [2, 2]
    },
    text: text2()
  };
}
function getDefaultSeparatorStyle() {
  return {
    size: 1,
    color: "#DDDDDD",
    fill: true,
    activeBackgroundColor: hexToRgb(Color.BLUE, 0.08)
  };
}
function getDefaultStyles() {
  return {
    grid: getDefaultGridStyle(),
    candle: getDefaultCandleStyle(),
    indicator: getDefaultIndicatorStyle(),
    xAxis: getDefaultAxisStyle(),
    yAxis: getDefaultAxisStyle(),
    separator: getDefaultSeparatorStyle(),
    crosshair: getDefaultCrosshairStyle(),
    overlay: getDefaultOverlayStyle()
  };
}
function eachFigures(indicator, dataIndex, defaultStyles, eachFigureCallback) {
  var result = indicator.result;
  var figures2 = indicator.figures;
  var styles2 = indicator.styles;
  var circleStyles = formatValue(styles2, "circles", defaultStyles.circles);
  var circleStyleCount = circleStyles.length;
  var barStyles = formatValue(styles2, "bars", defaultStyles.bars);
  var barStyleCount = barStyles.length;
  var lineStyles = formatValue(styles2, "lines", defaultStyles.lines);
  var lineStyleCount = lineStyles.length;
  var circleCount = 0;
  var barCount = 0;
  var lineCount = 0;
  var defaultFigureStyles;
  var figureIndex = 0;
  figures2.forEach(function(figure) {
    var _a;
    switch (figure.type) {
      case "circle": {
        figureIndex = circleCount;
        var styles_1 = circleStyles[circleCount % circleStyleCount];
        defaultFigureStyles = __assign(__assign({}, styles_1), { color: styles_1.noChangeColor });
        circleCount++;
        break;
      }
      case "bar": {
        figureIndex = barCount;
        var styles_2 = barStyles[barCount % barStyleCount];
        defaultFigureStyles = __assign(__assign({}, styles_2), { color: styles_2.noChangeColor });
        barCount++;
        break;
      }
      case "line": {
        figureIndex = lineCount;
        defaultFigureStyles = lineStyles[lineCount % lineStyleCount];
        lineCount++;
        break;
      }
    }
    if (isValid(figure.type)) {
      var ss = (_a = figure.styles) === null || _a === void 0 ? void 0 : _a.call(figure, {
        data: {
          prev: result[dataIndex - 1],
          current: result[dataIndex],
          next: result[dataIndex + 1]
        },
        indicator,
        defaultStyles
      });
      eachFigureCallback(figure, __assign(__assign({}, defaultFigureStyles), ss), figureIndex);
    }
  });
}
var IndicatorImp = (
  /** @class */
  function() {
    function IndicatorImp2(indicator) {
      this.precision = 4;
      this.calcParams = [];
      this.shouldOhlc = false;
      this.shouldFormatBigNumber = false;
      this.visible = true;
      this.zLevel = 0;
      this.series = "normal";
      this.figures = [];
      this.minValue = null;
      this.maxValue = null;
      this.styles = null;
      this.shouldUpdate = function(prev, current) {
        var calc = JSON.stringify(prev.calcParams) !== JSON.stringify(current.calcParams) || prev.figures !== current.figures || prev.calc !== current.calc;
        var draw = calc || prev.shortName !== current.shortName || prev.series !== current.series || prev.minValue !== current.minValue || prev.maxValue !== current.maxValue || prev.precision !== current.precision || prev.shouldOhlc !== current.shouldOhlc || prev.shouldFormatBigNumber !== current.shouldFormatBigNumber || prev.visible !== current.visible || prev.zLevel !== current.zLevel || prev.extendData !== current.extendData || prev.regenerateFigures !== current.regenerateFigures || prev.createTooltipDataSource !== current.createTooltipDataSource || prev.draw !== current.draw;
        return { calc, draw };
      };
      this.calc = function() {
        return [];
      };
      this.regenerateFigures = null;
      this.createTooltipDataSource = null;
      this.draw = null;
      this.result = [];
      this._lockSeriesPrecision = false;
      this.override(indicator);
      this._lockSeriesPrecision = false;
    }
    IndicatorImp2.prototype.override = function(indicator) {
      var _a, _b;
      var _c = this, result = _c.result, currentOthers = __rest(_c, ["result"]);
      this._prevIndicator = __assign(__assign({}, clone(currentOthers)), { result });
      var id = indicator.id, name = indicator.name, shortName = indicator.shortName, precision = indicator.precision, styles2 = indicator.styles, figures2 = indicator.figures, calcParams = indicator.calcParams, others = __rest(indicator, ["id", "name", "shortName", "precision", "styles", "figures", "calcParams"]);
      if (!isString(this.id) && isString(id)) {
        this.id = id;
      }
      if (!isString(this.name)) {
        this.name = name !== null && name !== void 0 ? name : "";
      }
      this.shortName = (_a = shortName !== null && shortName !== void 0 ? shortName : this.shortName) !== null && _a !== void 0 ? _a : this.name;
      if (isNumber(precision)) {
        this.precision = precision;
        this._lockSeriesPrecision = true;
      }
      if (isValid(styles2)) {
        (_b = this.styles) !== null && _b !== void 0 ? _b : this.styles = {};
        merge(this.styles, styles2);
      }
      merge(this, others);
      if (isValid(calcParams)) {
        this.calcParams = calcParams;
        if (isFunction(this.regenerateFigures)) {
          this.figures = this.regenerateFigures(this.calcParams);
        }
      }
      this.figures = figures2 !== null && figures2 !== void 0 ? figures2 : this.figures;
    };
    IndicatorImp2.prototype.setSeriesPrecision = function(precision) {
      if (!this._lockSeriesPrecision) {
        this.precision = precision;
      }
    };
    IndicatorImp2.prototype.shouldUpdateImp = function() {
      var sort = this._prevIndicator.zLevel !== this.zLevel;
      var result = this.shouldUpdate(this._prevIndicator, this);
      if (isBoolean(result)) {
        return { calc: result, draw: result, sort };
      }
      return __assign(__assign({}, result), { sort });
    };
    IndicatorImp2.prototype.calcImp = function(dataList) {
      return __awaiter(this, void 0, void 0, function() {
        var result;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 3]);
              return [4, this.calc(dataList, this)];
            case 1:
              result = _a.sent();
              this.result = result;
              return [2, true];
            case 2:
              _a.sent();
              return [2, false];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    IndicatorImp2.extend = function(template) {
      var Custom = (
        /** @class */
        function(_super) {
          __extends(Custom2, _super);
          function Custom2() {
            return _super.call(this, template) || this;
          }
          return Custom2;
        }(IndicatorImp2)
      );
      return Custom;
    };
    return IndicatorImp2;
  }()
);
var averagePrice = {
  name: "AVP",
  shortName: "AVP",
  series: "price",
  precision: 2,
  figures: [
    { key: "avp", title: "AVP: ", type: "line" }
  ],
  calc: function(dataList) {
    var totalTurnover = 0;
    var totalVolume = 0;
    return dataList.map(function(kLineData) {
      var _a, _b;
      var avp = {};
      var turnover = (_a = kLineData.turnover) !== null && _a !== void 0 ? _a : 0;
      var volume2 = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;
      totalTurnover += turnover;
      totalVolume += volume2;
      if (totalVolume !== 0) {
        avp.avp = totalTurnover / totalVolume;
      }
      return avp;
    });
  }
};
var awesomeOscillator = {
  name: "AO",
  shortName: "AO",
  calcParams: [5, 34],
  figures: [{
    key: "ao",
    title: "AO: ",
    type: "bar",
    baseValue: 0,
    styles: function(_a) {
      var _b, _c;
      var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;
      var prev = data.prev, current = data.current;
      var prevAo = (_b = prev === null || prev === void 0 ? void 0 : prev.ao) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
      var currentAo = (_c = current === null || current === void 0 ? void 0 : current.ao) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER;
      var color = "";
      if (currentAo > prevAo) {
        color = formatValue(indicator.styles, "bars[0].upColor", defaultStyles.bars[0].upColor);
      } else {
        color = formatValue(indicator.styles, "bars[0].downColor", defaultStyles.bars[0].downColor);
      }
      var style = currentAo > prevAo ? "stroke" : "fill";
      return { color, style, borderColor: color };
    }
  }],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var maxPeriod = Math.max(params[0], params[1]);
    var shortSum = 0;
    var longSum = 0;
    var short = 0;
    var long = 0;
    return dataList.map(function(kLineData, i) {
      var ao = {};
      var middle = (kLineData.low + kLineData.high) / 2;
      shortSum += middle;
      longSum += middle;
      if (i >= params[0] - 1) {
        short = shortSum / params[0];
        var agoKLineData = dataList[i - (params[0] - 1)];
        shortSum -= (agoKLineData.low + agoKLineData.high) / 2;
      }
      if (i >= params[1] - 1) {
        long = longSum / params[1];
        var agoKLineData = dataList[i - (params[1] - 1)];
        longSum -= (agoKLineData.low + agoKLineData.high) / 2;
      }
      if (i >= maxPeriod - 1) {
        ao.ao = short - long;
      }
      return ao;
    });
  }
};
var bias = {
  name: "BIAS",
  shortName: "BIAS",
  calcParams: [6, 12, 24],
  figures: [
    { key: "bias1", title: "BIAS6: ", type: "line" },
    { key: "bias2", title: "BIAS12: ", type: "line" },
    { key: "bias3", title: "BIAS24: ", type: "line" }
  ],
  regenerateFigures: function(params) {
    return params.map(function(p, i) {
      return { key: "bias".concat(i + 1), title: "BIAS".concat(p, ": "), type: "line" };
    });
  },
  calc: function(dataList, indicator) {
    var params = indicator.calcParams, figures2 = indicator.figures;
    var closeSums = [];
    return dataList.map(function(kLineData, i) {
      var bias2 = {};
      var close = kLineData.close;
      params.forEach(function(p, index) {
        var _a;
        closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;
        if (i >= p - 1) {
          var mean = closeSums[index] / params[index];
          bias2[figures2[index].key] = (close - mean) / mean * 100;
          closeSums[index] -= dataList[i - (p - 1)].close;
        }
      });
      return bias2;
    });
  }
};
function getBollMd(dataList, ma) {
  var dataSize = dataList.length;
  var sum = 0;
  dataList.forEach(function(data) {
    var closeMa = data.close - ma;
    sum += closeMa * closeMa;
  });
  sum = Math.abs(sum);
  return Math.sqrt(sum / dataSize);
}
var bollingerBands = {
  name: "BOLL",
  shortName: "BOLL",
  series: "price",
  calcParams: [20, 2],
  precision: 2,
  shouldOhlc: true,
  figures: [
    { key: "up", title: "UP: ", type: "line" },
    { key: "mid", title: "MID: ", type: "line" },
    { key: "dn", title: "DN: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var p = params[0] - 1;
    var closeSum = 0;
    return dataList.map(function(kLineData, i) {
      var close = kLineData.close;
      var boll = {};
      closeSum += close;
      if (i >= p) {
        boll.mid = closeSum / params[0];
        var md = getBollMd(dataList.slice(i - p, i + 1), boll.mid);
        boll.up = boll.mid + params[1] * md;
        boll.dn = boll.mid - params[1] * md;
        closeSum -= dataList[i - p].close;
      }
      return boll;
    });
  }
};
var brar = {
  name: "BRAR",
  shortName: "BRAR",
  calcParams: [26],
  figures: [
    { key: "br", title: "BR: ", type: "line" },
    { key: "ar", title: "AR: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var hcy = 0;
    var cyl = 0;
    var ho = 0;
    var ol = 0;
    return dataList.map(function(kLineData, i) {
      var _a, _b;
      var brar2 = {};
      var high = kLineData.high;
      var low = kLineData.low;
      var open = kLineData.open;
      var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
      ho += high - open;
      ol += open - low;
      hcy += high - prevClose;
      cyl += prevClose - low;
      if (i >= params[0] - 1) {
        if (ol !== 0) {
          brar2.ar = ho / ol * 100;
        } else {
          brar2.ar = 0;
        }
        if (cyl !== 0) {
          brar2.br = hcy / cyl * 100;
        } else {
          brar2.br = 0;
        }
        var agoKLineData = dataList[i - (params[0] - 1)];
        var agoHigh = agoKLineData.high;
        var agoLow = agoKLineData.low;
        var agoOpen = agoKLineData.open;
        var agoPreClose = ((_b = dataList[i - params[0]]) !== null && _b !== void 0 ? _b : dataList[i - (params[0] - 1)]).close;
        hcy -= agoHigh - agoPreClose;
        cyl -= agoPreClose - agoLow;
        ho -= agoHigh - agoOpen;
        ol -= agoOpen - agoLow;
      }
      return brar2;
    });
  }
};
var bullAndBearIndex = {
  name: "BBI",
  shortName: "BBI",
  series: "price",
  precision: 2,
  calcParams: [3, 6, 12, 24],
  shouldOhlc: true,
  figures: [
    { key: "bbi", title: "BBI: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var maxPeriod = Math.max.apply(Math, __spreadArray([], __read(params), false));
    var closeSums = [];
    var mas = [];
    return dataList.map(function(kLineData, i) {
      var bbi = {};
      var close = kLineData.close;
      params.forEach(function(p, index) {
        var _a;
        closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;
        if (i >= p - 1) {
          mas[index] = closeSums[index] / p;
          closeSums[index] -= dataList[i - (p - 1)].close;
        }
      });
      if (i >= maxPeriod - 1) {
        var maSum_1 = 0;
        mas.forEach(function(ma) {
          maSum_1 += ma;
        });
        bbi.bbi = maSum_1 / 4;
      }
      return bbi;
    });
  }
};
var commodityChannelIndex = {
  name: "CCI",
  shortName: "CCI",
  calcParams: [20],
  figures: [
    { key: "cci", title: "CCI: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var p = params[0] - 1;
    var tpSum = 0;
    var tpList = [];
    return dataList.map(function(kLineData, i) {
      var cci = {};
      var tp = (kLineData.high + kLineData.low + kLineData.close) / 3;
      tpSum += tp;
      tpList.push(tp);
      if (i >= p) {
        var maTp_1 = tpSum / params[0];
        var sliceTpList = tpList.slice(i - p, i + 1);
        var sum_1 = 0;
        sliceTpList.forEach(function(tp2) {
          sum_1 += Math.abs(tp2 - maTp_1);
        });
        var md = sum_1 / params[0];
        cci.cci = md !== 0 ? (tp - maTp_1) / md / 0.015 : 0;
        var agoTp = (dataList[i - p].high + dataList[i - p].low + dataList[i - p].close) / 3;
        tpSum -= agoTp;
      }
      return cci;
    });
  }
};
var currentRatio = {
  name: "CR",
  shortName: "CR",
  calcParams: [26, 10, 20, 40, 60],
  figures: [
    { key: "cr", title: "CR: ", type: "line" },
    { key: "ma1", title: "MA1: ", type: "line" },
    { key: "ma2", title: "MA2: ", type: "line" },
    { key: "ma3", title: "MA3: ", type: "line" },
    { key: "ma4", title: "MA4: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var ma1ForwardPeriod = Math.ceil(params[1] / 2.5 + 1);
    var ma2ForwardPeriod = Math.ceil(params[2] / 2.5 + 1);
    var ma3ForwardPeriod = Math.ceil(params[3] / 2.5 + 1);
    var ma4ForwardPeriod = Math.ceil(params[4] / 2.5 + 1);
    var ma1Sum = 0;
    var ma1List = [];
    var ma2Sum = 0;
    var ma2List = [];
    var ma3Sum = 0;
    var ma3List = [];
    var ma4Sum = 0;
    var ma4List = [];
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a, _b, _c, _d, _e;
      var cr = {};
      var prevData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
      var prevMid = (prevData.high + prevData.close + prevData.low + prevData.open) / 4;
      var highSubPreMid = Math.max(0, kLineData.high - prevMid);
      var preMidSubLow = Math.max(0, prevMid - kLineData.low);
      if (i >= params[0] - 1) {
        if (preMidSubLow !== 0) {
          cr.cr = highSubPreMid / preMidSubLow * 100;
        } else {
          cr.cr = 0;
        }
        ma1Sum += cr.cr;
        ma2Sum += cr.cr;
        ma3Sum += cr.cr;
        ma4Sum += cr.cr;
        if (i >= params[0] + params[1] - 2) {
          ma1List.push(ma1Sum / params[1]);
          if (i >= params[0] + params[1] + ma1ForwardPeriod - 3) {
            cr.ma1 = ma1List[ma1List.length - 1 - ma1ForwardPeriod];
          }
          ma1Sum -= (_b = result[i - (params[1] - 1)].cr) !== null && _b !== void 0 ? _b : 0;
        }
        if (i >= params[0] + params[2] - 2) {
          ma2List.push(ma2Sum / params[2]);
          if (i >= params[0] + params[2] + ma2ForwardPeriod - 3) {
            cr.ma2 = ma2List[ma2List.length - 1 - ma2ForwardPeriod];
          }
          ma2Sum -= (_c = result[i - (params[2] - 1)].cr) !== null && _c !== void 0 ? _c : 0;
        }
        if (i >= params[0] + params[3] - 2) {
          ma3List.push(ma3Sum / params[3]);
          if (i >= params[0] + params[3] + ma3ForwardPeriod - 3) {
            cr.ma3 = ma3List[ma3List.length - 1 - ma3ForwardPeriod];
          }
          ma3Sum -= (_d = result[i - (params[3] - 1)].cr) !== null && _d !== void 0 ? _d : 0;
        }
        if (i >= params[0] + params[4] - 2) {
          ma4List.push(ma4Sum / params[4]);
          if (i >= params[0] + params[4] + ma4ForwardPeriod - 3) {
            cr.ma4 = ma4List[ma4List.length - 1 - ma4ForwardPeriod];
          }
          ma4Sum -= (_e = result[i - (params[4] - 1)].cr) !== null && _e !== void 0 ? _e : 0;
        }
      }
      result.push(cr);
    });
    return result;
  }
};
var differentOfMovingAverage = {
  name: "DMA",
  shortName: "DMA",
  calcParams: [10, 50, 10],
  figures: [
    { key: "dma", title: "DMA: ", type: "line" },
    { key: "ama", title: "AMA: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var maxPeriod = Math.max(params[0], params[1]);
    var closeSum1 = 0;
    var closeSum2 = 0;
    var dmaSum = 0;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a;
      var dma = {};
      var close = kLineData.close;
      closeSum1 += close;
      closeSum2 += close;
      var ma1 = 0;
      var ma2 = 0;
      if (i >= params[0] - 1) {
        ma1 = closeSum1 / params[0];
        closeSum1 -= dataList[i - (params[0] - 1)].close;
      }
      if (i >= params[1] - 1) {
        ma2 = closeSum2 / params[1];
        closeSum2 -= dataList[i - (params[1] - 1)].close;
      }
      if (i >= maxPeriod - 1) {
        var dif = ma1 - ma2;
        dma.dma = dif;
        dmaSum += dif;
        if (i >= maxPeriod + params[2] - 2) {
          dma.ama = dmaSum / params[2];
          dmaSum -= (_a = result[i - (params[2] - 1)].dma) !== null && _a !== void 0 ? _a : 0;
        }
      }
      result.push(dma);
    });
    return result;
  }
};
var directionalMovementIndex = {
  name: "DMI",
  shortName: "DMI",
  calcParams: [14, 6],
  figures: [
    { key: "pdi", title: "PDI: ", type: "line" },
    { key: "mdi", title: "MDI: ", type: "line" },
    { key: "adx", title: "ADX: ", type: "line" },
    { key: "adxr", title: "ADXR: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var trSum = 0;
    var hSum = 0;
    var lSum = 0;
    var mtr = 0;
    var dmp = 0;
    var dmm = 0;
    var dxSum = 0;
    var adx = 0;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a, _b;
      var dmi = {};
      var prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
      var preClose = prevKLineData.close;
      var high = kLineData.high;
      var low = kLineData.low;
      var hl = high - low;
      var hcy = Math.abs(high - preClose);
      var lcy = Math.abs(preClose - low);
      var hhy = high - prevKLineData.high;
      var lyl = prevKLineData.low - low;
      var tr = Math.max(Math.max(hl, hcy), lcy);
      var h = hhy > 0 && hhy > lyl ? hhy : 0;
      var l = lyl > 0 && lyl > hhy ? lyl : 0;
      trSum += tr;
      hSum += h;
      lSum += l;
      if (i >= params[0] - 1) {
        if (i > params[0] - 1) {
          mtr = mtr - mtr / params[0] + tr;
          dmp = dmp - dmp / params[0] + h;
          dmm = dmm - dmm / params[0] + l;
        } else {
          mtr = trSum;
          dmp = hSum;
          dmm = lSum;
        }
        var pdi = 0;
        var mdi = 0;
        if (mtr !== 0) {
          pdi = dmp * 100 / mtr;
          mdi = dmm * 100 / mtr;
        }
        dmi.pdi = pdi;
        dmi.mdi = mdi;
        var dx = 0;
        if (mdi + pdi !== 0) {
          dx = Math.abs(mdi - pdi) / (mdi + pdi) * 100;
        }
        dxSum += dx;
        if (i >= params[0] * 2 - 2) {
          if (i > params[0] * 2 - 2) {
            adx = (adx * (params[0] - 1) + dx) / params[0];
          } else {
            adx = dxSum / params[0];
          }
          dmi.adx = adx;
          if (i >= params[0] * 2 + params[1] - 3) {
            dmi.adxr = (((_b = result[i - (params[1] - 1)].adx) !== null && _b !== void 0 ? _b : 0) + adx) / 2;
          }
        }
      }
      result.push(dmi);
    });
    return result;
  }
};
var easeOfMovementValue = {
  name: "EMV",
  shortName: "EMV",
  calcParams: [14, 9],
  figures: [
    { key: "emv", title: "EMV: ", type: "line" },
    { key: "maEmv", title: "MAEMV: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var emvValueSum = 0;
    var emvValueList = [];
    return dataList.map(function(kLineData, i) {
      var _a;
      var emv = {};
      if (i > 0) {
        var prevKLineData = dataList[i - 1];
        var high = kLineData.high;
        var low = kLineData.low;
        var volume2 = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;
        var distanceMoved = (high + low) / 2 - (prevKLineData.high + prevKLineData.low) / 2;
        if (volume2 === 0 || high - low === 0) {
          emv.emv = 0;
        } else {
          var ratio = volume2 / 1e8 / (high - low);
          emv.emv = distanceMoved / ratio;
        }
        emvValueSum += emv.emv;
        emvValueList.push(emv.emv);
        if (i >= params[0]) {
          emv.maEmv = emvValueSum / params[0];
          emvValueSum -= emvValueList[i - params[0]];
        }
      }
      return emv;
    });
  }
};
var exponentialMovingAverage = {
  name: "EMA",
  shortName: "EMA",
  series: "price",
  calcParams: [6, 12, 20],
  precision: 2,
  shouldOhlc: true,
  figures: [
    { key: "ema1", title: "EMA6: ", type: "line" },
    { key: "ema2", title: "EMA12: ", type: "line" },
    { key: "ema3", title: "EMA20: ", type: "line" }
  ],
  regenerateFigures: function(params) {
    return params.map(function(p, i) {
      return { key: "ema".concat(i + 1), title: "EMA".concat(p, ": "), type: "line" };
    });
  },
  calc: function(dataList, indicator) {
    var params = indicator.calcParams, figures2 = indicator.figures;
    var closeSum = 0;
    var emaValues = [];
    return dataList.map(function(kLineData, i) {
      var ema = {};
      var close = kLineData.close;
      closeSum += close;
      params.forEach(function(p, index) {
        if (i >= p - 1) {
          if (i > p - 1) {
            emaValues[index] = (2 * close + (p - 1) * emaValues[index]) / (p + 1);
          } else {
            emaValues[index] = closeSum / p;
          }
          ema[figures2[index].key] = emaValues[index];
        }
      });
      return ema;
    });
  }
};
var momentum = {
  name: "MTM",
  shortName: "MTM",
  calcParams: [12, 6],
  figures: [
    { key: "mtm", title: "MTM: ", type: "line" },
    { key: "maMtm", title: "MAMTM: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var mtmSum = 0;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a;
      var mtm = {};
      if (i >= params[0]) {
        var close_1 = kLineData.close;
        var agoClose = dataList[i - params[0]].close;
        mtm.mtm = close_1 - agoClose;
        mtmSum += mtm.mtm;
        if (i >= params[0] + params[1] - 1) {
          mtm.maMtm = mtmSum / params[1];
          mtmSum -= (_a = result[i - (params[1] - 1)].mtm) !== null && _a !== void 0 ? _a : 0;
        }
      }
      result.push(mtm);
    });
    return result;
  }
};
var movingAverage = {
  name: "MA",
  shortName: "MA",
  series: "price",
  calcParams: [5, 10, 30, 60],
  precision: 2,
  shouldOhlc: true,
  figures: [
    { key: "ma1", title: "MA5: ", type: "line" },
    { key: "ma2", title: "MA10: ", type: "line" },
    { key: "ma3", title: "MA30: ", type: "line" },
    { key: "ma4", title: "MA60: ", type: "line" }
  ],
  regenerateFigures: function(params) {
    return params.map(function(p, i) {
      return { key: "ma".concat(i + 1), title: "MA".concat(p, ": "), type: "line" };
    });
  },
  calc: function(dataList, indicator) {
    var params = indicator.calcParams, figures2 = indicator.figures;
    var closeSums = [];
    return dataList.map(function(kLineData, i) {
      var ma = {};
      var close = kLineData.close;
      params.forEach(function(p, index) {
        var _a;
        closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;
        if (i >= p - 1) {
          ma[figures2[index].key] = closeSums[index] / p;
          closeSums[index] -= dataList[i - (p - 1)].close;
        }
      });
      return ma;
    });
  }
};
var movingAverageConvergenceDivergence = {
  name: "MACD",
  shortName: "MACD",
  calcParams: [12, 26, 9],
  figures: [
    { key: "dif", title: "DIF: ", type: "line" },
    { key: "dea", title: "DEA: ", type: "line" },
    {
      key: "macd",
      title: "MACD: ",
      type: "bar",
      baseValue: 0,
      styles: function(_a) {
        var _b, _c;
        var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;
        var prev = data.prev, current = data.current;
        var prevMacd = (_b = prev === null || prev === void 0 ? void 0 : prev.macd) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
        var currentMacd = (_c = current === null || current === void 0 ? void 0 : current.macd) !== null && _c !== void 0 ? _c : Number.MIN_SAFE_INTEGER;
        var color = "";
        if (currentMacd > 0) {
          color = formatValue(indicator.styles, "bars[0].upColor", defaultStyles.bars[0].upColor);
        } else if (currentMacd < 0) {
          color = formatValue(indicator.styles, "bars[0].downColor", defaultStyles.bars[0].downColor);
        } else {
          color = formatValue(indicator.styles, "bars[0].noChangeColor", defaultStyles.bars[0].noChangeColor);
        }
        var style = prevMacd < currentMacd ? "stroke" : "fill";
        return { style, color, borderColor: color };
      }
    }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var closeSum = 0;
    var emaShort = 0;
    var emaLong = 0;
    var dif = 0;
    var difSum = 0;
    var dea = 0;
    var maxPeriod = Math.max(params[0], params[1]);
    return dataList.map(function(kLineData, i) {
      var macd = {};
      var close = kLineData.close;
      closeSum += close;
      if (i >= params[0] - 1) {
        if (i > params[0] - 1) {
          emaShort = (2 * close + (params[0] - 1) * emaShort) / (params[0] + 1);
        } else {
          emaShort = closeSum / params[0];
        }
      }
      if (i >= params[1] - 1) {
        if (i > params[1] - 1) {
          emaLong = (2 * close + (params[1] - 1) * emaLong) / (params[1] + 1);
        } else {
          emaLong = closeSum / params[1];
        }
      }
      if (i >= maxPeriod - 1) {
        dif = emaShort - emaLong;
        macd.dif = dif;
        difSum += dif;
        if (i >= maxPeriod + params[2] - 2) {
          if (i > maxPeriod + params[2] - 2) {
            dea = (dif * 2 + dea * (params[2] - 1)) / (params[2] + 1);
          } else {
            dea = difSum / params[2];
          }
          macd.macd = (dif - dea) * 2;
          macd.dea = dea;
        }
      }
      return macd;
    });
  }
};
var onBalanceVolume = {
  name: "OBV",
  shortName: "OBV",
  calcParams: [30],
  figures: [
    { key: "obv", title: "OBV: ", type: "line" },
    { key: "maObv", title: "MAOBV: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var obvSum = 0;
    var oldObv = 0;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a, _b, _c, _d;
      var prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
      if (kLineData.close < prevKLineData.close) {
        oldObv -= (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;
      } else if (kLineData.close > prevKLineData.close) {
        oldObv += (_c = kLineData.volume) !== null && _c !== void 0 ? _c : 0;
      }
      var obv = { obv: oldObv };
      obvSum += oldObv;
      if (i >= params[0] - 1) {
        obv.maObv = obvSum / params[0];
        obvSum -= (_d = result[i - (params[0] - 1)].obv) !== null && _d !== void 0 ? _d : 0;
      }
      result.push(obv);
    });
    return result;
  }
};
var priceAndVolumeTrend = {
  name: "PVT",
  shortName: "PVT",
  figures: [
    { key: "pvt", title: "PVT: ", type: "line" }
  ],
  calc: function(dataList) {
    var sum = 0;
    return dataList.map(function(kLineData, i) {
      var _a, _b;
      var pvt = {};
      var close = kLineData.close;
      var volume2 = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 1;
      var prevClose = ((_b = dataList[i - 1]) !== null && _b !== void 0 ? _b : kLineData).close;
      var x = 0;
      var total = prevClose * volume2;
      if (total !== 0) {
        x = (close - prevClose) / total;
      }
      sum += x;
      pvt.pvt = sum;
      return pvt;
    });
  }
};
var psychologicalLine = {
  name: "PSY",
  shortName: "PSY",
  calcParams: [12, 6],
  figures: [
    { key: "psy", title: "PSY: ", type: "line" },
    { key: "maPsy", title: "MAPSY: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var upCount = 0;
    var psySum = 0;
    var upList = [];
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a, _b;
      var psy = {};
      var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
      var upFlag = kLineData.close - prevClose > 0 ? 1 : 0;
      upList.push(upFlag);
      upCount += upFlag;
      if (i >= params[0] - 1) {
        psy.psy = upCount / params[0] * 100;
        psySum += psy.psy;
        if (i >= params[0] + params[1] - 2) {
          psy.maPsy = psySum / params[1];
          psySum -= (_b = result[i - (params[1] - 1)].psy) !== null && _b !== void 0 ? _b : 0;
        }
        upCount -= upList[i - (params[0] - 1)];
      }
      result.push(psy);
    });
    return result;
  }
};
var rateOfChange = {
  name: "ROC",
  shortName: "ROC",
  calcParams: [12, 6],
  figures: [
    { key: "roc", title: "ROC: ", type: "line" },
    { key: "maRoc", title: "MAROC: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var result = [];
    var rocSum = 0;
    dataList.forEach(function(kLineData, i) {
      var _a, _b;
      var roc = {};
      if (i >= params[0] - 1) {
        var close_1 = kLineData.close;
        var agoClose = ((_a = dataList[i - params[0]]) !== null && _a !== void 0 ? _a : dataList[i - (params[0] - 1)]).close;
        if (agoClose !== 0) {
          roc.roc = (close_1 - agoClose) / agoClose * 100;
        } else {
          roc.roc = 0;
        }
        rocSum += roc.roc;
        if (i >= params[0] - 1 + params[1] - 1) {
          roc.maRoc = rocSum / params[1];
          rocSum -= (_b = result[i - (params[1] - 1)].roc) !== null && _b !== void 0 ? _b : 0;
        }
      }
      result.push(roc);
    });
    return result;
  }
};
var relativeStrengthIndex = {
  name: "RSI",
  shortName: "RSI",
  calcParams: [6, 12, 24],
  figures: [
    { key: "rsi1", title: "RSI1: ", type: "line" },
    { key: "rsi2", title: "RSI2: ", type: "line" },
    { key: "rsi3", title: "RSI3: ", type: "line" }
  ],
  regenerateFigures: function(params) {
    return params.map(function(_, index) {
      var num = index + 1;
      return { key: "rsi".concat(num), title: "RSI".concat(num, ": "), type: "line" };
    });
  },
  calc: function(dataList, indicator) {
    var params = indicator.calcParams, figures2 = indicator.figures;
    var sumCloseAs = [];
    var sumCloseBs = [];
    return dataList.map(function(kLineData, i) {
      var _a;
      var rsi = {};
      var prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
      var tmp = kLineData.close - prevClose;
      params.forEach(function(p, index) {
        var _a2, _b, _c;
        if (tmp > 0) {
          sumCloseAs[index] = ((_a2 = sumCloseAs[index]) !== null && _a2 !== void 0 ? _a2 : 0) + tmp;
        } else {
          sumCloseBs[index] = ((_b = sumCloseBs[index]) !== null && _b !== void 0 ? _b : 0) + Math.abs(tmp);
        }
        if (i >= p - 1) {
          if (sumCloseBs[index] !== 0) {
            rsi[figures2[index].key] = 100 - 100 / (1 + sumCloseAs[index] / sumCloseBs[index]);
          } else {
            rsi[figures2[index].key] = 0;
          }
          var agoData = dataList[i - (p - 1)];
          var agoPreData = (_c = dataList[i - p]) !== null && _c !== void 0 ? _c : agoData;
          var agoTmp = agoData.close - agoPreData.close;
          if (agoTmp > 0) {
            sumCloseAs[index] -= agoTmp;
          } else {
            sumCloseBs[index] -= Math.abs(agoTmp);
          }
        }
      });
      return rsi;
    });
  }
};
var simpleMovingAverage = {
  name: "SMA",
  shortName: "SMA",
  series: "price",
  calcParams: [12, 2],
  precision: 2,
  figures: [
    { key: "sma", title: "SMA: ", type: "line" }
  ],
  shouldOhlc: true,
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var closeSum = 0;
    var smaValue = 0;
    return dataList.map(function(kLineData, i) {
      var sma = {};
      var close = kLineData.close;
      closeSum += close;
      if (i >= params[0] - 1) {
        if (i > params[0] - 1) {
          smaValue = (close * params[1] + smaValue * (params[0] - params[1] + 1)) / (params[0] + 1);
        } else {
          smaValue = closeSum / params[0];
        }
        sma.sma = smaValue;
      }
      return sma;
    });
  }
};
var stoch = {
  name: "KDJ",
  shortName: "KDJ",
  calcParams: [9, 3, 3],
  figures: [
    { key: "k", title: "K: ", type: "line" },
    { key: "d", title: "D: ", type: "line" },
    { key: "j", title: "J: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a, _b, _c, _d;
      var kdj = {};
      var close = kLineData.close;
      if (i >= params[0] - 1) {
        var lhn = getMaxMin(dataList.slice(i - (params[0] - 1), i + 1), "high", "low");
        var hn = lhn[0];
        var ln = lhn[1];
        var hnSubLn = hn - ln;
        var rsv = (close - ln) / (hnSubLn === 0 ? 1 : hnSubLn) * 100;
        kdj.k = ((params[1] - 1) * ((_b = (_a = result[i - 1]) === null || _a === void 0 ? void 0 : _a.k) !== null && _b !== void 0 ? _b : 50) + rsv) / params[1];
        kdj.d = ((params[2] - 1) * ((_d = (_c = result[i - 1]) === null || _c === void 0 ? void 0 : _c.d) !== null && _d !== void 0 ? _d : 50) + kdj.k) / params[2];
        kdj.j = 3 * kdj.k - 2 * kdj.d;
      }
      result.push(kdj);
    });
    return result;
  }
};
var stopAndReverse = {
  name: "SAR",
  shortName: "SAR",
  series: "price",
  calcParams: [2, 2, 20],
  precision: 2,
  shouldOhlc: true,
  figures: [
    {
      key: "sar",
      title: "SAR: ",
      type: "circle",
      styles: function(_a) {
        var _b, _c, _d;
        var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;
        var current = data.current;
        var sar = (_b = current === null || current === void 0 ? void 0 : current.sar) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
        var halfHL = (((_c = current === null || current === void 0 ? void 0 : current.high) !== null && _c !== void 0 ? _c : 0) + ((_d = current === null || current === void 0 ? void 0 : current.low) !== null && _d !== void 0 ? _d : 0)) / 2;
        var color = sar < halfHL ? formatValue(indicator.styles, "circles[0].upColor", defaultStyles.circles[0].upColor) : formatValue(indicator.styles, "circles[0].downColor", defaultStyles.circles[0].downColor);
        return { color };
      }
    }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var startAf = params[0] / 100;
    var step = params[1] / 100;
    var maxAf = params[2] / 100;
    var af = startAf;
    var ep = -100;
    var isIncreasing = false;
    var sar = 0;
    return dataList.map(function(kLineData, i) {
      var preSar = sar;
      var high = kLineData.high;
      var low = kLineData.low;
      if (isIncreasing) {
        if (ep === -100 || ep < high) {
          ep = high;
          af = Math.min(af + step, maxAf);
        }
        sar = preSar + af * (ep - preSar);
        var lowMin = Math.min(dataList[Math.max(1, i) - 1].low, low);
        if (sar > kLineData.low) {
          sar = ep;
          af = startAf;
          ep = -100;
          isIncreasing = !isIncreasing;
        } else if (sar > lowMin) {
          sar = lowMin;
        }
      } else {
        if (ep === -100 || ep > low) {
          ep = low;
          af = Math.min(af + step, maxAf);
        }
        sar = preSar + af * (ep - preSar);
        var highMax = Math.max(dataList[Math.max(1, i) - 1].high, high);
        if (sar < kLineData.high) {
          sar = ep;
          af = 0;
          ep = -100;
          isIncreasing = !isIncreasing;
        } else if (sar < highMax) {
          sar = highMax;
        }
      }
      return { high, low, sar };
    });
  }
};
var tripleExponentiallySmoothedAverage = {
  name: "TRIX",
  shortName: "TRIX",
  calcParams: [12, 9],
  figures: [
    { key: "trix", title: "TRIX: ", type: "line" },
    { key: "maTrix", title: "MATRIX: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var closeSum = 0;
    var ema1 = 0;
    var ema2 = 0;
    var oldTr = 0;
    var ema1Sum = 0;
    var ema2Sum = 0;
    var trixSum = 0;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a;
      var trix = {};
      var close = kLineData.close;
      closeSum += close;
      if (i >= params[0] - 1) {
        if (i > params[0] - 1) {
          ema1 = (2 * close + (params[0] - 1) * ema1) / (params[0] + 1);
        } else {
          ema1 = closeSum / params[0];
        }
        ema1Sum += ema1;
        if (i >= params[0] * 2 - 2) {
          if (i > params[0] * 2 - 2) {
            ema2 = (2 * ema1 + (params[0] - 1) * ema2) / (params[0] + 1);
          } else {
            ema2 = ema1Sum / params[0];
          }
          ema2Sum += ema2;
          if (i >= params[0] * 3 - 3) {
            var tr = 0;
            var trixValue = 0;
            if (i > params[0] * 3 - 3) {
              tr = (2 * ema2 + (params[0] - 1) * oldTr) / (params[0] + 1);
              trixValue = (tr - oldTr) / oldTr * 100;
            } else {
              tr = ema2Sum / params[0];
            }
            oldTr = tr;
            trix.trix = trixValue;
            trixSum += trixValue;
            if (i >= params[0] * 3 + params[1] - 4) {
              trix.maTrix = trixSum / params[1];
              trixSum -= (_a = result[i - (params[1] - 1)].trix) !== null && _a !== void 0 ? _a : 0;
            }
          }
        }
      }
      result.push(trix);
    });
    return result;
  }
};
function getVolumeFigure() {
  return {
    key: "volume",
    title: "VOLUME: ",
    type: "bar",
    baseValue: 0,
    styles: function(_a) {
      var data = _a.data, indicator = _a.indicator, defaultStyles = _a.defaultStyles;
      var current = data.current;
      var color = formatValue(indicator.styles, "bars[0].noChangeColor", defaultStyles.bars[0].noChangeColor);
      if (isValid(current)) {
        if (current.close > current.open) {
          color = formatValue(indicator.styles, "bars[0].upColor", defaultStyles.bars[0].upColor);
        } else if (current.close < current.open) {
          color = formatValue(indicator.styles, "bars[0].downColor", defaultStyles.bars[0].downColor);
        }
      }
      return { color };
    }
  };
}
var volume = {
  name: "VOL",
  shortName: "VOL",
  series: "volume",
  calcParams: [5, 10, 20],
  shouldFormatBigNumber: true,
  precision: 0,
  minValue: 0,
  figures: [
    { key: "ma1", title: "MA5: ", type: "line" },
    { key: "ma2", title: "MA10: ", type: "line" },
    { key: "ma3", title: "MA20: ", type: "line" },
    getVolumeFigure()
  ],
  regenerateFigures: function(params) {
    var figures2 = params.map(function(p, i) {
      return { key: "ma".concat(i + 1), title: "MA".concat(p, ": "), type: "line" };
    });
    figures2.push(getVolumeFigure());
    return figures2;
  },
  calc: function(dataList, indicator) {
    var params = indicator.calcParams, figures2 = indicator.figures;
    var volSums = [];
    return dataList.map(function(kLineData, i) {
      var _a;
      var volume2 = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;
      var vol = { volume: volume2, open: kLineData.open, close: kLineData.close };
      params.forEach(function(p, index) {
        var _a2, _b;
        volSums[index] = ((_a2 = volSums[index]) !== null && _a2 !== void 0 ? _a2 : 0) + volume2;
        if (i >= p - 1) {
          vol[figures2[index].key] = volSums[index] / p;
          volSums[index] -= (_b = dataList[i - (p - 1)].volume) !== null && _b !== void 0 ? _b : 0;
        }
      });
      return vol;
    });
  }
};
var volumeRatio = {
  name: "VR",
  shortName: "VR",
  calcParams: [26, 6],
  figures: [
    { key: "vr", title: "VR: ", type: "line" },
    { key: "maVr", title: "MAVR: ", type: "line" }
  ],
  calc: function(dataList, indicator) {
    var params = indicator.calcParams;
    var uvs = 0;
    var dvs = 0;
    var pvs = 0;
    var vrSum = 0;
    var result = [];
    dataList.forEach(function(kLineData, i) {
      var _a, _b, _c, _d, _e;
      var vr = {};
      var close = kLineData.close;
      var preClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
      var volume2 = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;
      if (close > preClose) {
        uvs += volume2;
      } else if (close < preClose) {
        dvs += volume2;
      } else {
        pvs += volume2;
      }
      if (i >= params[0] - 1) {
        var halfPvs = pvs / 2;
        if (dvs + halfPvs === 0) {
          vr.vr = 0;
        } else {
          vr.vr = (uvs + halfPvs) / (dvs + halfPvs) * 100;
        }
        vrSum += vr.vr;
        if (i >= params[0] + params[1] - 2) {
          vr.maVr = vrSum / params[1];
          vrSum -= (_c = result[i - (params[1] - 1)].vr) !== null && _c !== void 0 ? _c : 0;
        }
        var agoData = dataList[i - (params[0] - 1)];
        var agoPreData = (_d = dataList[i - params[0]]) !== null && _d !== void 0 ? _d : agoData;
        var agoClose = agoData.close;
        var agoVolume = (_e = agoData.volume) !== null && _e !== void 0 ? _e : 0;
        if (agoClose > agoPreData.close) {
          uvs -= agoVolume;
        } else if (agoClose < agoPreData.close) {
          dvs -= agoVolume;
        } else {
          pvs -= agoVolume;
        }
      }
      result.push(vr);
    });
    return result;
  }
};
var williamsR = {
  name: "WR",
  shortName: "WR",
  calcParams: [6, 10, 14],
  figures: [
    { key: "wr1", title: "WR1: ", type: "line" },
    { key: "wr2", title: "WR2: ", type: "line" },
    { key: "wr3", title: "WR3: ", type: "line" }
  ],
  regenerateFigures: function(params) {
    return params.map(function(_, i) {
      return { key: "wr".concat(i + 1), title: "WR".concat(i + 1, ": "), type: "line" };
    });
  },
  calc: function(dataList, indicator) {
    var params = indicator.calcParams, figures2 = indicator.figures;
    return dataList.map(function(kLineData, i) {
      var wr = {};
      var close = kLineData.close;
      params.forEach(function(param, index) {
        var p = param - 1;
        if (i >= p) {
          var hln = getMaxMin(dataList.slice(i - p, i + 1), "high", "low");
          var hn = hln[0];
          var ln = hln[1];
          var hnSubLn = hn - ln;
          wr[figures2[index].key] = hnSubLn === 0 ? 0 : (close - hn) / hnSubLn * 100;
        }
      });
      return wr;
    });
  }
};
var indicators = {};
var extensions$2 = [
  averagePrice,
  awesomeOscillator,
  bias,
  bollingerBands,
  brar,
  bullAndBearIndex,
  commodityChannelIndex,
  currentRatio,
  differentOfMovingAverage,
  directionalMovementIndex,
  easeOfMovementValue,
  exponentialMovingAverage,
  momentum,
  movingAverage,
  movingAverageConvergenceDivergence,
  onBalanceVolume,
  priceAndVolumeTrend,
  psychologicalLine,
  rateOfChange,
  relativeStrengthIndex,
  simpleMovingAverage,
  stoch,
  stopAndReverse,
  tripleExponentiallySmoothedAverage,
  volume,
  volumeRatio,
  williamsR
];
extensions$2.forEach(function(indicator) {
  indicators[indicator.name] = IndicatorImp.extend(indicator);
});
function registerIndicator(indicator) {
  indicators[indicator.name] = IndicatorImp.extend(indicator);
}
function getIndicatorClass(name) {
  var _a;
  return (_a = indicators[name]) !== null && _a !== void 0 ? _a : null;
}
function getSupportedIndicators() {
  return Object.keys(indicators);
}
function checkOverlayFigureEvent(targetEventType, figure) {
  var _a;
  var ignoreEvent = (_a = figure === null || figure === void 0 ? void 0 : figure.ignoreEvent) !== null && _a !== void 0 ? _a : false;
  if (isBoolean(ignoreEvent)) {
    return !ignoreEvent;
  }
  return !ignoreEvent.includes(targetEventType);
}
var OVERLAY_DRAW_STEP_START = 1;
var OVERLAY_DRAW_STEP_FINISHED = -1;
var OVERLAY_ID_PREFIX = "overlay_";
var OVERLAY_FIGURE_KEY_PREFIX = "overlay_figure_";
var OverlayImp = (
  /** @class */
  function() {
    function OverlayImp2(overlay) {
      this.groupId = "";
      this.totalStep = 1;
      this.currentStep = OVERLAY_DRAW_STEP_START;
      this.lock = false;
      this.visible = true;
      this.zLevel = 0;
      this.needDefaultPointFigure = false;
      this.needDefaultXAxisFigure = false;
      this.needDefaultYAxisFigure = false;
      this.mode = "normal";
      this.modeSensitivity = 8;
      this.points = [];
      this.styles = null;
      this.createPointFigures = null;
      this.createXAxisFigures = null;
      this.createYAxisFigures = null;
      this.performEventPressedMove = null;
      this.performEventMoveForDrawing = null;
      this.onDrawStart = null;
      this.onDrawing = null;
      this.onDrawEnd = null;
      this.onClick = null;
      this.onDoubleClick = null;
      this.onRightClick = null;
      this.onPressedMoveStart = null;
      this.onPressedMoving = null;
      this.onPressedMoveEnd = null;
      this.onMouseMove = null;
      this.onMouseEnter = null;
      this.onMouseLeave = null;
      this.onRemoved = null;
      this.onSelected = null;
      this.onDeselected = null;
      this._prevZLevel = 0;
      this._prevPressedPoint = null;
      this._prevPressedPoints = [];
      this.override(overlay);
    }
    OverlayImp2.prototype.override = function(overlay) {
      var _a, _b;
      this._prevOverlay = clone(__assign(__assign({}, this), { _prevOverlay: null }));
      var id = overlay.id, name = overlay.name;
      overlay.currentStep;
      var points = overlay.points, styles2 = overlay.styles, others = __rest(overlay, ["id", "name", "currentStep", "points", "styles"]);
      merge(this, others);
      if (!isString(this.name)) {
        this.name = name !== null && name !== void 0 ? name : "";
      }
      if (!isString(this.id) && isString(id)) {
        this.id = id;
      }
      if (isValid(styles2)) {
        (_a = this.styles) !== null && _a !== void 0 ? _a : this.styles = {};
        merge(this.styles, styles2);
      }
      if (isArray(points) && points.length > 0) {
        var repeatTotalStep = 0;
        this.points = __spreadArray([], __read(points), false);
        if (points.length >= this.totalStep - 1) {
          this.currentStep = OVERLAY_DRAW_STEP_FINISHED;
          repeatTotalStep = this.totalStep - 1;
        } else {
          this.currentStep = points.length + 1;
          repeatTotalStep = points.length;
        }
        if (isFunction(this.performEventMoveForDrawing)) {
          for (var i = 0; i < repeatTotalStep; i++) {
            this.performEventMoveForDrawing({
              currentStep: i + 2,
              mode: this.mode,
              points: this.points,
              performPointIndex: i,
              performPoint: this.points[i]
            });
          }
        }
        if (this.currentStep === OVERLAY_DRAW_STEP_FINISHED) {
          (_b = this.performEventPressedMove) === null || _b === void 0 ? void 0 : _b.call(this, {
            currentStep: this.currentStep,
            mode: this.mode,
            points: this.points,
            performPointIndex: this.points.length - 1,
            performPoint: this.points[this.points.length - 1]
          });
        }
      }
    };
    OverlayImp2.prototype.getPrevZLevel = function() {
      return this._prevZLevel;
    };
    OverlayImp2.prototype.setPrevZLevel = function(zLevel) {
      this._prevZLevel = zLevel;
    };
    OverlayImp2.prototype.shouldUpdate = function() {
      var sort = this._prevOverlay.zLevel !== this.zLevel;
      var draw = sort || JSON.stringify(this._prevOverlay.points) !== JSON.stringify(this.points) || this._prevOverlay.visible !== this.visible || this._prevOverlay.extendData !== this.extendData || this._prevOverlay.styles !== this.styles;
      return { sort, draw };
    };
    OverlayImp2.prototype.nextStep = function() {
      if (this.currentStep === this.totalStep - 1) {
        this.currentStep = OVERLAY_DRAW_STEP_FINISHED;
      } else {
        this.currentStep++;
      }
    };
    OverlayImp2.prototype.forceComplete = function() {
      this.currentStep = OVERLAY_DRAW_STEP_FINISHED;
    };
    OverlayImp2.prototype.isDrawing = function() {
      return this.currentStep !== OVERLAY_DRAW_STEP_FINISHED;
    };
    OverlayImp2.prototype.isStart = function() {
      return this.currentStep === OVERLAY_DRAW_STEP_START;
    };
    OverlayImp2.prototype.eventMoveForDrawing = function(point) {
      var _a;
      var pointIndex = this.currentStep - 1;
      var newPoint = {};
      if (isNumber(point.timestamp)) {
        newPoint.timestamp = point.timestamp;
      }
      if (isNumber(point.dataIndex)) {
        newPoint.dataIndex = point.dataIndex;
      }
      if (isNumber(point.value)) {
        newPoint.value = point.value;
      }
      this.points[pointIndex] = newPoint;
      (_a = this.performEventMoveForDrawing) === null || _a === void 0 ? void 0 : _a.call(this, {
        currentStep: this.currentStep,
        mode: this.mode,
        points: this.points,
        performPointIndex: pointIndex,
        performPoint: newPoint
      });
    };
    OverlayImp2.prototype.eventPressedPointMove = function(point, pointIndex) {
      var _a;
      this.points[pointIndex].timestamp = point.timestamp;
      if (isNumber(point.value)) {
        this.points[pointIndex].value = point.value;
      }
      (_a = this.performEventPressedMove) === null || _a === void 0 ? void 0 : _a.call(this, {
        currentStep: this.currentStep,
        points: this.points,
        mode: this.mode,
        performPointIndex: pointIndex,
        performPoint: this.points[pointIndex]
      });
    };
    OverlayImp2.prototype.startPressedMove = function(point) {
      this._prevPressedPoint = __assign({}, point);
      this._prevPressedPoints = clone(this.points);
    };
    OverlayImp2.prototype.eventPressedOtherMove = function(point, chartStore) {
      if (this._prevPressedPoint !== null) {
        var difDataIndex_1 = null;
        if (isNumber(point.dataIndex) && isNumber(this._prevPressedPoint.dataIndex)) {
          difDataIndex_1 = point.dataIndex - this._prevPressedPoint.dataIndex;
        }
        var difValue_1 = null;
        if (isNumber(point.value) && isNumber(this._prevPressedPoint.value)) {
          difValue_1 = point.value - this._prevPressedPoint.value;
        }
        this.points = this._prevPressedPoints.map(function(p) {
          var _a;
          if (isNumber(p.timestamp)) {
            p.dataIndex = chartStore.timestampToDataIndex(p.timestamp);
          }
          var newPoint = __assign({}, p);
          if (isNumber(difDataIndex_1) && isNumber(p.dataIndex)) {
            newPoint.dataIndex = p.dataIndex + difDataIndex_1;
            newPoint.timestamp = (_a = chartStore.dataIndexToTimestamp(newPoint.dataIndex)) !== null && _a !== void 0 ? _a : void 0;
          }
          if (isNumber(difValue_1) && isNumber(p.value)) {
            newPoint.value = p.value + difValue_1;
          }
          return newPoint;
        });
      }
    };
    OverlayImp2.extend = function(template) {
      var Custom = (
        /** @class */
        function(_super) {
          __extends(Custom2, _super);
          function Custom2() {
            return _super.call(this, template) || this;
          }
          return Custom2;
        }(OverlayImp2)
      );
      return Custom;
    };
    return OverlayImp2;
  }()
);
var fibonacciLine = {
  name: "fibonacciLine",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var _b, _c, _d;
    var chart = _a.chart, coordinates = _a.coordinates, bounding = _a.bounding, overlay = _a.overlay, yAxis = _a.yAxis;
    var points = overlay.points;
    if (coordinates.length > 0) {
      var precision_1 = 0;
      if ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isInCandle()) !== null && _b !== void 0 ? _b : true) {
        precision_1 = (_d = (_c = chart.getSymbol()) === null || _c === void 0 ? void 0 : _c.pricePrecision) !== null && _d !== void 0 ? _d : SymbolDefaultPrecisionConstants.PRICE;
      } else {
        var indicators2 = chart.getIndicators({ paneId: overlay.paneId });
        indicators2.forEach(function(indicator) {
          precision_1 = Math.max(precision_1, indicator.precision);
        });
      }
      var lines_1 = [];
      var texts_1 = [];
      var startX_1 = 0;
      var endX_1 = bounding.width;
      if (coordinates.length > 1 && isNumber(points[0].value) && isNumber(points[1].value)) {
        var percents = [1, 0.786, 0.618, 0.5, 0.382, 0.236, 0];
        var yDif_1 = coordinates[0].y - coordinates[1].y;
        var valueDif_1 = points[0].value - points[1].value;
        percents.forEach(function(percent) {
          var _a2;
          var y = coordinates[1].y + yDif_1 * percent;
          var value = chart.getDecimalFold().format(chart.getThousandsSeparator().format((((_a2 = points[1].value) !== null && _a2 !== void 0 ? _a2 : 0) + valueDif_1 * percent).toFixed(precision_1)));
          lines_1.push({ coordinates: [{ x: startX_1, y }, { x: endX_1, y }] });
          texts_1.push({
            x: startX_1,
            y,
            text: "".concat(value, " (").concat((percent * 100).toFixed(1), "%)"),
            baseline: "bottom"
          });
        });
      }
      return [
        {
          type: "line",
          attrs: lines_1
        },
        {
          type: "text",
          isCheckEvent: false,
          attrs: texts_1
        }
      ];
    }
    return [];
  }
};
var horizontalRayLine = {
  name: "horizontalRayLine",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    var coordinate = { x: 0, y: coordinates[0].y };
    if (isValid(coordinates[1]) && coordinates[0].x < coordinates[1].x) {
      coordinate.x = bounding.width;
    }
    return [
      {
        type: "line",
        attrs: { coordinates: [coordinates[0], coordinate] }
      }
    ];
  },
  performEventPressedMove: function(_a) {
    var points = _a.points, performPoint = _a.performPoint;
    points[0].value = performPoint.value;
    points[1].value = performPoint.value;
  },
  performEventMoveForDrawing: function(_a) {
    var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;
    if (currentStep === 2) {
      points[0].value = performPoint.value;
    }
  }
};
var horizontalSegment = {
  name: "horizontalSegment",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates;
    var lines = [];
    if (coordinates.length === 2) {
      lines.push({ coordinates });
    }
    return [
      {
        type: "line",
        attrs: lines
      }
    ];
  },
  performEventPressedMove: function(_a) {
    var points = _a.points, performPoint = _a.performPoint;
    points[0].value = performPoint.value;
    points[1].value = performPoint.value;
  },
  performEventMoveForDrawing: function(_a) {
    var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;
    if (currentStep === 2) {
      points[0].value = performPoint.value;
    }
  }
};
var horizontalStraightLine = {
  name: "horizontalStraightLine",
  totalStep: 2,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    return [{
      type: "line",
      attrs: {
        coordinates: [
          {
            x: 0,
            y: coordinates[0].y
          },
          {
            x: bounding.width,
            y: coordinates[0].y
          }
        ]
      }
    }];
  }
};
var Eventful = (
  /** @class */
  function() {
    function Eventful2() {
      this._children = [];
      this._callbacks = /* @__PURE__ */ new Map();
    }
    Eventful2.prototype.registerEvent = function(name, callback) {
      this._callbacks.set(name, callback);
      return this;
    };
    Eventful2.prototype.onEvent = function(name, event) {
      var callback = this._callbacks.get(name);
      if (isValid(callback) && this.checkEventOn(event)) {
        return callback(event);
      }
      return false;
    };
    Eventful2.prototype.dispatchEventToChildren = function(name, event) {
      var start = this._children.length - 1;
      if (start > -1) {
        for (var i = start; i > -1; i--) {
          if (this._children[i].dispatchEvent(name, event)) {
            return true;
          }
        }
      }
      return false;
    };
    Eventful2.prototype.dispatchEvent = function(name, event) {
      if (this.dispatchEventToChildren(name, event)) {
        return true;
      }
      return this.onEvent(name, event);
    };
    Eventful2.prototype.addChild = function(eventful) {
      this._children.push(eventful);
      return this;
    };
    Eventful2.prototype.clear = function() {
      this._children = [];
    };
    return Eventful2;
  }()
);
var DEVIATION = 2;
var FigureImp = (
  /** @class */
  function(_super) {
    __extends(FigureImp2, _super);
    function FigureImp2(figure) {
      var _this = _super.call(this) || this;
      _this.attrs = figure.attrs;
      _this.styles = figure.styles;
      return _this;
    }
    FigureImp2.prototype.checkEventOn = function(event) {
      return this.checkEventOnImp(event, this.attrs, this.styles);
    };
    FigureImp2.prototype.setAttrs = function(attrs) {
      this.attrs = attrs;
      return this;
    };
    FigureImp2.prototype.setStyles = function(styles2) {
      this.styles = styles2;
      return this;
    };
    FigureImp2.prototype.draw = function(ctx) {
      this.drawImp(ctx, this.attrs, this.styles);
    };
    FigureImp2.extend = function(figure) {
      var Custom = (
        /** @class */
        function(_super2) {
          __extends(Custom2, _super2);
          function Custom2() {
            return _super2 !== null && _super2.apply(this, arguments) || this;
          }
          Custom2.prototype.checkEventOnImp = function(coordinate, attrs, styles2) {
            return figure.checkEventOn(coordinate, attrs, styles2);
          };
          Custom2.prototype.drawImp = function(ctx, attrs, styles2) {
            figure.draw(ctx, attrs, styles2);
          };
          return Custom2;
        }(FigureImp2)
      );
      return Custom;
    };
    return FigureImp2;
  }(Eventful)
);
function checkCoordinateOnLine(coordinate, attrs) {
  var e_1, _a;
  var lines = [];
  lines = lines.concat(attrs);
  try {
    for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
      var line_1 = lines_1_1.value;
      var coordinates = line_1.coordinates;
      if (coordinates.length > 1) {
        for (var i = 1; i < coordinates.length; i++) {
          var prevCoordinate = coordinates[i - 1];
          var currentCoordinate = coordinates[i];
          if (prevCoordinate.x === currentCoordinate.x) {
            if (Math.abs(prevCoordinate.y - coordinate.y) + Math.abs(currentCoordinate.y - coordinate.y) - Math.abs(prevCoordinate.y - currentCoordinate.y) < DEVIATION + DEVIATION && Math.abs(coordinate.x - prevCoordinate.x) < DEVIATION) {
              return true;
            }
          } else {
            var kb = getLinearSlopeIntercept(prevCoordinate, currentCoordinate);
            var y = getLinearYFromSlopeIntercept(kb, coordinate);
            var yDif = Math.abs(y - coordinate.y);
            if (Math.abs(prevCoordinate.x - coordinate.x) + Math.abs(currentCoordinate.x - coordinate.x) - Math.abs(prevCoordinate.x - currentCoordinate.x) < DEVIATION + DEVIATION && yDif * yDif / (kb[0] * kb[0] + 1) < DEVIATION * DEVIATION) {
              return true;
            }
          }
        }
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function getLinearYFromSlopeIntercept(kb, coordinate) {
  if (kb !== null) {
    return coordinate.x * kb[0] + kb[1];
  }
  return coordinate.y;
}
function getLinearYFromCoordinates(coordinate1, coordinate2, targetCoordinate) {
  var kb = getLinearSlopeIntercept(coordinate1, coordinate2);
  return getLinearYFromSlopeIntercept(kb, targetCoordinate);
}
function getLinearSlopeIntercept(coordinate1, coordinate2) {
  var difX = coordinate1.x - coordinate2.x;
  if (difX !== 0) {
    var k = (coordinate1.y - coordinate2.y) / difX;
    var b = coordinate1.y - k * coordinate1.x;
    return [k, b];
  }
  return null;
}
function lineTo(ctx, coordinates, smooth) {
  var length = coordinates.length;
  var smoothParam = isNumber(smooth) ? smooth > 0 && smooth < 1 ? smooth : 0 : smooth ? 0.5 : 0;
  if (smoothParam > 0 && length > 2) {
    var cpx0 = coordinates[0].x;
    var cpy0 = coordinates[0].y;
    for (var i = 1; i < length - 1; i++) {
      var prevCoordinate = coordinates[i - 1];
      var coordinate = coordinates[i];
      var nextCoordinate = coordinates[i + 1];
      var dx01 = coordinate.x - prevCoordinate.x;
      var dy01 = coordinate.y - prevCoordinate.y;
      var dx12 = nextCoordinate.x - coordinate.x;
      var dy12 = nextCoordinate.y - coordinate.y;
      var dx02 = nextCoordinate.x - prevCoordinate.x;
      var dy02 = nextCoordinate.y - prevCoordinate.y;
      var prevSegmentLength = Math.sqrt(dx01 * dx01 + dy01 * dy01);
      var nextSegmentLength = Math.sqrt(dx12 * dx12 + dy12 * dy12);
      var segmentLengthRatio = nextSegmentLength / (nextSegmentLength + prevSegmentLength);
      var nextCpx = coordinate.x + dx02 * smoothParam * segmentLengthRatio;
      var nextCpy = coordinate.y + dy02 * smoothParam * segmentLengthRatio;
      nextCpx = Math.min(nextCpx, Math.max(nextCoordinate.x, coordinate.x));
      nextCpy = Math.min(nextCpy, Math.max(nextCoordinate.y, coordinate.y));
      nextCpx = Math.max(nextCpx, Math.min(nextCoordinate.x, coordinate.x));
      nextCpy = Math.max(nextCpy, Math.min(nextCoordinate.y, coordinate.y));
      dx02 = nextCpx - coordinate.x;
      dy02 = nextCpy - coordinate.y;
      var cpx1 = coordinate.x - dx02 * prevSegmentLength / nextSegmentLength;
      var cpy1 = coordinate.y - dy02 * prevSegmentLength / nextSegmentLength;
      cpx1 = Math.min(cpx1, Math.max(prevCoordinate.x, coordinate.x));
      cpy1 = Math.min(cpy1, Math.max(prevCoordinate.y, coordinate.y));
      cpx1 = Math.max(cpx1, Math.min(prevCoordinate.x, coordinate.x));
      cpy1 = Math.max(cpy1, Math.min(prevCoordinate.y, coordinate.y));
      dx02 = coordinate.x - cpx1;
      dy02 = coordinate.y - cpy1;
      nextCpx = coordinate.x + dx02 * nextSegmentLength / prevSegmentLength;
      nextCpy = coordinate.y + dy02 * nextSegmentLength / prevSegmentLength;
      ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, coordinate.x, coordinate.y);
      cpx0 = nextCpx;
      cpy0 = nextCpy;
    }
    var lastCoordinate = coordinates[length - 1];
    ctx.bezierCurveTo(cpx0, cpy0, lastCoordinate.x, lastCoordinate.y, lastCoordinate.x, lastCoordinate.y);
  } else {
    for (var i = 1; i < length; i++) {
      ctx.lineTo(coordinates[i].x, coordinates[i].y);
    }
  }
}
function drawLine(ctx, attrs, styles2) {
  var lines = [];
  lines = lines.concat(attrs);
  var _a = styles2.style, style = _a === void 0 ? "solid" : _a, _b = styles2.smooth, smooth = _b === void 0 ? false : _b, _c = styles2.size, size = _c === void 0 ? 1 : _c, _d = styles2.color, color = _d === void 0 ? "currentColor" : _d, _e = styles2.dashedValue, dashedValue = _e === void 0 ? [2, 2] : _e;
  ctx.lineWidth = size;
  ctx.strokeStyle = color;
  if (style === "dashed") {
    ctx.setLineDash(dashedValue);
  } else {
    ctx.setLineDash([]);
  }
  var correction = size % 2 === 1 ? 0.5 : 0;
  lines.forEach(function(_a2) {
    var coordinates = _a2.coordinates;
    if (coordinates.length > 1) {
      if (coordinates.length === 2 && (coordinates[0].x === coordinates[1].x || coordinates[0].y === coordinates[1].y)) {
        ctx.beginPath();
        if (coordinates[0].x === coordinates[1].x) {
          ctx.moveTo(coordinates[0].x + correction, coordinates[0].y);
          ctx.lineTo(coordinates[1].x + correction, coordinates[1].y);
        } else {
          ctx.moveTo(coordinates[0].x, coordinates[0].y + correction);
          ctx.lineTo(coordinates[1].x, coordinates[1].y + correction);
        }
        ctx.stroke();
        ctx.closePath();
      } else {
        ctx.save();
        if (size % 2 === 1) {
          ctx.translate(0.5, 0.5);
        }
        ctx.beginPath();
        ctx.moveTo(coordinates[0].x, coordinates[0].y);
        lineTo(ctx, coordinates, smooth);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
      }
    }
  });
}
var line = {
  name: "line",
  checkEventOn: checkCoordinateOnLine,
  draw: function(ctx, attrs, styles2) {
    drawLine(ctx, attrs, styles2);
  }
};
function getParallelLines(coordinates, bounding, extendParallelLineCount) {
  var count = extendParallelLineCount !== null && extendParallelLineCount !== void 0 ? extendParallelLineCount : 0;
  var lines = [];
  if (coordinates.length > 1) {
    if (coordinates[0].x === coordinates[1].x) {
      var startY = 0;
      var endY = bounding.height;
      lines.push({ coordinates: [{ x: coordinates[0].x, y: startY }, { x: coordinates[0].x, y: endY }] });
      if (coordinates.length > 2) {
        lines.push({ coordinates: [{ x: coordinates[2].x, y: startY }, { x: coordinates[2].x, y: endY }] });
        var distance = coordinates[0].x - coordinates[2].x;
        for (var i = 0; i < count; i++) {
          var d = distance * (i + 1);
          lines.push({ coordinates: [{ x: coordinates[0].x + d, y: startY }, { x: coordinates[0].x + d, y: endY }] });
        }
      }
    } else {
      var startX = 0;
      var endX = bounding.width;
      var kb = getLinearSlopeIntercept(coordinates[0], coordinates[1]);
      var k = kb[0];
      var b = kb[1];
      lines.push({ coordinates: [{ x: startX, y: startX * k + b }, { x: endX, y: endX * k + b }] });
      if (coordinates.length > 2) {
        var b1 = coordinates[2].y - k * coordinates[2].x;
        lines.push({ coordinates: [{ x: startX, y: startX * k + b1 }, { x: endX, y: endX * k + b1 }] });
        var distance = b - b1;
        for (var i = 0; i < count; i++) {
          var b2 = b + distance * (i + 1);
          lines.push({ coordinates: [{ x: startX, y: startX * k + b2 }, { x: endX, y: endX * k + b2 }] });
        }
      }
    }
  }
  return lines;
}
var parallelStraightLine = {
  name: "parallelStraightLine",
  totalStep: 4,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    return [
      {
        type: "line",
        attrs: getParallelLines(coordinates, bounding)
      }
    ];
  }
};
var priceChannelLine = {
  name: "priceChannelLine",
  totalStep: 4,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    return [
      {
        type: "line",
        attrs: getParallelLines(coordinates, bounding, 1)
      }
    ];
  }
};
var priceLine = {
  name: "priceLine",
  totalStep: 2,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var _b, _c, _d;
    var chart = _a.chart, coordinates = _a.coordinates, bounding = _a.bounding, overlay = _a.overlay, yAxis = _a.yAxis;
    var precision = 0;
    if ((_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isInCandle()) !== null && _b !== void 0 ? _b : true) {
      precision = (_d = (_c = chart.getSymbol()) === null || _c === void 0 ? void 0 : _c.pricePrecision) !== null && _d !== void 0 ? _d : SymbolDefaultPrecisionConstants.PRICE;
    } else {
      var indicators2 = chart.getIndicators({ paneId: overlay.paneId });
      indicators2.forEach(function(indicator) {
        precision = Math.max(precision, indicator.precision);
      });
    }
    var _e = overlay.points[0].value, value = _e === void 0 ? 0 : _e;
    return [
      {
        type: "line",
        attrs: { coordinates: [coordinates[0], { x: bounding.width, y: coordinates[0].y }] }
      },
      {
        type: "text",
        ignoreEvent: true,
        attrs: {
          x: coordinates[0].x,
          y: coordinates[0].y,
          text: chart.getDecimalFold().format(chart.getThousandsSeparator().format(value.toFixed(precision))),
          baseline: "bottom"
        }
      }
    ];
  }
};
function getRayLine(coordinates, bounding) {
  if (coordinates.length > 1) {
    var coordinate = { x: 0, y: 0 };
    if (coordinates[0].x === coordinates[1].x && coordinates[0].y !== coordinates[1].y) {
      if (coordinates[0].y < coordinates[1].y) {
        coordinate = {
          x: coordinates[0].x,
          y: bounding.height
        };
      } else {
        coordinate = {
          x: coordinates[0].x,
          y: 0
        };
      }
    } else if (coordinates[0].x > coordinates[1].x) {
      coordinate = {
        x: 0,
        y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: 0, y: coordinates[0].y })
      };
    } else {
      coordinate = {
        x: bounding.width,
        y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: bounding.width, y: coordinates[0].y })
      };
    }
    return { coordinates: [coordinates[0], coordinate] };
  }
  return [];
}
var rayLine = {
  name: "rayLine",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    return [
      {
        type: "line",
        attrs: getRayLine(coordinates, bounding)
      }
    ];
  }
};
var segment = {
  name: "segment",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates;
    if (coordinates.length === 2) {
      return [
        {
          type: "line",
          attrs: { coordinates }
        }
      ];
    }
    return [];
  }
};
var straightLine = {
  name: "straightLine",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    if (coordinates.length === 2) {
      if (coordinates[0].x === coordinates[1].x) {
        return [
          {
            type: "line",
            attrs: {
              coordinates: [
                {
                  x: coordinates[0].x,
                  y: 0
                },
                {
                  x: coordinates[0].x,
                  y: bounding.height
                }
              ]
            }
          }
        ];
      }
      return [
        {
          type: "line",
          attrs: {
            coordinates: [
              {
                x: 0,
                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: 0, y: coordinates[0].y })
              },
              {
                x: bounding.width,
                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: bounding.width, y: coordinates[0].y })
              }
            ]
          }
        }
      ];
    }
    return [];
  }
};
var verticalRayLine = {
  name: "verticalRayLine",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    if (coordinates.length === 2) {
      var coordinate = { x: coordinates[0].x, y: 0 };
      if (coordinates[0].y < coordinates[1].y) {
        coordinate.y = bounding.height;
      }
      return [
        {
          type: "line",
          attrs: { coordinates: [coordinates[0], coordinate] }
        }
      ];
    }
    return [];
  },
  performEventPressedMove: function(_a) {
    var points = _a.points, performPoint = _a.performPoint;
    points[0].timestamp = performPoint.timestamp;
    points[0].dataIndex = performPoint.dataIndex;
    points[1].timestamp = performPoint.timestamp;
    points[1].dataIndex = performPoint.dataIndex;
  },
  performEventMoveForDrawing: function(_a) {
    var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;
    if (currentStep === 2) {
      points[0].timestamp = performPoint.timestamp;
      points[0].dataIndex = performPoint.dataIndex;
    }
  }
};
var verticalSegment = {
  name: "verticalSegment",
  totalStep: 3,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates;
    if (coordinates.length === 2) {
      return [
        {
          type: "line",
          attrs: { coordinates }
        }
      ];
    }
    return [];
  },
  performEventPressedMove: function(_a) {
    var points = _a.points, performPoint = _a.performPoint;
    points[0].timestamp = performPoint.timestamp;
    points[0].dataIndex = performPoint.dataIndex;
    points[1].timestamp = performPoint.timestamp;
    points[1].dataIndex = performPoint.dataIndex;
  },
  performEventMoveForDrawing: function(_a) {
    var currentStep = _a.currentStep, points = _a.points, performPoint = _a.performPoint;
    if (currentStep === 2) {
      points[0].timestamp = performPoint.timestamp;
      points[0].dataIndex = performPoint.dataIndex;
    }
  }
};
var verticalStraightLine = {
  name: "verticalStraightLine",
  totalStep: 2,
  needDefaultPointFigure: true,
  needDefaultXAxisFigure: true,
  needDefaultYAxisFigure: true,
  createPointFigures: function(_a) {
    var coordinates = _a.coordinates, bounding = _a.bounding;
    return [
      {
        type: "line",
        attrs: {
          coordinates: [
            {
              x: coordinates[0].x,
              y: 0
            },
            {
              x: coordinates[0].x,
              y: bounding.height
            }
          ]
        }
      }
    ];
  }
};
var simpleAnnotation = {
  name: "simpleAnnotation",
  totalStep: 2,
  styles: {
    line: { style: "dashed" }
  },
  createPointFigures: function(_a) {
    var _b;
    var overlay = _a.overlay, coordinates = _a.coordinates;
    var text2 = "";
    if (isValid(overlay.extendData)) {
      if (!isFunction(overlay.extendData)) {
        text2 = (_b = overlay.extendData) !== null && _b !== void 0 ? _b : "";
      } else {
        text2 = overlay.extendData(overlay);
      }
    }
    var startX = coordinates[0].x;
    var startY = coordinates[0].y - 6;
    var lineEndY = startY - 50;
    var arrowEndY = lineEndY - 5;
    return [
      {
        type: "line",
        attrs: { coordinates: [{ x: startX, y: startY }, { x: startX, y: lineEndY }] },
        ignoreEvent: true
      },
      {
        type: "polygon",
        attrs: { coordinates: [{ x: startX, y: lineEndY }, { x: startX - 4, y: arrowEndY }, { x: startX + 4, y: arrowEndY }] },
        ignoreEvent: true
      },
      {
        type: "text",
        attrs: { x: startX, y: arrowEndY, text: text2, align: "center", baseline: "bottom" },
        ignoreEvent: true
      }
    ];
  }
};
var simpleTag = {
  name: "simpleTag",
  totalStep: 2,
  styles: {
    line: { style: "dashed" }
  },
  createPointFigures: function(_a) {
    var bounding = _a.bounding, coordinates = _a.coordinates;
    return {
      type: "line",
      attrs: {
        coordinates: [
          { x: 0, y: coordinates[0].y },
          { x: bounding.width, y: coordinates[0].y }
        ]
      },
      ignoreEvent: true
    };
  },
  createYAxisFigures: function(_a) {
    var _b, _c, _d, _e;
    var chart = _a.chart, overlay = _a.overlay, coordinates = _a.coordinates, bounding = _a.bounding, yAxis = _a.yAxis;
    var isFromZero = (_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isFromZero()) !== null && _b !== void 0 ? _b : false;
    var textAlign = "left";
    var x = 0;
    if (isFromZero) {
      textAlign = "left";
      x = 0;
    } else {
      textAlign = "right";
      x = bounding.width;
    }
    var text2 = "";
    if (isValid(overlay.extendData)) {
      if (!isFunction(overlay.extendData)) {
        text2 = (_c = overlay.extendData) !== null && _c !== void 0 ? _c : "";
      } else {
        text2 = overlay.extendData(overlay);
      }
    }
    if (!isValid(text2) && isNumber(overlay.points[0].value)) {
      text2 = formatPrecision(overlay.points[0].value, (_e = (_d = chart.getSymbol()) === null || _d === void 0 ? void 0 : _d.pricePrecision) !== null && _e !== void 0 ? _e : SymbolDefaultPrecisionConstants.PRICE);
    }
    return { type: "text", attrs: { x, y: coordinates[0].y, text: text2, align: textAlign, baseline: "middle" } };
  }
};
var overlays = {};
var extensions$1 = [
  fibonacciLine,
  horizontalRayLine,
  horizontalSegment,
  horizontalStraightLine,
  parallelStraightLine,
  priceChannelLine,
  priceLine,
  rayLine,
  segment,
  straightLine,
  verticalRayLine,
  verticalSegment,
  verticalStraightLine,
  simpleAnnotation,
  simpleTag
];
extensions$1.forEach(function(template) {
  overlays[template.name] = OverlayImp.extend(template);
});
function registerOverlay(template) {
  overlays[template.name] = OverlayImp.extend(template);
}
function getOverlayInnerClass(name) {
  var _a;
  return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;
}
function getOverlayClass(name) {
  var _a;
  return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;
}
function getSupportedOverlays() {
  return Object.keys(overlays);
}
var light = {
  grid: {
    horizontal: {
      color: "#EDEDED"
    },
    vertical: {
      color: "#EDEDED"
    }
  },
  candle: {
    priceMark: {
      high: {
        color: "#76808F"
      },
      low: {
        color: "#76808F"
      }
    },
    tooltip: {
      rect: {
        color: "#FEFEFE",
        borderColor: "#F2F3F5"
      },
      title: {
        color: "#76808F"
      },
      legend: {
        color: "#76808F"
      }
    }
  },
  indicator: {
    tooltip: {
      title: {
        color: "#76808F"
      },
      legend: {
        color: "#76808F"
      }
    }
  },
  xAxis: {
    axisLine: {
      color: "#DDDDDD"
    },
    tickText: {
      color: "#76808F"
    },
    tickLine: {
      color: "#DDDDDD"
    }
  },
  yAxis: {
    axisLine: {
      color: "#DDDDDD"
    },
    tickText: {
      color: "#76808F"
    },
    tickLine: {
      color: "#DDDDDD"
    }
  },
  separator: {
    color: "#DDDDDD"
  },
  crosshair: {
    horizontal: {
      line: {
        color: "#76808F"
      },
      text: {
        borderColor: "#686D76",
        backgroundColor: "#686D76"
      }
    },
    vertical: {
      line: {
        color: "#76808F"
      },
      text: {
        borderColor: "#686D76",
        backgroundColor: "#686D76"
      }
    }
  }
};
var dark = {
  grid: {
    horizontal: {
      color: "#292929"
    },
    vertical: {
      color: "#292929"
    }
  },
  candle: {
    priceMark: {
      high: {
        color: "#929AA5"
      },
      low: {
        color: "#929AA5"
      }
    },
    tooltip: {
      rect: {
        color: "rgba(10, 10, 10, .6)",
        borderColor: "rgba(10, 10, 10, .6)"
      },
      title: {
        color: "#929AA5"
      },
      legend: {
        color: "#929AA5"
      }
    }
  },
  indicator: {
    tooltip: {
      title: {
        color: "#929AA5"
      },
      legend: {
        color: "#929AA5"
      }
    }
  },
  xAxis: {
    axisLine: {
      color: "#333333"
    },
    tickText: {
      color: "#929AA5"
    },
    tickLine: {
      color: "#333333"
    }
  },
  yAxis: {
    axisLine: {
      color: "#333333"
    },
    tickText: {
      color: "#929AA5"
    },
    tickLine: {
      color: "#333333"
    }
  },
  separator: {
    color: "#333333"
  },
  crosshair: {
    horizontal: {
      line: {
        color: "#929AA5"
      },
      text: {
        borderColor: "#373a40",
        backgroundColor: "#373a40"
      }
    },
    vertical: {
      line: {
        color: "#929AA5"
      },
      text: {
        borderColor: "#373a40",
        backgroundColor: "#373a40"
      }
    }
  }
};
var styles = {
  light,
  dark
};
function registerStyles(name, ss) {
  styles[name] = ss;
}
function getStyles(name) {
  var _a;
  return (_a = styles[name]) !== null && _a !== void 0 ? _a : null;
}
var PANE_MIN_HEIGHT = 30;
var PANE_DEFAULT_HEIGHT = 100;
var PaneIdConstants = {
  CANDLE: "candle_pane",
  INDICATOR: "indicator_pane_",
  X_AXIS: "x_axis_pane"
};
var BarSpaceLimitConstants = {
  MIN: 1,
  MAX: 50
};
var DEFAULT_BAR_SPACE = 10;
var DEFAULT_OFFSET_RIGHT_DISTANCE = 80;
var BAR_GAP_RATIO = 0.2;
var SCALE_MULTIPLIER = 10;
var StoreImp = (
  /** @class */
  function() {
    function StoreImp2(chart, options) {
      var _this = this;
      this._styles = getDefaultStyles();
      this._formatter = {
        formatDate: function(_a2) {
          var dateTimeFormat = _a2.dateTimeFormat, timestamp = _a2.timestamp, template = _a2.template;
          return formatTimestampByTemplate(dateTimeFormat, timestamp, template);
        },
        formatBigNumber,
        formatExtendText: function(_) {
          return "";
        }
      };
      this._innerFormatter = {
        formatDate: function(timestamp, template, type) {
          return _this._formatter.formatDate({ dateTimeFormat: _this._dateTimeFormat, timestamp, template, type });
        },
        formatBigNumber: function(value) {
          return _this._formatter.formatBigNumber(value);
        },
        formatExtendText: function(params) {
          return _this._formatter.formatExtendText(params);
        }
      };
      this._locale = "en-US";
      this._thousandsSeparator = {
        sign: ",",
        format: function(value) {
          return formatThousands(value, _this._thousandsSeparator.sign);
        }
      };
      this._decimalFold = {
        threshold: 3,
        format: function(value) {
          return formatFoldDecimal(value, _this._decimalFold.threshold);
        }
      };
      this._symbol = null;
      this._period = null;
      this._dataList = [];
      this._dataLoader = null;
      this._loading = false;
      this._dataLoadMore = { forward: false, backward: false };
      this._zoomEnabled = true;
      this._zoomAnchor = {
        main: "cursor",
        xAxis: "cursor"
      };
      this._scrollEnabled = true;
      this._totalBarSpace = 0;
      this._barSpace = DEFAULT_BAR_SPACE;
      this._offsetRightDistance = DEFAULT_OFFSET_RIGHT_DISTANCE;
      this._startLastBarRightSideDiffBarCount = 0;
      this._scrollLimitRole = "bar_count";
      this._minVisibleBarCount = { left: 2, right: 2 };
      this._maxOffsetDistance = { left: 50, right: 50 };
      this._visibleRange = getDefaultVisibleRange();
      this._visibleRangeDataList = [];
      this._visibleRangeHighLowPrice = [
        { x: 0, price: Number.MIN_SAFE_INTEGER },
        { x: 0, price: Number.MAX_SAFE_INTEGER }
      ];
      this._crosshair = {};
      this._actions = /* @__PURE__ */ new Map();
      this._indicators = /* @__PURE__ */ new Map();
      this._overlays = /* @__PURE__ */ new Map();
      this._progressOverlayInfo = null;
      this._lastPriceMarkExtendTextUpdateTimers = [];
      this._pressedOverlayInfo = {
        paneId: "",
        overlay: null,
        figureType: "none",
        figureIndex: -1,
        figure: null
      };
      this._hoverOverlayInfo = {
        paneId: "",
        overlay: null,
        figureType: "none",
        figureIndex: -1,
        figure: null
      };
      this._clickOverlayInfo = {
        paneId: "",
        overlay: null,
        figureType: "none",
        figureIndex: -1,
        figure: null
      };
      this._chart = chart;
      this._calcOptimalBarSpace();
      this._lastBarRightSideDiffBarCount = this._offsetRightDistance / this._barSpace;
      var _a = options !== null && options !== void 0 ? options : {}, styles2 = _a.styles, locale = _a.locale, timezone = _a.timezone, formatter = _a.formatter, thousandsSeparator = _a.thousandsSeparator, decimalFold = _a.decimalFold, zoomAnchor = _a.zoomAnchor;
      if (isValid(styles2)) {
        this.setStyles(styles2);
      }
      if (isString(locale)) {
        this.setLocale(locale);
      }
      this.setTimezone(timezone !== null && timezone !== void 0 ? timezone : "");
      if (isValid(formatter)) {
        this.setFormatter(formatter);
      }
      if (isValid(thousandsSeparator)) {
        this.setThousandsSeparator(thousandsSeparator);
      }
      if (isValid(decimalFold)) {
        this.setDecimalFold(decimalFold);
      }
      if (isValid(zoomAnchor)) {
        this.setZoomAnchor(zoomAnchor);
      }
      this._taskScheduler = new TaskScheduler(function() {
        _this._chart.layout({
          measureWidth: true,
          update: true,
          buildYAxisTick: true
        });
      });
    }
    StoreImp2.prototype.setStyles = function(value) {
      var _this = this;
      var _a, _b, _c, _d, _e, _f;
      var styles2 = null;
      if (isString(value)) {
        styles2 = getStyles(value);
      } else {
        styles2 = value;
      }
      merge(this._styles, styles2);
      if (isArray((_c = (_b = (_a = styles2 === null || styles2 === void 0 ? void 0 : styles2.candle) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.legend) === null || _c === void 0 ? void 0 : _c.template)) {
        this._styles.candle.tooltip.legend.template = styles2.candle.tooltip.legend.template;
      }
      if (isValid((_f = (_e = (_d = styles2 === null || styles2 === void 0 ? void 0 : styles2.candle) === null || _d === void 0 ? void 0 : _d.priceMark) === null || _e === void 0 ? void 0 : _e.last) === null || _f === void 0 ? void 0 : _f.extendTexts)) {
        this._clearLastPriceMarkExtendTextUpdateTimer();
        var intervals_1 = [];
        this._styles.candle.priceMark.last.extendTexts.forEach(function(item) {
          var updateInterval = item.updateInterval;
          if (item.show && updateInterval > 0 && !intervals_1.includes(updateInterval)) {
            intervals_1.push(updateInterval);
            var timer = setInterval(function() {
              _this._chart.updatePane(0, PaneIdConstants.CANDLE);
            }, updateInterval);
            _this._lastPriceMarkExtendTextUpdateTimers.push(timer);
          }
        });
      }
    };
    StoreImp2.prototype.getStyles = function() {
      return this._styles;
    };
    StoreImp2.prototype.setFormatter = function(formatter) {
      merge(this._formatter, formatter);
    };
    StoreImp2.prototype.getFormatter = function() {
      return this._formatter;
    };
    StoreImp2.prototype.getInnerFormatter = function() {
      return this._innerFormatter;
    };
    StoreImp2.prototype.setLocale = function(locale) {
      this._locale = locale;
    };
    StoreImp2.prototype.getLocale = function() {
      return this._locale;
    };
    StoreImp2.prototype.setTimezone = function(timezone) {
      if (!isValid(this._dateTimeFormat) || this.getTimezone() !== timezone) {
        var options = {
          hour12: false,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        };
        if (timezone.length > 0) {
          options.timeZone = timezone;
        }
        var dateTimeFormat = null;
        try {
          dateTimeFormat = new Intl.DateTimeFormat("en", options);
        } catch (e) {
          logWarn("", "", "Timezone is error!!!");
        }
        if (dateTimeFormat !== null) {
          this._dateTimeFormat = dateTimeFormat;
        }
      }
    };
    StoreImp2.prototype.getTimezone = function() {
      return this._dateTimeFormat.resolvedOptions().timeZone;
    };
    StoreImp2.prototype.getDateTimeFormat = function() {
      return this._dateTimeFormat;
    };
    StoreImp2.prototype.setThousandsSeparator = function(thousandsSeparator) {
      merge(this._thousandsSeparator, thousandsSeparator);
    };
    StoreImp2.prototype.getThousandsSeparator = function() {
      return this._thousandsSeparator;
    };
    StoreImp2.prototype.setDecimalFold = function(decimalFold) {
      merge(this._decimalFold, decimalFold);
    };
    StoreImp2.prototype.getDecimalFold = function() {
      return this._decimalFold;
    };
    StoreImp2.prototype.setSymbol = function(symbol) {
      var _this = this;
      this.resetData(function() {
        _this._symbol = __assign(__assign({ pricePrecision: SymbolDefaultPrecisionConstants.PRICE, volumePrecision: SymbolDefaultPrecisionConstants.VOLUME }, _this._symbol), symbol);
        _this._synchronizeIndicatorSeriesPrecision();
      });
    };
    StoreImp2.prototype.getSymbol = function() {
      return this._symbol;
    };
    StoreImp2.prototype.setPeriod = function(period) {
      var _this = this;
      this.resetData(function() {
        _this._period = period;
      });
    };
    StoreImp2.prototype.getPeriod = function() {
      return this._period;
    };
    StoreImp2.prototype.getDataList = function() {
      return this._dataList;
    };
    StoreImp2.prototype.getVisibleRangeDataList = function() {
      return this._visibleRangeDataList;
    };
    StoreImp2.prototype.getVisibleRangeHighLowPrice = function() {
      return this._visibleRangeHighLowPrice;
    };
    StoreImp2.prototype._addData = function(data, type, more) {
      var _a, _b;
      var success = false;
      var adjustFlag = false;
      var dataLengthChange = 0;
      if (isArray(data)) {
        var realMore = { backward: false, forward: false };
        if (isBoolean(more)) {
          realMore.backward = more;
          realMore.forward = more;
        } else {
          realMore.backward = (_a = more === null || more === void 0 ? void 0 : more.backward) !== null && _a !== void 0 ? _a : false;
          realMore.forward = (_b = more === null || more === void 0 ? void 0 : more.forward) !== null && _b !== void 0 ? _b : false;
        }
        dataLengthChange = data.length;
        switch (type) {
          case "init": {
            this._clearData();
            this._dataList = data;
            this._dataLoadMore.backward = realMore.backward;
            this._dataLoadMore.forward = realMore.forward;
            this.setOffsetRightDistance(this._offsetRightDistance);
            adjustFlag = true;
            break;
          }
          case "backward": {
            this._dataList = this._dataList.concat(data);
            this._dataLoadMore.backward = realMore.backward;
            this._lastBarRightSideDiffBarCount -= dataLengthChange;
            adjustFlag = dataLengthChange > 0;
            break;
          }
          case "forward": {
            this._dataList = data.concat(this._dataList);
            this._dataLoadMore.forward = realMore.forward;
            adjustFlag = dataLengthChange > 0;
            break;
          }
        }
        success = true;
      } else {
        var dataCount = this._dataList.length;
        var timestamp = data.timestamp;
        var lastDataTimestamp = formatValue(this._dataList[dataCount - 1], "timestamp", 0);
        if (timestamp > lastDataTimestamp) {
          this._dataList.push(data);
          var lastBarRightSideDiffBarCount = this.getLastBarRightSideDiffBarCount();
          if (lastBarRightSideDiffBarCount < 0) {
            this.setLastBarRightSideDiffBarCount(--lastBarRightSideDiffBarCount);
          }
          dataLengthChange = 1;
          success = true;
          adjustFlag = true;
        } else if (timestamp === lastDataTimestamp) {
          this._dataList[dataCount - 1] = data;
          success = true;
          adjustFlag = true;
        }
      }
      if (success && adjustFlag) {
        this._adjustVisibleRange();
        this.setCrosshair(this._crosshair, { notInvalidate: true });
        var filterIndicators = this.getIndicatorsByFilter({});
        if (filterIndicators.length > 0) {
          this._calcIndicator(filterIndicators);
        } else {
          this._chart.layout({
            measureWidth: true,
            update: true,
            buildYAxisTick: true,
            cacheYAxisWidth: type !== "init"
          });
        }
      }
    };
    StoreImp2.prototype.setDataLoader = function(dataLoader) {
      var _this = this;
      this.resetData(function() {
        _this._dataLoader = dataLoader;
      });
    };
    StoreImp2.prototype._calcOptimalBarSpace = function() {
      var specialBarSpace = 4;
      var ratio = 1 - BAR_GAP_RATIO * Math.atan(Math.max(specialBarSpace, this._barSpace) - specialBarSpace) / (Math.PI * 0.5);
      var gapBarSpace = Math.min(Math.floor(this._barSpace * ratio), Math.floor(this._barSpace));
      if (gapBarSpace % 2 === 0 && gapBarSpace + 2 >= this._barSpace) {
        --gapBarSpace;
      }
      this._gapBarSpace = Math.max(1, gapBarSpace);
    };
    StoreImp2.prototype._adjustVisibleRange = function() {
      var _a, _b;
      var totalBarCount = this._dataList.length;
      var visibleBarCount = this._totalBarSpace / this._barSpace;
      var leftMinVisibleBarCount = 0;
      var rightMinVisibleBarCount = 0;
      if (this._scrollLimitRole === "distance") {
        leftMinVisibleBarCount = (this._totalBarSpace - this._maxOffsetDistance.right) / this._barSpace;
        rightMinVisibleBarCount = (this._totalBarSpace - this._maxOffsetDistance.left) / this._barSpace;
      } else {
        leftMinVisibleBarCount = this._minVisibleBarCount.left;
        rightMinVisibleBarCount = this._minVisibleBarCount.right;
      }
      leftMinVisibleBarCount = Math.max(0, leftMinVisibleBarCount);
      rightMinVisibleBarCount = Math.max(0, rightMinVisibleBarCount);
      var maxRightOffsetBarCount = visibleBarCount - Math.min(leftMinVisibleBarCount, totalBarCount);
      if (this._lastBarRightSideDiffBarCount > maxRightOffsetBarCount) {
        this._lastBarRightSideDiffBarCount = maxRightOffsetBarCount;
      }
      var minRightOffsetBarCount = -totalBarCount + Math.min(rightMinVisibleBarCount, totalBarCount);
      if (this._lastBarRightSideDiffBarCount < minRightOffsetBarCount) {
        this._lastBarRightSideDiffBarCount = minRightOffsetBarCount;
      }
      var to = Math.round(this._lastBarRightSideDiffBarCount + totalBarCount + 0.5);
      var realTo = to;
      if (to > totalBarCount) {
        to = totalBarCount;
      }
      var from = Math.round(to - visibleBarCount) - 1;
      if (from < 0) {
        from = 0;
      }
      var realFrom = this._lastBarRightSideDiffBarCount > 0 ? Math.round(totalBarCount + this._lastBarRightSideDiffBarCount - visibleBarCount) - 1 : from;
      this._visibleRange = { from, to, realFrom, realTo };
      this.executeAction("onVisibleRangeChange", this._visibleRange);
      this._visibleRangeDataList = [];
      this._visibleRangeHighLowPrice = [
        { x: 0, price: Number.MIN_SAFE_INTEGER },
        { x: 0, price: Number.MAX_SAFE_INTEGER }
      ];
      for (var i = realFrom; i < realTo; i++) {
        var kLineData = this._dataList[i];
        var x = this.dataIndexToCoordinate(i);
        this._visibleRangeDataList.push({
          dataIndex: i,
          x,
          data: {
            prev: (_a = this._dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData,
            current: kLineData,
            next: (_b = this._dataList[i + 1]) !== null && _b !== void 0 ? _b : kLineData
          }
        });
        if (isValid(kLineData)) {
          if (this._visibleRangeHighLowPrice[0].price < kLineData.high) {
            this._visibleRangeHighLowPrice[0].price = kLineData.high;
            this._visibleRangeHighLowPrice[0].x = x;
          }
          if (this._visibleRangeHighLowPrice[1].price > kLineData.low) {
            this._visibleRangeHighLowPrice[1].price = kLineData.low;
            this._visibleRangeHighLowPrice[1].x = x;
          }
        }
      }
      if (from === 0) {
        if (this._dataLoadMore.forward) {
          this._processDataLoad("forward");
        }
      } else if (to === totalBarCount) {
        if (this._dataLoadMore.backward) {
          this._processDataLoad("backward");
        }
      }
    };
    StoreImp2.prototype._processDataLoad = function(type) {
      var _this = this;
      var _a, _b, _c, _d;
      if (!this._loading && isValid(this._dataLoader) && isValid(this._symbol) && isValid(this._period)) {
        this._loading = true;
        var params = {
          type,
          symbol: this._symbol,
          period: this._period,
          timestamp: null,
          callback: function(data, more) {
            var _a2, _b2;
            _this._loading = false;
            _this._addData(data, type, more);
            if (type === "init") {
              (_b2 = (_a2 = _this._dataLoader) === null || _a2 === void 0 ? void 0 : _a2.subscribeBar) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
                symbol: _this._symbol,
                period: _this._period,
                callback: function(data2) {
                  _this._addData(data2, "update");
                }
              });
            }
          }
        };
        switch (type) {
          case "backward": {
            params.timestamp = (_b = (_a = this._dataList[this._dataList.length - 1]) === null || _a === void 0 ? void 0 : _a.timestamp) !== null && _b !== void 0 ? _b : null;
            break;
          }
          case "forward": {
            params.timestamp = (_d = (_c = this._dataList[0]) === null || _c === void 0 ? void 0 : _c.timestamp) !== null && _d !== void 0 ? _d : null;
            break;
          }
        }
        void this._dataLoader.getBars(params);
      }
    };
    StoreImp2.prototype._processDataUnsubscribe = function() {
      var _a, _b;
      if (isValid(this._dataLoader) && isValid(this._symbol) && isValid(this._period)) {
        (_b = (_a = this._dataLoader).unsubscribeBar) === null || _b === void 0 ? void 0 : _b.call(_a, {
          symbol: this._symbol,
          period: this._period
        });
      }
    };
    StoreImp2.prototype.resetData = function(fn) {
      this._processDataUnsubscribe();
      fn === null || fn === void 0 ? void 0 : fn();
      this._loading = false;
      this._processDataLoad("init");
    };
    StoreImp2.prototype.getBarSpace = function() {
      return {
        bar: this._barSpace,
        halfBar: this._barSpace / 2,
        gapBar: this._gapBarSpace,
        halfGapBar: Math.floor(this._gapBarSpace / 2)
      };
    };
    StoreImp2.prototype.setBarSpace = function(barSpace, adjustBeforeFunc) {
      if (barSpace < BarSpaceLimitConstants.MIN || barSpace > BarSpaceLimitConstants.MAX || this._barSpace === barSpace) {
        return;
      }
      this._barSpace = barSpace;
      this._calcOptimalBarSpace();
      adjustBeforeFunc === null || adjustBeforeFunc === void 0 ? void 0 : adjustBeforeFunc();
      this._adjustVisibleRange();
      this.setCrosshair(this._crosshair, { notInvalidate: true });
      this._chart.layout({
        measureWidth: true,
        update: true,
        buildYAxisTick: true,
        cacheYAxisWidth: true
      });
    };
    StoreImp2.prototype.setTotalBarSpace = function(totalSpace) {
      if (this._totalBarSpace !== totalSpace) {
        this._totalBarSpace = totalSpace;
        this._adjustVisibleRange();
        this.setCrosshair(this._crosshair, { notInvalidate: true });
      }
    };
    StoreImp2.prototype.setOffsetRightDistance = function(distance, isUpdate) {
      this._offsetRightDistance = this._scrollLimitRole === "distance" ? Math.min(this._maxOffsetDistance.right, distance) : distance;
      this._lastBarRightSideDiffBarCount = this._offsetRightDistance / this._barSpace;
      if (isUpdate !== null && isUpdate !== void 0 ? isUpdate : false) {
        this._adjustVisibleRange();
        this.setCrosshair(this._crosshair, { notInvalidate: true });
        this._chart.layout({
          measureWidth: true,
          update: true,
          buildYAxisTick: true,
          cacheYAxisWidth: true
        });
      }
      return this;
    };
    StoreImp2.prototype.getInitialOffsetRightDistance = function() {
      return this._offsetRightDistance;
    };
    StoreImp2.prototype.getOffsetRightDistance = function() {
      return Math.max(0, this._lastBarRightSideDiffBarCount * this._barSpace);
    };
    StoreImp2.prototype.getLastBarRightSideDiffBarCount = function() {
      return this._lastBarRightSideDiffBarCount;
    };
    StoreImp2.prototype.setLastBarRightSideDiffBarCount = function(barCount) {
      this._lastBarRightSideDiffBarCount = barCount;
    };
    StoreImp2.prototype.setMaxOffsetLeftDistance = function(distance) {
      this._scrollLimitRole = "distance";
      this._maxOffsetDistance.left = distance;
    };
    StoreImp2.prototype.setMaxOffsetRightDistance = function(distance) {
      this._scrollLimitRole = "distance";
      this._maxOffsetDistance.right = distance;
    };
    StoreImp2.prototype.setLeftMinVisibleBarCount = function(barCount) {
      this._scrollLimitRole = "bar_count";
      this._minVisibleBarCount.left = barCount;
    };
    StoreImp2.prototype.setRightMinVisibleBarCount = function(barCount) {
      this._scrollLimitRole = "bar_count";
      this._minVisibleBarCount.right = barCount;
    };
    StoreImp2.prototype.getVisibleRange = function() {
      return this._visibleRange;
    };
    StoreImp2.prototype.startScroll = function() {
      this._startLastBarRightSideDiffBarCount = this._lastBarRightSideDiffBarCount;
    };
    StoreImp2.prototype.scroll = function(distance) {
      if (!this._scrollEnabled) {
        return;
      }
      var distanceBarCount = distance / this._barSpace;
      var prevLastBarRightSideDistance = this._lastBarRightSideDiffBarCount * this._barSpace;
      this._lastBarRightSideDiffBarCount = this._startLastBarRightSideDiffBarCount - distanceBarCount;
      this._adjustVisibleRange();
      this.setCrosshair(this._crosshair, { notInvalidate: true });
      this._chart.layout({
        measureWidth: true,
        update: true,
        buildYAxisTick: true,
        cacheYAxisWidth: true
      });
      var realDistance = Math.round(prevLastBarRightSideDistance - this._lastBarRightSideDiffBarCount * this._barSpace);
      if (realDistance !== 0) {
        this.executeAction("onScroll", { distance: realDistance });
      }
    };
    StoreImp2.prototype.getDataByDataIndex = function(dataIndex) {
      var _a;
      return (_a = this._dataList[dataIndex]) !== null && _a !== void 0 ? _a : null;
    };
    StoreImp2.prototype.coordinateToFloatIndex = function(x) {
      var dataCount = this._dataList.length;
      var deltaFromRight = (this._totalBarSpace - x) / this._barSpace;
      var index = dataCount + this._lastBarRightSideDiffBarCount - deltaFromRight;
      return Math.round(index * 1e6) / 1e6;
    };
    StoreImp2.prototype.dataIndexToTimestamp = function(dataIndex) {
      var length = this._dataList.length;
      if (length === 0) {
        return null;
      }
      var data = this.getDataByDataIndex(dataIndex);
      if (isValid(data)) {
        return data.timestamp;
      }
      if (isValid(this._period)) {
        var lastIndex = length - 1;
        var referenceTimestamp = null;
        var diff = 0;
        if (dataIndex > lastIndex) {
          referenceTimestamp = this._dataList[lastIndex].timestamp;
          diff = dataIndex - lastIndex;
        } else if (dataIndex < 0) {
          referenceTimestamp = this._dataList[0].timestamp;
          diff = dataIndex;
        }
        if (isNumber(referenceTimestamp)) {
          var _a = this._period, type = _a.type, span = _a.span;
          switch (type) {
            case "second": {
              return referenceTimestamp + span * 1e3 * diff;
            }
            case "minute": {
              return referenceTimestamp + span * 60 * 1e3 * diff;
            }
            case "hour": {
              return referenceTimestamp + span * 60 * 60 * 1e3 * diff;
            }
            case "day": {
              return referenceTimestamp + span * 24 * 60 * 60 * 1e3 * diff;
            }
            case "week": {
              return referenceTimestamp + span * 7 * 24 * 60 * 60 * 1e3 * diff;
            }
            case "month": {
              var date = new Date(referenceTimestamp);
              var referenceDay = date.getDate();
              date.setDate(1);
              date.setMonth(date.getMonth() + span * diff);
              var lastDayOfTargetMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
              date.setDate(Math.min(referenceDay, lastDayOfTargetMonth));
              return date.getTime();
            }
            case "year": {
              var date = new Date(referenceTimestamp);
              date.setFullYear(date.getFullYear() + span * diff);
              return date.getTime();
            }
          }
        }
      }
      return null;
    };
    StoreImp2.prototype.timestampToDataIndex = function(timestamp) {
      var length = this._dataList.length;
      if (length === 0) {
        return 0;
      }
      if (isValid(this._period)) {
        var referenceTimestamp = null;
        var baseDataIndex = 0;
        var lastIndex = length - 1;
        var lastTimestamp = this._dataList[lastIndex].timestamp;
        if (timestamp > lastTimestamp) {
          referenceTimestamp = lastTimestamp;
          baseDataIndex = lastIndex;
        }
        var firstTimestamp = this._dataList[0].timestamp;
        if (timestamp < firstTimestamp) {
          referenceTimestamp = firstTimestamp;
          baseDataIndex = 0;
        }
        if (isNumber(referenceTimestamp)) {
          var _a = this._period, type = _a.type, span = _a.span;
          switch (type) {
            case "second": {
              return baseDataIndex + Math.floor((timestamp - referenceTimestamp) / (span * 1e3));
            }
            case "minute": {
              return baseDataIndex + Math.floor((timestamp - referenceTimestamp) / (span * 60 * 1e3));
            }
            case "hour": {
              return baseDataIndex + Math.floor((timestamp - referenceTimestamp) / (span * 60 * 60 * 1e3));
            }
            case "day": {
              return baseDataIndex + Math.floor((timestamp - referenceTimestamp) / (span * 24 * 60 * 60 * 1e3));
            }
            case "week": {
              return baseDataIndex + Math.floor((timestamp - referenceTimestamp) / (span * 7 * 24 * 60 * 60 * 1e3));
            }
            case "month": {
              var referenceDate = new Date(referenceTimestamp);
              var currentDate = new Date(timestamp);
              var referenceYear = referenceDate.getFullYear();
              var currentYear = currentDate.getFullYear();
              var referenceMonth = referenceDate.getMonth();
              var currentMonth = currentDate.getMonth();
              return baseDataIndex + Math.floor(((currentYear - referenceYear) * 12 + (currentMonth - referenceMonth)) / span);
            }
            case "year": {
              var referenceYear = new Date(referenceTimestamp).getFullYear();
              var currentYear = new Date(timestamp).getFullYear();
              return baseDataIndex + Math.floor((currentYear - referenceYear) / span);
            }
          }
        }
      }
      return binarySearchNearest(this._dataList, "timestamp", timestamp);
    };
    StoreImp2.prototype.dataIndexToCoordinate = function(dataIndex) {
      var dataCount = this._dataList.length;
      var deltaFromRight = dataCount + this._lastBarRightSideDiffBarCount - dataIndex;
      return Math.floor(this._totalBarSpace - (deltaFromRight - 0.5) * this._barSpace + 0.5);
    };
    StoreImp2.prototype.coordinateToDataIndex = function(x) {
      return Math.ceil(this.coordinateToFloatIndex(x)) - 1;
    };
    StoreImp2.prototype.zoom = function(scale, coordinate, position) {
      var _this = this;
      var _a;
      if (!this._zoomEnabled) {
        return;
      }
      var zoomCoordinate = coordinate !== null && coordinate !== void 0 ? coordinate : { x: (_a = this._crosshair.x) !== null && _a !== void 0 ? _a : this._totalBarSpace / 2 };
      if (position === "xAxis") {
        if (this._zoomAnchor.xAxis === "last_bar") {
          zoomCoordinate.x = this.dataIndexToCoordinate(this._dataList.length - 1);
        }
      } else {
        if (this._zoomAnchor.main === "last_bar") {
          zoomCoordinate.x = this.dataIndexToCoordinate(this._dataList.length - 1);
        }
      }
      var x = zoomCoordinate.x;
      var floatIndex = this.coordinateToFloatIndex(x);
      var prevBarSpace = this._barSpace;
      var barSpace = this._barSpace + scale * (this._barSpace / SCALE_MULTIPLIER);
      this.setBarSpace(barSpace, function() {
        _this._lastBarRightSideDiffBarCount += floatIndex - _this.coordinateToFloatIndex(x);
      });
      var realScale = this._barSpace / prevBarSpace;
      if (realScale !== 1) {
        this.executeAction("onZoom", { scale: realScale });
      }
    };
    StoreImp2.prototype.setZoomEnabled = function(enabled) {
      this._zoomEnabled = enabled;
    };
    StoreImp2.prototype.isZoomEnabled = function() {
      return this._zoomEnabled;
    };
    StoreImp2.prototype.setZoomAnchor = function(anchor) {
      if (isString(anchor)) {
        this._zoomAnchor.main = anchor;
        this._zoomAnchor.xAxis = anchor;
      } else {
        if (isString(anchor.main)) {
          this._zoomAnchor.main = anchor.main;
        }
        if (isString(anchor.xAxis)) {
          this._zoomAnchor.xAxis = anchor.xAxis;
        }
      }
    };
    StoreImp2.prototype.getZoomAnchor = function() {
      return __assign({}, this._zoomAnchor);
    };
    StoreImp2.prototype.setScrollEnabled = function(enabled) {
      this._scrollEnabled = enabled;
    };
    StoreImp2.prototype.isScrollEnabled = function() {
      return this._scrollEnabled;
    };
    StoreImp2.prototype.setCrosshair = function(crosshair, options) {
      var _a;
      var _b = options !== null && options !== void 0 ? options : {}, notInvalidate = _b.notInvalidate, notExecuteAction = _b.notExecuteAction, forceInvalidate = _b.forceInvalidate;
      var cr = crosshair !== null && crosshair !== void 0 ? crosshair : {};
      var realDataIndex = 0;
      var dataIndex = 0;
      if (isNumber(cr.x)) {
        realDataIndex = this.coordinateToDataIndex(cr.x);
        if (realDataIndex < 0) {
          dataIndex = 0;
        } else if (realDataIndex > this._dataList.length - 1) {
          dataIndex = this._dataList.length - 1;
        } else {
          dataIndex = realDataIndex;
        }
      } else {
        realDataIndex = this._dataList.length - 1;
        dataIndex = realDataIndex;
      }
      var kLineData = this._dataList[dataIndex];
      var realX = this.dataIndexToCoordinate(realDataIndex);
      var prevCrosshair = { x: this._crosshair.x, y: this._crosshair.y, paneId: this._crosshair.paneId };
      this._crosshair = __assign(__assign({}, cr), { realX, kLineData, realDataIndex, dataIndex, timestamp: (_a = this.dataIndexToTimestamp(realDataIndex)) !== null && _a !== void 0 ? _a : void 0 });
      if (prevCrosshair.x !== cr.x || prevCrosshair.y !== cr.y || prevCrosshair.paneId !== cr.paneId || (forceInvalidate !== null && forceInvalidate !== void 0 ? forceInvalidate : false)) {
        if (isValid(kLineData) && !(notExecuteAction !== null && notExecuteAction !== void 0 ? notExecuteAction : false) && this.hasAction("onCrosshairChange") && isString(this._crosshair.paneId)) {
          this.executeAction("onCrosshairChange", crosshair);
        }
        if (!(notInvalidate !== null && notInvalidate !== void 0 ? notInvalidate : false)) {
          this._chart.updatePane(
            1
            /* UpdateLevel.Overlay */
          );
        }
      }
    };
    StoreImp2.prototype.getCrosshair = function() {
      return this._crosshair;
    };
    StoreImp2.prototype.executeAction = function(type, data) {
      var _a;
      (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.execute(data);
    };
    StoreImp2.prototype.subscribeAction = function(type, callback) {
      var _a;
      if (!this._actions.has(type)) {
        this._actions.set(type, new Action());
      }
      (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.subscribe(callback);
    };
    StoreImp2.prototype.unsubscribeAction = function(type, callback) {
      var action = this._actions.get(type);
      if (isValid(action)) {
        action.unsubscribe(callback);
        if (action.isEmpty()) {
          this._actions.delete(type);
        }
      }
    };
    StoreImp2.prototype.hasAction = function(type) {
      var action = this._actions.get(type);
      return isValid(action) && !action.isEmpty();
    };
    StoreImp2.prototype._sortIndicators = function(paneId) {
      var _a;
      if (isString(paneId)) {
        (_a = this._indicators.get(paneId)) === null || _a === void 0 ? void 0 : _a.sort(function(i1, i2) {
          return i1.zLevel - i2.zLevel;
        });
      } else {
        this._indicators.forEach(function(paneIndicators) {
          paneIndicators.sort(function(i1, i2) {
            return i1.zLevel - i2.zLevel;
          });
        });
      }
    };
    StoreImp2.prototype._calcIndicator = function(data) {
      var _this = this;
      var indicators2 = [];
      indicators2 = indicators2.concat(data);
      if (indicators2.length > 0) {
        var tasks_1 = {};
        indicators2.forEach(function(indicator) {
          tasks_1[indicator.id] = indicator.calcImp(_this._dataList);
        });
        this._taskScheduler.add(tasks_1);
      }
    };
    StoreImp2.prototype.addIndicator = function(create, paneId, isStack) {
      var name = create.name;
      var filterIndicators = this.getIndicatorsByFilter(create);
      if (filterIndicators.length > 0) {
        return false;
      }
      var paneIndicators = this.getIndicatorsByPaneId(paneId);
      var IndicatorClazz = getIndicatorClass(name);
      var indicator = new IndicatorClazz();
      this._synchronizeIndicatorSeriesPrecision(indicator);
      indicator.paneId = paneId;
      indicator.override(create);
      if (!isStack) {
        this.removeIndicator({ paneId });
        paneIndicators = [];
      }
      paneIndicators.push(indicator);
      this._indicators.set(paneId, paneIndicators);
      this._sortIndicators(paneId);
      this._calcIndicator(indicator);
      return true;
    };
    StoreImp2.prototype.getIndicatorsByPaneId = function(paneId) {
      var _a;
      return (_a = this._indicators.get(paneId)) !== null && _a !== void 0 ? _a : [];
    };
    StoreImp2.prototype.getIndicatorsByFilter = function(filter) {
      var paneId = filter.paneId, name = filter.name, id = filter.id;
      var match = function(indicator) {
        if (isValid(id)) {
          return indicator.id === id;
        }
        return !isValid(name) || indicator.name === name;
      };
      var indicators2 = [];
      if (isValid(paneId)) {
        indicators2 = indicators2.concat(this.getIndicatorsByPaneId(paneId).filter(match));
      } else {
        this._indicators.forEach(function(paneIndicators) {
          indicators2 = indicators2.concat(paneIndicators.filter(match));
        });
      }
      return indicators2;
    };
    StoreImp2.prototype.removeIndicator = function(filter) {
      var _this = this;
      var removed = false;
      var filterIndicators = this.getIndicatorsByFilter(filter);
      filterIndicators.forEach(function(indicator) {
        var paneIndicators = _this.getIndicatorsByPaneId(indicator.paneId);
        var index = paneIndicators.findIndex(function(ins) {
          return ins.id === indicator.id;
        });
        if (index > -1) {
          paneIndicators.splice(index, 1);
          removed = true;
        }
        if (paneIndicators.length === 0) {
          _this._indicators.delete(indicator.paneId);
        }
      });
      return removed;
    };
    StoreImp2.prototype.hasIndicators = function(paneId) {
      return this._indicators.has(paneId);
    };
    StoreImp2.prototype._synchronizeIndicatorSeriesPrecision = function(indicator) {
      if (isValid(this._symbol)) {
        var _a = this._symbol, _b = _a.pricePrecision, pricePrecision_1 = _b === void 0 ? SymbolDefaultPrecisionConstants.PRICE : _b, _c = _a.volumePrecision, volumePrecision_1 = _c === void 0 ? SymbolDefaultPrecisionConstants.VOLUME : _c;
        var synchronize_1 = function(indicator2) {
          switch (indicator2.series) {
            case "price": {
              indicator2.setSeriesPrecision(pricePrecision_1);
              break;
            }
            case "volume": {
              indicator2.setSeriesPrecision(volumePrecision_1);
              break;
            }
          }
        };
        if (isValid(indicator)) {
          synchronize_1(indicator);
        } else {
          this._indicators.forEach(function(paneIndicators) {
            paneIndicators.forEach(function(indicator2) {
              synchronize_1(indicator2);
            });
          });
        }
      }
    };
    StoreImp2.prototype.overrideIndicator = function(override) {
      var _this = this;
      var updateFlag = false;
      var sortFlag = false;
      var filterIndicators = this.getIndicatorsByFilter(override);
      filterIndicators.forEach(function(indicator) {
        indicator.override(override);
        var _a = indicator.shouldUpdateImp(), calc = _a.calc, draw = _a.draw, sort = _a.sort;
        if (sort) {
          sortFlag = true;
        }
        if (calc) {
          _this._calcIndicator(indicator);
        } else {
          if (draw) {
            updateFlag = true;
          }
        }
      });
      if (sortFlag) {
        this._sortIndicators();
      }
      if (updateFlag) {
        this._chart.layout({ update: true });
        return true;
      }
      return false;
    };
    StoreImp2.prototype.getOverlaysByFilter = function(filter) {
      var _a;
      var id = filter.id, groupId = filter.groupId, paneId = filter.paneId, name = filter.name;
      var match = function(overlay) {
        if (isValid(id)) {
          return overlay.id === id;
        } else {
          if (isValid(groupId)) {
            return overlay.groupId === groupId && (!isValid(name) || overlay.name === name);
          }
        }
        return !isValid(name) || overlay.name === name;
      };
      var overlays2 = [];
      if (isValid(paneId)) {
        overlays2 = overlays2.concat(this.getOverlaysByPaneId(paneId).filter(match));
      } else {
        this._overlays.forEach(function(paneOverlays) {
          overlays2 = overlays2.concat(paneOverlays.filter(match));
        });
      }
      var progressOverlay = (_a = this._progressOverlayInfo) === null || _a === void 0 ? void 0 : _a.overlay;
      if (isValid(progressOverlay) && match(progressOverlay)) {
        overlays2.push(progressOverlay);
      }
      return overlays2;
    };
    StoreImp2.prototype.getOverlaysByPaneId = function(paneId) {
      var _a;
      if (!isString(paneId)) {
        var overlays_1 = [];
        this._overlays.forEach(function(paneOverlays) {
          overlays_1 = overlays_1.concat(paneOverlays);
        });
        return overlays_1;
      }
      return (_a = this._overlays.get(paneId)) !== null && _a !== void 0 ? _a : [];
    };
    StoreImp2.prototype._sortOverlays = function(paneId) {
      var _a;
      if (isString(paneId)) {
        (_a = this._overlays.get(paneId)) === null || _a === void 0 ? void 0 : _a.sort(function(o1, o2) {
          return o1.zLevel - o2.zLevel;
        });
      } else {
        this._overlays.forEach(function(paneOverlays) {
          paneOverlays.sort(function(o1, o2) {
            return o1.zLevel - o2.zLevel;
          });
        });
      }
    };
    StoreImp2.prototype.addOverlays = function(os, appointPaneFlags) {
      var _this = this;
      var updatePaneIds = [];
      var ids = os.map(function(create, index) {
        var e_1, _a;
        var _b, _c, _d, _e, _f, _g;
        if (isValid(create.id)) {
          var findOverlay = null;
          try {
            for (var _h = __values(_this._overlays), _j = _h.next(); !_j.done; _j = _h.next()) {
              var item = _j.value;
              var overlays2 = item[1];
              var overlay = overlays2.find(function(o) {
                return o.id === create.id;
              });
              if (isValid(overlay)) {
                findOverlay = overlay;
                break;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (isValid(findOverlay)) {
            return create.id;
          }
        }
        var OverlayClazz = getOverlayInnerClass(create.name);
        if (isValid(OverlayClazz)) {
          var id = (_b = create.id) !== null && _b !== void 0 ? _b : createId(OVERLAY_ID_PREFIX);
          var overlay = new OverlayClazz();
          var paneId = (_c = create.paneId) !== null && _c !== void 0 ? _c : PaneIdConstants.CANDLE;
          create.id = id;
          (_d = create.groupId) !== null && _d !== void 0 ? _d : create.groupId = id;
          var zLevel = _this.getOverlaysByPaneId(paneId).length;
          (_e = create.zLevel) !== null && _e !== void 0 ? _e : create.zLevel = zLevel;
          overlay.override(create);
          if (!updatePaneIds.includes(paneId)) {
            updatePaneIds.push(paneId);
          }
          if (overlay.isDrawing()) {
            _this._progressOverlayInfo = { paneId, overlay, appointPaneFlag: appointPaneFlags[index] };
          } else {
            if (!_this._overlays.has(paneId)) {
              _this._overlays.set(paneId, []);
            }
            (_f = _this._overlays.get(paneId)) === null || _f === void 0 ? void 0 : _f.push(overlay);
          }
          if (overlay.isStart()) {
            (_g = overlay.onDrawStart) === null || _g === void 0 ? void 0 : _g.call(overlay, { overlay, chart: _this._chart });
          }
          return id;
        }
        return null;
      });
      if (updatePaneIds.length > 0) {
        this._sortOverlays();
        updatePaneIds.forEach(function(paneId) {
          _this._chart.updatePane(1, paneId);
        });
        this._chart.updatePane(1, PaneIdConstants.X_AXIS);
      }
      return ids;
    };
    StoreImp2.prototype.getProgressOverlayInfo = function() {
      return this._progressOverlayInfo;
    };
    StoreImp2.prototype.progressOverlayComplete = function() {
      var _a;
      if (this._progressOverlayInfo !== null) {
        var _b = this._progressOverlayInfo, overlay = _b.overlay, paneId = _b.paneId;
        if (!overlay.isDrawing()) {
          if (!this._overlays.has(paneId)) {
            this._overlays.set(paneId, []);
          }
          (_a = this._overlays.get(paneId)) === null || _a === void 0 ? void 0 : _a.push(overlay);
          this._sortOverlays(paneId);
          this._progressOverlayInfo = null;
        }
      }
    };
    StoreImp2.prototype.updateProgressOverlayInfo = function(paneId, appointPaneFlag) {
      if (this._progressOverlayInfo !== null) {
        if (isBoolean(appointPaneFlag) && appointPaneFlag) {
          this._progressOverlayInfo.appointPaneFlag = appointPaneFlag;
        }
        this._progressOverlayInfo.paneId = paneId;
        this._progressOverlayInfo.overlay.override({ paneId });
      }
    };
    StoreImp2.prototype.overrideOverlay = function(override) {
      var _this = this;
      var sortFlag = false;
      var updatePaneIds = [];
      var filterOverlays = this.getOverlaysByFilter(override);
      filterOverlays.forEach(function(overlay) {
        overlay.override(override);
        var _a = overlay.shouldUpdate(), sort = _a.sort, draw = _a.draw;
        if (sort) {
          sortFlag = true;
        }
        if (sort || draw) {
          if (!updatePaneIds.includes(overlay.paneId)) {
            updatePaneIds.push(overlay.paneId);
          }
        }
      });
      if (sortFlag) {
        this._sortOverlays();
      }
      if (updatePaneIds.length > 0) {
        updatePaneIds.forEach(function(paneId) {
          _this._chart.updatePane(1, paneId);
        });
        this._chart.updatePane(1, PaneIdConstants.X_AXIS);
        return true;
      }
      return false;
    };
    StoreImp2.prototype.removeOverlay = function(filter) {
      var _this = this;
      var updatePaneIds = [];
      var filterOverlays = this.getOverlaysByFilter(filter);
      filterOverlays.forEach(function(overlay) {
        var _a;
        var paneId = overlay.paneId;
        var paneOverlays = _this.getOverlaysByPaneId(overlay.paneId);
        (_a = overlay.onRemoved) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, chart: _this._chart });
        if (!updatePaneIds.includes(paneId)) {
          updatePaneIds.push(paneId);
        }
        if (overlay.isDrawing()) {
          _this._progressOverlayInfo = null;
        } else {
          var index = paneOverlays.findIndex(function(o) {
            return o.id === overlay.id;
          });
          if (index > -1) {
            paneOverlays.splice(index, 1);
          }
        }
        if (paneOverlays.length === 0) {
          _this._overlays.delete(paneId);
        }
      });
      if (updatePaneIds.length > 0) {
        updatePaneIds.forEach(function(paneId) {
          _this._chart.updatePane(1, paneId);
        });
        this._chart.updatePane(1, PaneIdConstants.X_AXIS);
        return true;
      }
      return false;
    };
    StoreImp2.prototype.setPressedOverlayInfo = function(info) {
      this._pressedOverlayInfo = info;
    };
    StoreImp2.prototype.getPressedOverlayInfo = function() {
      return this._pressedOverlayInfo;
    };
    StoreImp2.prototype.setHoverOverlayInfo = function(info, processOnMouseEnterEvent, processOnMouseLeaveEvent) {
      var _a = this._hoverOverlayInfo, overlay = _a.overlay, figureType = _a.figureType, figureIndex = _a.figureIndex, figure = _a.figure;
      var infoOverlay = info.overlay;
      if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id) || figureType !== info.figureType || figureIndex !== info.figureIndex) {
        this._hoverOverlayInfo = info;
        if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id)) {
          var ignoreUpdateFlag = false;
          var sortFlag = false;
          if (overlay !== null) {
            overlay.override({ zLevel: overlay.getPrevZLevel() });
            sortFlag = true;
            if (processOnMouseLeaveEvent(overlay, figure)) {
              ignoreUpdateFlag = true;
            }
          }
          if (infoOverlay !== null) {
            infoOverlay.setPrevZLevel(infoOverlay.zLevel);
            infoOverlay.override({ zLevel: Number.MAX_SAFE_INTEGER });
            sortFlag = true;
            if (processOnMouseEnterEvent(infoOverlay, info.figure)) {
              ignoreUpdateFlag = true;
            }
          }
          if (sortFlag) {
            this._sortOverlays();
          }
          if (!ignoreUpdateFlag) {
            this._chart.updatePane(
              1
              /* UpdateLevel.Overlay */
            );
          }
        }
      }
    };
    StoreImp2.prototype.getHoverOverlayInfo = function() {
      return this._hoverOverlayInfo;
    };
    StoreImp2.prototype.setClickOverlayInfo = function(info, processOnSelectedEvent, processOnDeselectedEvent) {
      var _a = this._clickOverlayInfo, paneId = _a.paneId, overlay = _a.overlay, figureType = _a.figureType, figure = _a.figure, figureIndex = _a.figureIndex;
      var infoOverlay = info.overlay;
      if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id) || figureType !== info.figureType || figureIndex !== info.figureIndex) {
        this._clickOverlayInfo = info;
        if ((overlay === null || overlay === void 0 ? void 0 : overlay.id) !== (infoOverlay === null || infoOverlay === void 0 ? void 0 : infoOverlay.id)) {
          if (isValid(overlay)) {
            processOnDeselectedEvent(overlay, figure);
          }
          if (isValid(infoOverlay)) {
            processOnSelectedEvent(infoOverlay, info.figure);
          }
          this._chart.updatePane(1, info.paneId);
          if (paneId !== info.paneId) {
            this._chart.updatePane(1, paneId);
          }
          this._chart.updatePane(1, PaneIdConstants.X_AXIS);
        }
      }
    };
    StoreImp2.prototype.getClickOverlayInfo = function() {
      return this._clickOverlayInfo;
    };
    StoreImp2.prototype.isOverlayEmpty = function() {
      return this._overlays.size === 0 && this._progressOverlayInfo === null;
    };
    StoreImp2.prototype.isOverlayDrawing = function() {
      var _a, _b;
      return (_b = (_a = this._progressOverlayInfo) === null || _a === void 0 ? void 0 : _a.overlay.isDrawing()) !== null && _b !== void 0 ? _b : false;
    };
    StoreImp2.prototype._clearLastPriceMarkExtendTextUpdateTimer = function() {
      this._lastPriceMarkExtendTextUpdateTimers.forEach(function(timer) {
        clearInterval(timer);
      });
      this._lastPriceMarkExtendTextUpdateTimers = [];
    };
    StoreImp2.prototype._clearData = function() {
      this._dataLoadMore.backward = false;
      this._dataLoadMore.forward = false;
      this._loading = false;
      this._dataList = [];
      this._visibleRangeDataList = [];
      this._visibleRangeHighLowPrice = [
        { x: 0, price: Number.MIN_SAFE_INTEGER },
        { x: 0, price: Number.MAX_SAFE_INTEGER }
      ];
      this._visibleRange = getDefaultVisibleRange();
      this._crosshair = {};
    };
    StoreImp2.prototype.getChart = function() {
      return this._chart;
    };
    StoreImp2.prototype.destroy = function() {
      this._clearData();
      this._clearLastPriceMarkExtendTextUpdateTimer();
      this._taskScheduler.clear();
      this._overlays.clear();
      this._indicators.clear();
      this._actions.clear();
    };
    return StoreImp2;
  }()
);
var WidgetNameConstants = {
  MAIN: "main",
  X_AXIS: "xAxis",
  Y_AXIS: "yAxis",
  SEPARATOR: "separator"
};
var REAL_SEPARATOR_HEIGHT = 7;
function isSupportedDevicePixelContentBox() {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, new Promise(function(resolve) {
            var ro = new ResizeObserver(function(entries) {
              resolve(entries.every(function(entry) {
                return "devicePixelContentBoxSize" in entry;
              }));
              ro.disconnect();
            });
            ro.observe(document.body, { box: "device-pixel-content-box" });
          }).catch(function() {
            return false;
          })];
        case 1:
          return [2, _a.sent()];
      }
    });
  });
}
var Canvas = (
  /** @class */
  function() {
    function Canvas2(style, listener) {
      var _this = this;
      this._supportedDevicePixelContentBox = false;
      this._width = 0;
      this._height = 0;
      this._pixelWidth = 0;
      this._pixelHeight = 0;
      this._nextPixelWidth = 0;
      this._nextPixelHeight = 0;
      this._requestAnimationId = DEFAULT_REQUEST_ID;
      this._mediaQueryListener = function() {
        var pixelRatio = getPixelRatio(_this._element);
        _this._nextPixelWidth = Math.round(_this._element.clientWidth * pixelRatio);
        _this._nextPixelHeight = Math.round(_this._element.clientHeight * pixelRatio);
        _this._resetPixelRatio();
      };
      this._listener = listener;
      this._element = createDom("canvas", style);
      this._ctx = this._element.getContext("2d");
      isSupportedDevicePixelContentBox().then(function(result) {
        _this._supportedDevicePixelContentBox = result;
        if (result) {
          _this._resizeObserver = new ResizeObserver(function(entries) {
            var entry = entries.find(function(entry2) {
              return entry2.target === _this._element;
            });
            var size = entry === null || entry === void 0 ? void 0 : entry.devicePixelContentBoxSize[0];
            if (isValid(size)) {
              _this._nextPixelWidth = size.inlineSize;
              _this._nextPixelHeight = size.blockSize;
              if (_this._pixelWidth !== _this._nextPixelWidth || _this._pixelHeight !== _this._nextPixelHeight) {
                _this._resetPixelRatio();
              }
            }
          });
          _this._resizeObserver.observe(_this._element, { box: "device-pixel-content-box" });
        } else {
          _this._mediaQueryList = window.matchMedia("(resolution: ".concat(getPixelRatio(_this._element), "dppx)"));
          _this._mediaQueryList.addListener(_this._mediaQueryListener);
        }
      }).catch(function(_) {
        return false;
      });
    }
    Canvas2.prototype._resetPixelRatio = function() {
      var _this = this;
      this._executeListener(function() {
        var width = _this._element.clientWidth;
        var height = _this._element.clientHeight;
        _this._width = width;
        _this._height = height;
        _this._pixelWidth = _this._nextPixelWidth;
        _this._pixelHeight = _this._nextPixelHeight;
        _this._element.width = _this._nextPixelWidth;
        _this._element.height = _this._nextPixelHeight;
        var horizontalPixelRatio = _this._nextPixelWidth / width;
        var verticalPixelRatio = _this._nextPixelHeight / height;
        _this._ctx.scale(horizontalPixelRatio, verticalPixelRatio);
      });
    };
    Canvas2.prototype._executeListener = function(fn) {
      var _this = this;
      if (this._requestAnimationId === DEFAULT_REQUEST_ID) {
        this._requestAnimationId = requestAnimationFrame(function() {
          _this._ctx.clearRect(0, 0, _this._width, _this._height);
          fn === null || fn === void 0 ? void 0 : fn();
          _this._listener();
          _this._requestAnimationId = DEFAULT_REQUEST_ID;
        });
      }
    };
    Canvas2.prototype.update = function(w, h) {
      if (this._width !== w || this._height !== h) {
        this._element.style.width = "".concat(w, "px");
        this._element.style.height = "".concat(h, "px");
        if (!this._supportedDevicePixelContentBox) {
          var pixelRatio = getPixelRatio(this._element);
          this._nextPixelWidth = Math.round(w * pixelRatio);
          this._nextPixelHeight = Math.round(h * pixelRatio);
          this._resetPixelRatio();
        }
      } else {
        this._executeListener();
      }
    };
    Canvas2.prototype.getElement = function() {
      return this._element;
    };
    Canvas2.prototype.getContext = function() {
      return this._ctx;
    };
    Canvas2.prototype.destroy = function() {
      if (isValid(this._resizeObserver)) {
        this._resizeObserver.unobserve(this._element);
      }
      if (isValid(this._mediaQueryList)) {
        this._mediaQueryList.removeListener(this._mediaQueryListener);
      }
    };
    return Canvas2;
  }()
);
var Widget = (
  /** @class */
  function(_super) {
    __extends(Widget2, _super);
    function Widget2(rootContainer, pane) {
      var _this = _super.call(this) || this;
      _this._bounding = createDefaultBounding();
      _this._cursor = "crosshair";
      _this._forceCursor = null;
      _this._pane = pane;
      _this._rootContainer = rootContainer;
      _this._container = _this.createContainer();
      rootContainer.appendChild(_this._container);
      return _this;
    }
    Widget2.prototype.setBounding = function(bounding) {
      merge(this._bounding, bounding);
      return this;
    };
    Widget2.prototype.getContainer = function() {
      return this._container;
    };
    Widget2.prototype.getBounding = function() {
      return this._bounding;
    };
    Widget2.prototype.getPane = function() {
      return this._pane;
    };
    Widget2.prototype.checkEventOn = function(_) {
      return true;
    };
    Widget2.prototype.setCursor = function(cursor) {
      if (!isString(this._forceCursor)) {
        if (cursor !== this._cursor) {
          this._cursor = cursor;
          this._container.style.cursor = this._cursor;
        }
      }
    };
    Widget2.prototype.setForceCursor = function(cursor) {
      var _a;
      if (cursor !== this._forceCursor) {
        this._forceCursor = cursor;
        this._container.style.cursor = (_a = this._forceCursor) !== null && _a !== void 0 ? _a : this._cursor;
      }
    };
    Widget2.prototype.getForceCursor = function() {
      return this._forceCursor;
    };
    Widget2.prototype.update = function(level) {
      this.updateImp(
        this._container,
        this._bounding,
        level !== null && level !== void 0 ? level : 3
        /* UpdateLevel.Drawer */
      );
    };
    Widget2.prototype.destroy = function() {
      this._rootContainer.removeChild(this._container);
    };
    return Widget2;
  }(Eventful)
);
var DrawWidget = (
  /** @class */
  function(_super) {
    __extends(DrawWidget2, _super);
    function DrawWidget2(rootContainer, pane) {
      var _this = _super.call(this, rootContainer, pane) || this;
      _this._mainCanvas = new Canvas({
        position: "absolute",
        top: "0",
        left: "0",
        zIndex: "2",
        boxSizing: "border-box"
      }, function() {
        _this.updateMain(_this._mainCanvas.getContext());
      });
      _this._overlayCanvas = new Canvas({
        position: "absolute",
        top: "0",
        left: "0",
        zIndex: "2",
        boxSizing: "border-box"
      }, function() {
        _this.updateOverlay(_this._overlayCanvas.getContext());
      });
      var container = _this.getContainer();
      container.appendChild(_this._mainCanvas.getElement());
      container.appendChild(_this._overlayCanvas.getElement());
      return _this;
    }
    DrawWidget2.prototype.createContainer = function() {
      return createDom("div", {
        margin: "0",
        padding: "0",
        position: "absolute",
        top: "0",
        overflow: "hidden",
        boxSizing: "border-box",
        zIndex: "1"
      });
    };
    DrawWidget2.prototype.updateImp = function(container, bounding, level) {
      var width = bounding.width, height = bounding.height, left = bounding.left;
      container.style.left = "".concat(left, "px");
      var l = level;
      var w = container.clientWidth;
      var h = container.clientHeight;
      if (width !== w || height !== h) {
        container.style.width = "".concat(width, "px");
        container.style.height = "".concat(height, "px");
        l = 3;
      }
      switch (l) {
        case 0: {
          this._mainCanvas.update(width, height);
          break;
        }
        case 1: {
          this._overlayCanvas.update(width, height);
          break;
        }
        case 3:
        case 4: {
          this._mainCanvas.update(width, height);
          this._overlayCanvas.update(width, height);
          break;
        }
      }
    };
    DrawWidget2.prototype.destroy = function() {
      this._mainCanvas.destroy();
      this._overlayCanvas.destroy();
    };
    DrawWidget2.prototype.getImage = function(includeOverlay) {
      var _a = this.getBounding(), width = _a.width, height = _a.height;
      var canvas = createDom("canvas", {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: "border-box"
      });
      var ctx = canvas.getContext("2d");
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      ctx.drawImage(this._mainCanvas.getElement(), 0, 0, width, height);
      if (includeOverlay) {
        ctx.drawImage(this._overlayCanvas.getElement(), 0, 0, width, height);
      }
      return canvas;
    };
    return DrawWidget2;
  }(Widget)
);
function checkCoordinateOnCircle(coordinate, attrs) {
  var e_1, _a;
  var circles = [];
  circles = circles.concat(attrs);
  try {
    for (var circles_1 = __values(circles), circles_1_1 = circles_1.next(); !circles_1_1.done; circles_1_1 = circles_1.next()) {
      var circle_1 = circles_1_1.value;
      var x = circle_1.x, y = circle_1.y, r = circle_1.r;
      var difX = coordinate.x - x;
      var difY = coordinate.y - y;
      if (!(difX * difX + difY * difY > r * r)) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (circles_1_1 && !circles_1_1.done && (_a = circles_1.return)) _a.call(circles_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function drawCircle(ctx, attrs, styles2) {
  var circles = [];
  circles = circles.concat(attrs);
  var _a = styles2.style, style = _a === void 0 ? "fill" : _a, _b = styles2.color, color = _b === void 0 ? "currentColor" : _b, _c = styles2.borderSize, borderSize = _c === void 0 ? 1 : _c, _d = styles2.borderColor, borderColor = _d === void 0 ? "currentColor" : _d, _e = styles2.borderStyle, borderStyle = _e === void 0 ? "solid" : _e, _f = styles2.borderDashedValue, borderDashedValue = _f === void 0 ? [2, 2] : _f;
  var solid = (style === "fill" || styles2.style === "stroke_fill") && (!isString(color) || !isTransparent(color));
  if (solid) {
    ctx.fillStyle = color;
    circles.forEach(function(_a2) {
      var x = _a2.x, y = _a2.y, r = _a2.r;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fill();
    });
  }
  if ((style === "stroke" || styles2.style === "stroke_fill") && borderSize > 0 && !isTransparent(borderColor)) {
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderSize;
    if (borderStyle === "dashed") {
      ctx.setLineDash(borderDashedValue);
    } else {
      ctx.setLineDash([]);
    }
    circles.forEach(function(_a2) {
      var x = _a2.x, y = _a2.y, r = _a2.r;
      if (!solid || r > borderSize) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
      }
    });
  }
}
var circle = {
  name: "circle",
  checkEventOn: checkCoordinateOnCircle,
  draw: function(ctx, attrs, styles2) {
    drawCircle(ctx, attrs, styles2);
  }
};
function checkCoordinateOnPolygon(coordinate, attrs) {
  var e_1, _a;
  var polygons = [];
  polygons = polygons.concat(attrs);
  try {
    for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
      var polygon_1 = polygons_1_1.value;
      var on = false;
      var coordinates = polygon_1.coordinates;
      for (var i = 0, j = coordinates.length - 1; i < coordinates.length; j = i++) {
        if (coordinates[i].y > coordinate.y !== coordinates[j].y > coordinate.y && coordinate.x < (coordinates[j].x - coordinates[i].x) * (coordinate.y - coordinates[i].y) / (coordinates[j].y - coordinates[i].y) + coordinates[i].x) {
          on = !on;
        }
      }
      if (on) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1.return)) _a.call(polygons_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function drawPolygon(ctx, attrs, styles2) {
  var polygons = [];
  polygons = polygons.concat(attrs);
  var _a = styles2.style, style = _a === void 0 ? "fill" : _a, _b = styles2.color, color = _b === void 0 ? "currentColor" : _b, _c = styles2.borderSize, borderSize = _c === void 0 ? 1 : _c, _d = styles2.borderColor, borderColor = _d === void 0 ? "currentColor" : _d, _e = styles2.borderStyle, borderStyle = _e === void 0 ? "solid" : _e, _f = styles2.borderDashedValue, borderDashedValue = _f === void 0 ? [2, 2] : _f;
  if ((style === "fill" || styles2.style === "stroke_fill") && (!isString(color) || !isTransparent(color))) {
    ctx.fillStyle = color;
    polygons.forEach(function(_a2) {
      var coordinates = _a2.coordinates;
      ctx.beginPath();
      ctx.moveTo(coordinates[0].x, coordinates[0].y);
      for (var i = 1; i < coordinates.length; i++) {
        ctx.lineTo(coordinates[i].x, coordinates[i].y);
      }
      ctx.closePath();
      ctx.fill();
    });
  }
  if ((style === "stroke" || styles2.style === "stroke_fill") && borderSize > 0 && !isTransparent(borderColor)) {
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderSize;
    if (borderStyle === "dashed") {
      ctx.setLineDash(borderDashedValue);
    } else {
      ctx.setLineDash([]);
    }
    polygons.forEach(function(_a2) {
      var coordinates = _a2.coordinates;
      ctx.beginPath();
      ctx.moveTo(coordinates[0].x, coordinates[0].y);
      for (var i = 1; i < coordinates.length; i++) {
        ctx.lineTo(coordinates[i].x, coordinates[i].y);
      }
      ctx.closePath();
      ctx.stroke();
    });
  }
}
var polygon = {
  name: "polygon",
  checkEventOn: checkCoordinateOnPolygon,
  draw: function(ctx, attrs, styles2) {
    drawPolygon(ctx, attrs, styles2);
  }
};
function checkCoordinateOnRect(coordinate, attrs) {
  var e_1, _a;
  var rects = [];
  rects = rects.concat(attrs);
  try {
    for (var rects_1 = __values(rects), rects_1_1 = rects_1.next(); !rects_1_1.done; rects_1_1 = rects_1.next()) {
      var rect_1 = rects_1_1.value;
      var x = rect_1.x;
      var width = rect_1.width;
      if (width < DEVIATION * 2) {
        x -= DEVIATION;
        width = DEVIATION * 2;
      }
      var y = rect_1.y;
      var height = rect_1.height;
      if (height < DEVIATION * 2) {
        y -= DEVIATION;
        height = DEVIATION * 2;
      }
      if (coordinate.x >= x && coordinate.x <= x + width && coordinate.y >= y && coordinate.y <= y + height) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (rects_1_1 && !rects_1_1.done && (_a = rects_1.return)) _a.call(rects_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function drawRect(ctx, attrs, styles2) {
  var _a;
  var rects = [];
  rects = rects.concat(attrs);
  var _b = styles2.style, style = _b === void 0 ? "fill" : _b, _c = styles2.color, color = _c === void 0 ? "transparent" : _c, _d = styles2.borderSize, borderSize = _d === void 0 ? 1 : _d, _e = styles2.borderColor, borderColor = _e === void 0 ? "transparent" : _e, _f = styles2.borderStyle, borderStyle = _f === void 0 ? "solid" : _f, _g = styles2.borderRadius, r = _g === void 0 ? 0 : _g, _h = styles2.borderDashedValue, borderDashedValue = _h === void 0 ? [2, 2] : _h;
  var draw = (_a = ctx.roundRect) !== null && _a !== void 0 ? _a : ctx.rect;
  var solid = (style === "fill" || styles2.style === "stroke_fill") && (!isString(color) || !isTransparent(color));
  if (solid) {
    ctx.fillStyle = color;
    rects.forEach(function(_a2) {
      var x = _a2.x, y = _a2.y, w = _a2.width, h = _a2.height;
      ctx.beginPath();
      draw.call(ctx, x, y, w, h, r);
      ctx.closePath();
      ctx.fill();
    });
  }
  if ((style === "stroke" || styles2.style === "stroke_fill") && borderSize > 0 && !isTransparent(borderColor)) {
    ctx.strokeStyle = borderColor;
    ctx.fillStyle = borderColor;
    ctx.lineWidth = borderSize;
    if (borderStyle === "dashed") {
      ctx.setLineDash(borderDashedValue);
    } else {
      ctx.setLineDash([]);
    }
    var correction_1 = borderSize % 2 === 1 ? 0.5 : 0;
    var doubleCorrection_1 = Math.round(correction_1 * 2);
    rects.forEach(function(_a2) {
      var x = _a2.x, y = _a2.y, w = _a2.width, h = _a2.height;
      if (w > borderSize * 2 && h > borderSize * 2) {
        ctx.beginPath();
        draw.call(ctx, x + correction_1, y + correction_1, w - doubleCorrection_1, h - doubleCorrection_1, r);
        ctx.closePath();
        ctx.stroke();
      } else {
        if (!solid) {
          ctx.fillRect(x, y, w, h);
        }
      }
    });
  }
}
var rect = {
  name: "rect",
  checkEventOn: checkCoordinateOnRect,
  draw: function(ctx, attrs, styles2) {
    drawRect(ctx, attrs, styles2);
  }
};
function getTextRect(attrs, styles2) {
  var _a = styles2.size, size = _a === void 0 ? 12 : _a, _b = styles2.paddingLeft, paddingLeft = _b === void 0 ? 0 : _b, _c = styles2.paddingTop, paddingTop = _c === void 0 ? 0 : _c, _d = styles2.paddingRight, paddingRight = _d === void 0 ? 0 : _d, _e = styles2.paddingBottom, paddingBottom = _e === void 0 ? 0 : _e, _f = styles2.weight, weight = _f === void 0 ? "normal" : _f, family = styles2.family;
  var x = attrs.x, y = attrs.y, text2 = attrs.text, _g = attrs.align, align = _g === void 0 ? "left" : _g, _h = attrs.baseline, baseline = _h === void 0 ? "top" : _h, w = attrs.width, h = attrs.height;
  var width = w !== null && w !== void 0 ? w : paddingLeft + calcTextWidth(text2, size, weight, family) + paddingRight;
  var height = h !== null && h !== void 0 ? h : paddingTop + size + paddingBottom;
  var startX = 0;
  switch (align) {
    case "left":
    case "start": {
      startX = x;
      break;
    }
    case "right":
    case "end": {
      startX = x - width;
      break;
    }
    default: {
      startX = x - width / 2;
      break;
    }
  }
  var startY = 0;
  switch (baseline) {
    case "top":
    case "hanging": {
      startY = y;
      break;
    }
    case "bottom":
    case "ideographic":
    case "alphabetic": {
      startY = y - height;
      break;
    }
    default: {
      startY = y - height / 2;
      break;
    }
  }
  return { x: startX, y: startY, width, height };
}
function checkCoordinateOnText(coordinate, attrs, styles2) {
  var e_1, _a;
  var texts = [];
  texts = texts.concat(attrs);
  try {
    for (var texts_1 = __values(texts), texts_1_1 = texts_1.next(); !texts_1_1.done; texts_1_1 = texts_1.next()) {
      var text_1 = texts_1_1.value;
      var _b = getTextRect(text_1, styles2), x = _b.x, y = _b.y, width = _b.width, height = _b.height;
      if (coordinate.x >= x && coordinate.x <= x + width && coordinate.y >= y && coordinate.y <= y + height) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (texts_1_1 && !texts_1_1.done && (_a = texts_1.return)) _a.call(texts_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function drawText(ctx, attrs, styles2) {
  var texts = [];
  texts = texts.concat(attrs);
  var _a = styles2.color, color = _a === void 0 ? "currentColor" : _a, _b = styles2.size, size = _b === void 0 ? 12 : _b, family = styles2.family, weight = styles2.weight, _c = styles2.paddingLeft, paddingLeft = _c === void 0 ? 0 : _c, _d = styles2.paddingTop, paddingTop = _d === void 0 ? 0 : _d, _e = styles2.paddingRight, paddingRight = _e === void 0 ? 0 : _e;
  var rects = texts.map(function(text2) {
    return getTextRect(text2, styles2);
  });
  drawRect(ctx, rects, __assign(__assign({}, styles2), { color: styles2.backgroundColor }));
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.font = createFont(size, weight, family);
  ctx.fillStyle = color;
  texts.forEach(function(text2, index) {
    var rect2 = rects[index];
    ctx.fillText(text2.text, rect2.x + paddingLeft, rect2.y + paddingTop, rect2.width - paddingLeft - paddingRight);
  });
}
var text = {
  name: "text",
  checkEventOn: checkCoordinateOnText,
  draw: function(ctx, attrs, styles2) {
    drawText(ctx, attrs, styles2);
  }
};
function getDistance(coordinate1, coordinate2) {
  var xDif = coordinate1.x - coordinate2.x;
  var yDif = coordinate1.y - coordinate2.y;
  return Math.sqrt(xDif * xDif + yDif * yDif);
}
function checkCoordinateOnArc(coordinate, attrs) {
  var e_1, _a;
  var arcs = [];
  arcs = arcs.concat(attrs);
  try {
    for (var arcs_1 = __values(arcs), arcs_1_1 = arcs_1.next(); !arcs_1_1.done; arcs_1_1 = arcs_1.next()) {
      var arc_1 = arcs_1_1.value;
      if (Math.abs(getDistance(coordinate, arc_1) - arc_1.r) < DEVIATION) {
        var r = arc_1.r, startAngle = arc_1.startAngle, endAngle = arc_1.endAngle;
        var startCoordinateX = r * Math.cos(startAngle) + arc_1.x;
        var startCoordinateY = r * Math.sin(startAngle) + arc_1.y;
        var endCoordinateX = r * Math.cos(endAngle) + arc_1.x;
        var endCoordinateY = r * Math.sin(endAngle) + arc_1.y;
        if (coordinate.x <= Math.max(startCoordinateX, endCoordinateX) + DEVIATION && coordinate.x >= Math.min(startCoordinateX, endCoordinateX) - DEVIATION && coordinate.y <= Math.max(startCoordinateY, endCoordinateY) + DEVIATION && coordinate.y >= Math.min(startCoordinateY, endCoordinateY) - DEVIATION) {
          return true;
        }
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (arcs_1_1 && !arcs_1_1.done && (_a = arcs_1.return)) _a.call(arcs_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
}
function drawArc(ctx, attrs, styles2) {
  var arcs = [];
  arcs = arcs.concat(attrs);
  var _a = styles2.style, style = _a === void 0 ? "solid" : _a, _b = styles2.size, size = _b === void 0 ? 1 : _b, _c = styles2.color, color = _c === void 0 ? "currentColor" : _c, _d = styles2.dashedValue, dashedValue = _d === void 0 ? [2, 2] : _d;
  ctx.lineWidth = size;
  ctx.strokeStyle = color;
  if (style === "dashed") {
    ctx.setLineDash(dashedValue);
  } else {
    ctx.setLineDash([]);
  }
  arcs.forEach(function(_a2) {
    var x = _a2.x, y = _a2.y, r = _a2.r, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    ctx.beginPath();
    ctx.arc(x, y, r, startAngle, endAngle);
    ctx.stroke();
    ctx.closePath();
  });
}
var arc = {
  name: "arc",
  checkEventOn: checkCoordinateOnArc,
  draw: function(ctx, attrs, styles2) {
    drawArc(ctx, attrs, styles2);
  }
};
function drawEllipticalArc(ctx, x1, y1, args, offsetX, offsetY, isRelative) {
  var _a = __read(args, 7), rx = _a[0], ry = _a[1], rotation = _a[2], largeArcFlag = _a[3], sweepFlag = _a[4], x2 = _a[5], y2 = _a[6];
  var targetX = isRelative ? x1 + x2 : x2 + offsetX;
  var targetY = isRelative ? y1 + y2 : y2 + offsetY;
  var segments = ellipticalArcToBeziers(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, targetX, targetY);
  segments.forEach(function(segment2) {
    ctx.bezierCurveTo(segment2[0], segment2[1], segment2[2], segment2[3], segment2[4], segment2[5]);
  });
}
function ellipticalArcToBeziers(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2) {
  var _a = computeEllipticalArcParameters(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2), cx = _a.cx, cy = _a.cy, startAngle = _a.startAngle, deltaAngle = _a.deltaAngle;
  var segments = [];
  var numSegments = Math.ceil(Math.abs(deltaAngle) / (Math.PI / 2));
  for (var i = 0; i < numSegments; i++) {
    var start = startAngle + i * deltaAngle / numSegments;
    var end = startAngle + (i + 1) * deltaAngle / numSegments;
    var bezier = ellipticalArcToBezier(cx, cy, rx, ry, rotation, start, end);
    segments.push(bezier);
  }
  return segments;
}
function computeEllipticalArcParameters(x1, y1, rx, ry, rotation, largeArcFlag, sweepFlag, x2, y2) {
  var phi = rotation * Math.PI / 180;
  var dx = (x1 - x2) / 2;
  var dy = (y1 - y2) / 2;
  var x1p = Math.cos(phi) * dx + Math.sin(phi) * dy;
  var y1p = -Math.sin(phi) * dx + Math.cos(phi) * dy;
  var lambda = Math.pow(x1p, 2) / Math.pow(rx, 2) + Math.pow(y1p, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var sign = largeArcFlag === sweepFlag ? -1 : 1;
  var numerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(y1p, 2) - Math.pow(ry, 2) * Math.pow(x1p, 2);
  var denominator = Math.pow(rx, 2) * Math.pow(y1p, 2) + Math.pow(ry, 2) * Math.pow(x1p, 2);
  var cxp = sign * Math.sqrt(Math.abs(numerator / denominator)) * (rx * y1p / ry);
  var cyp = sign * Math.sqrt(Math.abs(numerator / denominator)) * (-ry * x1p / rx);
  var cx = Math.cos(phi) * cxp - Math.sin(phi) * cyp + (x1 + x2) / 2;
  var cy = Math.sin(phi) * cxp + Math.cos(phi) * cyp + (y1 + y2) / 2;
  var startAngle = Math.atan2((y1p - cyp) / ry, (x1p - cxp) / rx);
  var deltaAngle = Math.atan2((-y1p - cyp) / ry, (-x1p - cxp) / rx) - startAngle;
  if (deltaAngle < 0 && sweepFlag === 1) {
    deltaAngle += 2 * Math.PI;
  } else if (deltaAngle > 0 && sweepFlag === 0) {
    deltaAngle -= 2 * Math.PI;
  }
  return { cx, cy, startAngle, deltaAngle };
}
function ellipticalArcToBezier(cx, cy, rx, ry, rotation, startAngle, endAngle) {
  var alpha = Math.sin(endAngle - startAngle) * (Math.sqrt(4 + 3 * Math.pow(Math.tan((endAngle - startAngle) / 2), 2)) - 1) / 3;
  var cosPhi = Math.cos(rotation);
  var sinPhi = Math.sin(rotation);
  var x1 = cx + rx * Math.cos(startAngle) * cosPhi - ry * Math.sin(startAngle) * sinPhi;
  var y1 = cy + rx * Math.cos(startAngle) * sinPhi + ry * Math.sin(startAngle) * cosPhi;
  var x2 = cx + rx * Math.cos(endAngle) * cosPhi - ry * Math.sin(endAngle) * sinPhi;
  var y2 = cy + rx * Math.cos(endAngle) * sinPhi + ry * Math.sin(endAngle) * cosPhi;
  var cp1x = x1 + alpha * (-rx * Math.sin(startAngle) * cosPhi - ry * Math.cos(startAngle) * sinPhi);
  var cp1y = y1 + alpha * (-rx * Math.sin(startAngle) * sinPhi + ry * Math.cos(startAngle) * cosPhi);
  var cp2x = x2 - alpha * (-rx * Math.sin(endAngle) * cosPhi - ry * Math.cos(endAngle) * sinPhi);
  var cp2y = y2 - alpha * (-rx * Math.sin(endAngle) * sinPhi + ry * Math.cos(endAngle) * cosPhi);
  return [cp1x, cp1y, cp2x, cp2y, x2, y2];
}
function drawPath(ctx, attrs, styles2) {
  var paths = [];
  paths = paths.concat(attrs);
  var _a = styles2.lineWidth, lineWidth = _a === void 0 ? 1 : _a, _b = styles2.color, color = _b === void 0 ? "currentColor" : _b;
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = color;
  ctx.setLineDash([]);
  paths.forEach(function(_a2) {
    var x = _a2.x, y = _a2.y, path2 = _a2.path;
    var commands = path2.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);
    if (isValid(commands)) {
      var offsetX_1 = x;
      var offsetY_1 = y;
      ctx.beginPath();
      commands.forEach(function(command) {
        var currentX = 0;
        var currentY = 0;
        var startX = 0;
        var startY = 0;
        var type = command[0];
        var args = command.slice(1).trim().split(/[\s,]+/).map(Number);
        switch (type) {
          case "M":
            currentX = args[0] + offsetX_1;
            currentY = args[1] + offsetY_1;
            ctx.moveTo(currentX, currentY);
            startX = currentX;
            startY = currentY;
            break;
          case "m":
            currentX += args[0];
            currentY += args[1];
            ctx.moveTo(currentX, currentY);
            startX = currentX;
            startY = currentY;
            break;
          case "L":
            currentX = args[0] + offsetX_1;
            currentY = args[1] + offsetY_1;
            ctx.lineTo(currentX, currentY);
            break;
          case "l":
            currentX += args[0];
            currentY += args[1];
            ctx.lineTo(currentX, currentY);
            break;
          case "H":
            currentX = args[0] + offsetX_1;
            ctx.lineTo(currentX, currentY);
            break;
          case "h":
            currentX += args[0];
            ctx.lineTo(currentX, currentY);
            break;
          case "V":
            currentY = args[0] + offsetY_1;
            ctx.lineTo(currentX, currentY);
            break;
          case "v":
            currentY += args[0];
            ctx.lineTo(currentX, currentY);
            break;
          case "C":
            ctx.bezierCurveTo(args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1, args[4] + offsetX_1, args[5] + offsetY_1);
            currentX = args[4] + offsetX_1;
            currentY = args[5] + offsetY_1;
            break;
          case "c":
            ctx.bezierCurveTo(currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3], currentX + args[4], currentY + args[5]);
            currentX += args[4];
            currentY += args[5];
            break;
          case "S":
            ctx.bezierCurveTo(currentX, currentY, args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1);
            currentX = args[2] + offsetX_1;
            currentY = args[3] + offsetY_1;
            break;
          case "s":
            ctx.bezierCurveTo(currentX, currentY, currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3]);
            currentX += args[2];
            currentY += args[3];
            break;
          case "Q":
            ctx.quadraticCurveTo(args[0] + offsetX_1, args[1] + offsetY_1, args[2] + offsetX_1, args[3] + offsetY_1);
            currentX = args[2] + offsetX_1;
            currentY = args[3] + offsetY_1;
            break;
          case "q":
            ctx.quadraticCurveTo(currentX + args[0], currentY + args[1], currentX + args[2], currentY + args[3]);
            currentX += args[2];
            currentY += args[3];
            break;
          case "T":
            ctx.quadraticCurveTo(currentX, currentY, args[0] + offsetX_1, args[1] + offsetY_1);
            currentX = args[0] + offsetX_1;
            currentY = args[1] + offsetY_1;
            break;
          case "t":
            ctx.quadraticCurveTo(currentX, currentY, currentX + args[0], currentY + args[1]);
            currentX += args[0];
            currentY += args[1];
            break;
          case "A":
            drawEllipticalArc(ctx, currentX, currentY, args, offsetX_1, offsetY_1, false);
            currentX = args[5] + offsetX_1;
            currentY = args[6] + offsetY_1;
            break;
          case "a":
            drawEllipticalArc(ctx, currentX, currentY, args, offsetX_1, offsetY_1, true);
            currentX += args[5];
            currentY += args[6];
            break;
          case "Z":
          case "z":
            ctx.closePath();
            currentX = startX;
            currentY = startY;
            break;
        }
      });
      if (styles2.style === "fill") {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
  });
}
var path = {
  name: "path",
  checkEventOn: checkCoordinateOnRect,
  draw: function(ctx, attrs, styles2) {
    drawPath(ctx, attrs, styles2);
  }
};
var figures = {};
var extensions = [circle, line, polygon, rect, text, arc, path];
extensions.forEach(function(figure) {
  figures[figure.name] = FigureImp.extend(figure);
});
function getSupportedFigures() {
  return Object.keys(figures);
}
function registerFigure(figure) {
  figures[figure.name] = FigureImp.extend(figure);
}
function getInnerFigureClass(name) {
  var _a;
  return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;
}
function getFigureClass(name) {
  var _a;
  return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;
}
var View = (
  /** @class */
  function(_super) {
    __extends(View2, _super);
    function View2(widget) {
      var _this = _super.call(this) || this;
      _this._widget = widget;
      return _this;
    }
    View2.prototype.getWidget = function() {
      return this._widget;
    };
    View2.prototype.createFigure = function(create, eventHandler) {
      var FigureClazz = getInnerFigureClass(create.name);
      if (FigureClazz !== null) {
        var figure = new FigureClazz(create);
        if (isValid(eventHandler)) {
          for (var key in eventHandler) {
            if (eventHandler.hasOwnProperty(key)) {
              figure.registerEvent(key, eventHandler[key]);
            }
          }
          this.addChild(figure);
        }
        return figure;
      }
      return null;
    };
    View2.prototype.draw = function(ctx) {
      var extend = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        extend[_i - 1] = arguments[_i];
      }
      this.clear();
      this.drawImp(ctx, extend);
    };
    View2.prototype.checkEventOn = function(_) {
      return true;
    };
    return View2;
  }(Eventful)
);
var GridView = (
  /** @class */
  function(_super) {
    __extends(GridView2, _super);
    function GridView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GridView2.prototype.drawImp = function(ctx) {
      var _a, _b;
      var widget = this.getWidget();
      var pane = this.getWidget().getPane();
      var chart = pane.getChart();
      var bounding = widget.getBounding();
      var styles2 = chart.getStyles().grid;
      var show = styles2.show;
      if (show) {
        ctx.save();
        ctx.globalCompositeOperation = "destination-over";
        var horizontalStyles = styles2.horizontal;
        var horizontalShow = horizontalStyles.show;
        if (horizontalShow) {
          var yAxis = pane.getAxisComponent();
          var attrs = yAxis.getTicks().map(function(tick) {
            return {
              coordinates: [
                { x: 0, y: tick.coord },
                { x: bounding.width, y: tick.coord }
              ]
            };
          });
          (_a = this.createFigure({
            name: "line",
            attrs,
            styles: horizontalStyles
          })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        }
        var verticalStyles = styles2.vertical;
        var verticalShow = verticalStyles.show;
        if (verticalShow) {
          var xAxis = chart.getXAxisPane().getAxisComponent();
          var attrs = xAxis.getTicks().map(function(tick) {
            return {
              coordinates: [
                { x: tick.coord, y: 0 },
                { x: tick.coord, y: bounding.height }
              ]
            };
          });
          (_b = this.createFigure({
            name: "line",
            attrs,
            styles: verticalStyles
          })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        ctx.restore();
      }
    };
    return GridView2;
  }(View)
);
var ChildrenView = (
  /** @class */
  function(_super) {
    __extends(ChildrenView2, _super);
    function ChildrenView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ChildrenView2.prototype.eachChildren = function(childCallback) {
      var pane = this.getWidget().getPane();
      var chartStore = pane.getChart().getChartStore();
      var visibleRangeDataList = chartStore.getVisibleRangeDataList();
      var barSpace = chartStore.getBarSpace();
      var dataLength = visibleRangeDataList.length;
      var index = 0;
      while (index < dataLength) {
        childCallback(visibleRangeDataList[index], barSpace, index);
        ++index;
      }
    };
    return ChildrenView2;
  }(View)
);
var CandleBarView = (
  /** @class */
  function(_super) {
    __extends(CandleBarView2, _super);
    function CandleBarView2() {
      var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this._boundCandleBarClickEvent = function(data) {
        return function() {
          _this.getWidget().getPane().getChart().getChartStore().executeAction("onCandleBarClick", data);
          return false;
        };
      };
      return _this;
    }
    CandleBarView2.prototype.drawImp = function(ctx) {
      var _this = this;
      var pane = this.getWidget().getPane();
      var isMain = pane.getId() === PaneIdConstants.CANDLE;
      var chartStore = pane.getChart().getChartStore();
      var candleBarOptions = this.getCandleBarOptions();
      if (candleBarOptions !== null) {
        var type_1 = candleBarOptions.type, styles_1 = candleBarOptions.styles;
        var ohlcSize_1 = 0;
        var halfOhlcSize_1 = 0;
        if (candleBarOptions.type === "ohlc") {
          var gapBar = chartStore.getBarSpace().gapBar;
          ohlcSize_1 = Math.min(Math.max(Math.round(gapBar * 0.2), 1), 8);
          if (ohlcSize_1 > 2 && ohlcSize_1 % 2 === 1) {
            ohlcSize_1--;
          }
          halfOhlcSize_1 = Math.floor(ohlcSize_1 / 2);
        }
        var yAxis_1 = pane.getAxisComponent();
        this.eachChildren(function(visibleData, barSpace) {
          var _a;
          var x = visibleData.x, _b = visibleData.data, current = _b.current, prev = _b.prev;
          if (isValid(current)) {
            var open_1 = current.open, high = current.high, low = current.low, close_1 = current.close;
            var comparePrice = styles_1.compareRule === "current_open" ? open_1 : (_a = prev === null || prev === void 0 ? void 0 : prev.close) !== null && _a !== void 0 ? _a : close_1;
            var colors = [];
            if (close_1 > comparePrice) {
              colors[0] = styles_1.upColor;
              colors[1] = styles_1.upBorderColor;
              colors[2] = styles_1.upWickColor;
            } else if (close_1 < comparePrice) {
              colors[0] = styles_1.downColor;
              colors[1] = styles_1.downBorderColor;
              colors[2] = styles_1.downWickColor;
            } else {
              colors[0] = styles_1.noChangeColor;
              colors[1] = styles_1.noChangeBorderColor;
              colors[2] = styles_1.noChangeWickColor;
            }
            var openY = yAxis_1.convertToPixel(open_1);
            var closeY = yAxis_1.convertToPixel(close_1);
            var priceY = [
              openY,
              closeY,
              yAxis_1.convertToPixel(high),
              yAxis_1.convertToPixel(low)
            ];
            priceY.sort(function(a, b) {
              return a - b;
            });
            var correction = barSpace.gapBar % 2 === 0 ? 1 : 0;
            var rects = [];
            switch (type_1) {
              case "candle_solid": {
                rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);
                break;
              }
              case "candle_stroke": {
                rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);
                break;
              }
              case "candle_up_stroke": {
                if (close_1 > open_1) {
                  rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);
                } else {
                  rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);
                }
                break;
              }
              case "candle_down_stroke": {
                if (open_1 > close_1) {
                  rects = _this._createStrokeBar(x, priceY, barSpace, colors, correction);
                } else {
                  rects = _this._createSolidBar(x, priceY, barSpace, colors, correction);
                }
                break;
              }
              case "ohlc": {
                rects = [
                  {
                    name: "rect",
                    attrs: [
                      {
                        x: x - halfOhlcSize_1,
                        y: priceY[0],
                        width: ohlcSize_1,
                        height: priceY[3] - priceY[0]
                      },
                      {
                        x: x - barSpace.halfGapBar,
                        y: openY + ohlcSize_1 > priceY[3] ? priceY[3] - ohlcSize_1 : openY,
                        width: barSpace.halfGapBar - halfOhlcSize_1,
                        height: ohlcSize_1
                      },
                      {
                        x: x + halfOhlcSize_1,
                        y: closeY + ohlcSize_1 > priceY[3] ? priceY[3] - ohlcSize_1 : closeY,
                        width: barSpace.halfGapBar - halfOhlcSize_1,
                        height: ohlcSize_1
                      }
                    ],
                    styles: { color: colors[0] }
                  }
                ];
                break;
              }
            }
            rects.forEach(function(rect2) {
              var _a2;
              var handler = null;
              if (isMain) {
                handler = {
                  mouseClickEvent: _this._boundCandleBarClickEvent(visibleData)
                };
              }
              (_a2 = _this.createFigure(rect2, handler !== null && handler !== void 0 ? handler : void 0)) === null || _a2 === void 0 ? void 0 : _a2.draw(ctx);
            });
          }
        });
      }
    };
    CandleBarView2.prototype.getCandleBarOptions = function() {
      var candleStyles = this.getWidget().getPane().getChart().getStyles().candle;
      return {
        type: candleStyles.type,
        styles: candleStyles.bar
      };
    };
    CandleBarView2.prototype._createSolidBar = function(x, priceY, barSpace, colors, correction) {
      return [
        {
          name: "rect",
          attrs: {
            x,
            y: priceY[0],
            width: 1,
            height: priceY[3] - priceY[0]
          },
          styles: { color: colors[2] }
        },
        {
          name: "rect",
          attrs: {
            x: x - barSpace.halfGapBar,
            y: priceY[1],
            width: barSpace.gapBar + correction,
            height: Math.max(1, priceY[2] - priceY[1])
          },
          styles: {
            style: "stroke_fill",
            color: colors[0],
            borderColor: colors[1]
          }
        }
      ];
    };
    CandleBarView2.prototype._createStrokeBar = function(x, priceY, barSpace, colors, correction) {
      return [
        {
          name: "rect",
          attrs: [
            {
              x,
              y: priceY[0],
              width: 1,
              height: priceY[1] - priceY[0]
            },
            {
              x,
              y: priceY[2],
              width: 1,
              height: priceY[3] - priceY[2]
            }
          ],
          styles: { color: colors[2] }
        },
        {
          name: "rect",
          attrs: {
            x: x - barSpace.halfGapBar,
            y: priceY[1],
            width: barSpace.gapBar + correction,
            height: Math.max(1, priceY[2] - priceY[1])
          },
          styles: {
            style: "stroke",
            borderColor: colors[1]
          }
        }
      ];
    };
    return CandleBarView2;
  }(ChildrenView)
);
var IndicatorView = (
  /** @class */
  function(_super) {
    __extends(IndicatorView2, _super);
    function IndicatorView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IndicatorView2.prototype.getCandleBarOptions = function() {
      var e_1, _a;
      var pane = this.getWidget().getPane();
      var yAxis = pane.getAxisComponent();
      if (!yAxis.isInCandle()) {
        var chartStore = pane.getChart().getChartStore();
        var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
        try {
          for (var indicators_1 = __values(indicators2), indicators_1_1 = indicators_1.next(); !indicators_1_1.done; indicators_1_1 = indicators_1.next()) {
            var indicator = indicators_1_1.value;
            if (indicator.shouldOhlc && indicator.visible) {
              var indicatorStyles = indicator.styles;
              var defaultStyles = chartStore.getStyles().indicator;
              var compareRule = formatValue(indicatorStyles, "ohlc.compareRule", defaultStyles.ohlc.compareRule);
              var upColor = formatValue(indicatorStyles, "ohlc.upColor", defaultStyles.ohlc.upColor);
              var downColor = formatValue(indicatorStyles, "ohlc.downColor", defaultStyles.ohlc.downColor);
              var noChangeColor = formatValue(indicatorStyles, "ohlc.noChangeColor", defaultStyles.ohlc.noChangeColor);
              return {
                type: "ohlc",
                styles: {
                  compareRule,
                  upColor,
                  downColor,
                  noChangeColor,
                  upBorderColor: upColor,
                  downBorderColor: downColor,
                  noChangeBorderColor: noChangeColor,
                  upWickColor: upColor,
                  downWickColor: downColor,
                  noChangeWickColor: noChangeColor
                }
              };
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (indicators_1_1 && !indicators_1_1.done && (_a = indicators_1.return)) _a.call(indicators_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
      return null;
    };
    IndicatorView2.prototype.drawImp = function(ctx) {
      var _this = this;
      _super.prototype.drawImp.call(this, ctx);
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chart = pane.getChart();
      var bounding = widget.getBounding();
      var xAxis = chart.getXAxisPane().getAxisComponent();
      var yAxis = pane.getAxisComponent();
      var chartStore = chart.getChartStore();
      var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
      var defaultStyles = chartStore.getStyles().indicator;
      ctx.save();
      indicators2.forEach(function(indicator) {
        if (indicator.visible) {
          if (indicator.zLevel < 0) {
            ctx.globalCompositeOperation = "destination-over";
          } else {
            ctx.globalCompositeOperation = "source-over";
          }
          var isCover = false;
          if (indicator.draw !== null) {
            ctx.save();
            isCover = indicator.draw({
              ctx,
              chart,
              indicator,
              bounding,
              xAxis,
              yAxis
            });
            ctx.restore();
          }
          if (!isCover) {
            var result_1 = indicator.result;
            var lines_1 = [];
            _this.eachChildren(function(data, barSpace) {
              var _a, _b, _c;
              var halfGapBar = barSpace.halfGapBar;
              var dataIndex = data.dataIndex, x = data.x;
              var prevX = xAxis.convertToPixel(dataIndex - 1);
              var nextX = xAxis.convertToPixel(dataIndex + 1);
              var prevData = (_a = result_1[dataIndex - 1]) !== null && _a !== void 0 ? _a : null;
              var currentData = (_b = result_1[dataIndex]) !== null && _b !== void 0 ? _b : null;
              var nextData = (_c = result_1[dataIndex + 1]) !== null && _c !== void 0 ? _c : null;
              var prevCoordinate = { x: prevX };
              var currentCoordinate = { x };
              var nextCoordinate = { x: nextX };
              indicator.figures.forEach(function(_a2) {
                var key = _a2.key;
                var prevValue = prevData === null || prevData === void 0 ? void 0 : prevData[key];
                if (isNumber(prevValue)) {
                  prevCoordinate[key] = yAxis.convertToPixel(prevValue);
                }
                var currentValue = currentData === null || currentData === void 0 ? void 0 : currentData[key];
                if (isNumber(currentValue)) {
                  currentCoordinate[key] = yAxis.convertToPixel(currentValue);
                }
                var nextValue = nextData === null || nextData === void 0 ? void 0 : nextData[key];
                if (isNumber(nextValue)) {
                  nextCoordinate[key] = yAxis.convertToPixel(nextValue);
                }
              });
              eachFigures(indicator, dataIndex, defaultStyles, function(figure, figureStyles, figureIndex) {
                var _a2, _b2, _c2;
                if (isValid(currentData === null || currentData === void 0 ? void 0 : currentData[figure.key])) {
                  var valueY = currentCoordinate[figure.key];
                  var attrs = (_a2 = figure.attrs) === null || _a2 === void 0 ? void 0 : _a2.call(figure, {
                    data: { prev: prevData, current: currentData, next: nextData },
                    coordinate: { prev: prevCoordinate, current: currentCoordinate, next: nextCoordinate },
                    bounding,
                    barSpace,
                    xAxis,
                    yAxis
                  });
                  if (!isValid(attrs)) {
                    switch (figure.type) {
                      case "circle": {
                        attrs = { x, y: valueY, r: Math.max(1, halfGapBar) };
                        break;
                      }
                      case "rect":
                      case "bar": {
                        var baseValue = (_b2 = figure.baseValue) !== null && _b2 !== void 0 ? _b2 : yAxis.getRange().from;
                        var baseValueY = yAxis.convertToPixel(baseValue);
                        var height = Math.abs(baseValueY - valueY);
                        if (baseValue !== (currentData === null || currentData === void 0 ? void 0 : currentData[figure.key])) {
                          height = Math.max(1, height);
                        }
                        var y = 0;
                        if (valueY > baseValueY) {
                          y = baseValueY;
                        } else {
                          y = valueY;
                        }
                        attrs = {
                          x: x - halfGapBar,
                          y,
                          width: Math.max(1, halfGapBar * 2),
                          height
                        };
                        break;
                      }
                      case "line": {
                        if (!isValid(lines_1[figureIndex])) {
                          lines_1[figureIndex] = [];
                        }
                        if (isNumber(currentCoordinate[figure.key]) && isNumber(nextCoordinate[figure.key])) {
                          lines_1[figureIndex].push({
                            coordinates: [
                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore
                              { x: currentCoordinate.x, y: currentCoordinate[figure.key] },
                              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- ignore
                              { x: nextCoordinate.x, y: nextCoordinate[figure.key] }
                            ],
                            styles: figureStyles
                          });
                        }
                        break;
                      }
                    }
                  }
                  var type = figure.type;
                  if (isValid(attrs) && type !== "line") {
                    (_c2 = _this.createFigure({
                      name: type === "bar" ? "rect" : type,
                      attrs,
                      styles: figureStyles
                    })) === null || _c2 === void 0 ? void 0 : _c2.draw(ctx);
                  }
                }
              });
            });
            lines_1.forEach(function(items) {
              var _a, _b, _c, _d;
              if (items.length > 1) {
                var mergeLines = [
                  {
                    coordinates: [items[0].coordinates[0], items[0].coordinates[1]],
                    styles: items[0].styles
                  }
                ];
                for (var i = 1; i < items.length; i++) {
                  var lastMergeLine = mergeLines[mergeLines.length - 1];
                  var current = items[i];
                  var lastMergeLineLastCoordinate = lastMergeLine.coordinates[lastMergeLine.coordinates.length - 1];
                  if (lastMergeLineLastCoordinate.x === current.coordinates[0].x && lastMergeLineLastCoordinate.y === current.coordinates[0].y && lastMergeLine.styles.style === current.styles.style && lastMergeLine.styles.color === current.styles.color && lastMergeLine.styles.size === current.styles.size && lastMergeLine.styles.smooth === current.styles.smooth && ((_a = lastMergeLine.styles.dashedValue) === null || _a === void 0 ? void 0 : _a[0]) === ((_b = current.styles.dashedValue) === null || _b === void 0 ? void 0 : _b[0]) && ((_c = lastMergeLine.styles.dashedValue) === null || _c === void 0 ? void 0 : _c[1]) === ((_d = current.styles.dashedValue) === null || _d === void 0 ? void 0 : _d[1])) {
                    lastMergeLine.coordinates.push(current.coordinates[1]);
                  } else {
                    mergeLines.push({
                      coordinates: [current.coordinates[0], current.coordinates[1]],
                      styles: current.styles
                    });
                  }
                }
                mergeLines.forEach(function(_a2) {
                  var _b2;
                  var coordinates = _a2.coordinates, styles2 = _a2.styles;
                  (_b2 = _this.createFigure({
                    name: "line",
                    attrs: { coordinates },
                    styles: styles2
                  })) === null || _b2 === void 0 ? void 0 : _b2.draw(ctx);
                });
              }
            });
          }
        }
      });
      ctx.restore();
    };
    return IndicatorView2;
  }(CandleBarView)
);
var CrosshairLineView = (
  /** @class */
  function(_super) {
    __extends(CrosshairLineView2, _super);
    function CrosshairLineView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairLineView2.prototype.drawImp = function(ctx) {
      var widget = this.getWidget();
      var pane = widget.getPane();
      var bounding = widget.getBounding();
      var chartStore = widget.getPane().getChart().getChartStore();
      var crosshair = chartStore.getCrosshair();
      var styles2 = chartStore.getStyles().crosshair;
      if (isString(crosshair.paneId) && styles2.show) {
        if (crosshair.paneId === pane.getId()) {
          var y = crosshair.y;
          this._drawLine(ctx, [
            { x: 0, y },
            { x: bounding.width, y }
          ], styles2.horizontal);
        }
        var x = crosshair.realX;
        this._drawLine(ctx, [
          { x, y: 0 },
          { x, y: bounding.height }
        ], styles2.vertical);
      }
    };
    CrosshairLineView2.prototype._drawLine = function(ctx, coordinates, styles2) {
      var _a;
      if (styles2.show) {
        var lineStyles = styles2.line;
        if (lineStyles.show) {
          (_a = this.createFigure({
            name: "line",
            attrs: { coordinates },
            styles: lineStyles
          })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        }
      }
    };
    return CrosshairLineView2;
  }(View)
);
var IndicatorTooltipView = (
  /** @class */
  function(_super) {
    __extends(IndicatorTooltipView2, _super);
    function IndicatorTooltipView2(widget) {
      var _this = _super.call(this, widget) || this;
      _this._activeFeatureInfo = null;
      _this._featureClickEvent = function(type, featureInfo) {
        return function() {
          var pane = _this.getWidget().getPane();
          pane.getChart().getChartStore().executeAction(type, featureInfo);
          return true;
        };
      };
      _this._featureMouseMoveEvent = function(featureInfo) {
        return function() {
          _this._activeFeatureInfo = featureInfo;
          return true;
        };
      };
      _this.registerEvent("mouseMoveEvent", function(_) {
        _this._activeFeatureInfo = null;
        return false;
      });
      return _this;
    }
    IndicatorTooltipView2.prototype.drawImp = function(ctx) {
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = pane.getChart().getChartStore();
      var crosshair = chartStore.getCrosshair();
      if (isValid(crosshair.kLineData)) {
        var bounding = widget.getBounding();
        var _a = chartStore.getStyles().indicator.tooltip, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, offsetRight = _a.offsetRight;
        this.drawIndicatorTooltip(ctx, offsetLeft, offsetTop, bounding.width - offsetRight);
      }
    };
    IndicatorTooltipView2.prototype.drawIndicatorTooltip = function(ctx, left, top, maxWidth) {
      var _this = this;
      var pane = this.getWidget().getPane();
      var chartStore = pane.getChart().getChartStore();
      var styles2 = chartStore.getStyles().indicator;
      var tooltipStyles = styles2.tooltip;
      if (this.isDrawTooltip(chartStore.getCrosshair(), tooltipStyles)) {
        var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
        var tooltipTitleStyles_1 = tooltipStyles.title;
        var tooltipLegendStyles_1 = tooltipStyles.legend;
        indicators2.forEach(function(indicator) {
          var prevRowHeight = 0;
          var coordinate = { x: left, y: top };
          var _a = _this.getIndicatorTooltipData(indicator), name = _a.name, calcParamsText = _a.calcParamsText, legends = _a.legends, featuresStyles = _a.features;
          var nameValid = name.length > 0;
          var legendValid = legends.length > 0;
          if (nameValid || legendValid) {
            var features = _this.classifyTooltipFeatures(featuresStyles);
            prevRowHeight = _this.drawStandardTooltipFeatures(ctx, features[0], coordinate, indicator, left, prevRowHeight, maxWidth);
            if (nameValid) {
              var text2 = name;
              if (calcParamsText.length > 0) {
                text2 = "".concat(text2).concat(calcParamsText);
              }
              var color = tooltipTitleStyles_1.color;
              prevRowHeight = _this.drawStandardTooltipLegends(ctx, [
                {
                  title: { text: "", color },
                  value: { text: text2, color }
                }
              ], coordinate, left, prevRowHeight, maxWidth, tooltipTitleStyles_1);
            }
            prevRowHeight = _this.drawStandardTooltipFeatures(ctx, features[1], coordinate, indicator, left, prevRowHeight, maxWidth);
            if (legendValid) {
              prevRowHeight = _this.drawStandardTooltipLegends(ctx, legends, coordinate, left, prevRowHeight, maxWidth, tooltipLegendStyles_1);
            }
            prevRowHeight = _this.drawStandardTooltipFeatures(ctx, features[2], coordinate, indicator, left, prevRowHeight, maxWidth);
            top = coordinate.y + prevRowHeight;
          }
        });
      }
      return top;
    };
    IndicatorTooltipView2.prototype.drawStandardTooltipFeatures = function(ctx, features, coordinate, indicator, left, prevRowHeight, maxWidth) {
      var _this = this;
      if (features.length > 0) {
        var width_1 = 0;
        var height_1 = 0;
        features.forEach(function(feature) {
          var _a = feature.marginLeft, marginLeft = _a === void 0 ? 0 : _a, _b = feature.marginTop, marginTop = _b === void 0 ? 0 : _b, _c = feature.marginRight, marginRight = _c === void 0 ? 0 : _c, _d = feature.marginBottom, marginBottom = _d === void 0 ? 0 : _d, _e = feature.paddingLeft, paddingLeft = _e === void 0 ? 0 : _e, _f = feature.paddingTop, paddingTop = _f === void 0 ? 0 : _f, _g = feature.paddingRight, paddingRight = _g === void 0 ? 0 : _g, _h = feature.paddingBottom, paddingBottom = _h === void 0 ? 0 : _h, _j = feature.size, size = _j === void 0 ? 0 : _j, type = feature.type, content = feature.content;
          var contentWidth = 0;
          if (type === "icon_font") {
            var iconFont = content;
            ctx.font = createFont(size, "normal", iconFont.family);
            contentWidth = ctx.measureText(iconFont.code).width;
          } else {
            contentWidth = size;
          }
          width_1 += marginLeft + paddingLeft + contentWidth + paddingRight + marginRight;
          height_1 = Math.max(height_1, marginTop + paddingTop + size + paddingBottom + marginBottom);
        });
        if (coordinate.x + width_1 > maxWidth) {
          coordinate.x = left;
          coordinate.y += prevRowHeight;
          prevRowHeight = height_1;
        } else {
          prevRowHeight = Math.max(prevRowHeight, height_1);
        }
        var pane = this.getWidget().getPane();
        var paneId_1 = pane.getId();
        features.forEach(function(feature) {
          var _a, _b, _c, _d, _e;
          var _f = feature.marginLeft, marginLeft = _f === void 0 ? 0 : _f, _g = feature.marginTop, marginTop = _g === void 0 ? 0 : _g, _h = feature.marginRight, marginRight = _h === void 0 ? 0 : _h, _j = feature.paddingLeft, paddingLeft = _j === void 0 ? 0 : _j, _k = feature.paddingTop, paddingTop = _k === void 0 ? 0 : _k, _l = feature.paddingRight, paddingRight = _l === void 0 ? 0 : _l, _m = feature.paddingBottom, paddingBottom = _m === void 0 ? 0 : _m, backgroundColor = feature.backgroundColor, activeBackgroundColor = feature.activeBackgroundColor, borderRadius = feature.borderRadius, _o = feature.size, size = _o === void 0 ? 0 : _o, color = feature.color, activeColor = feature.activeColor, type = feature.type, content = feature.content;
          var finalColor = color;
          var finalBackgroundColor = backgroundColor;
          if (((_a = _this._activeFeatureInfo) === null || _a === void 0 ? void 0 : _a.paneId) === paneId_1 && ((_b = _this._activeFeatureInfo.indicator) === null || _b === void 0 ? void 0 : _b.id) === (indicator === null || indicator === void 0 ? void 0 : indicator.id) && _this._activeFeatureInfo.feature.id === feature.id) {
            finalColor = activeColor !== null && activeColor !== void 0 ? activeColor : color;
            finalBackgroundColor = activeBackgroundColor !== null && activeBackgroundColor !== void 0 ? activeBackgroundColor : backgroundColor;
          }
          var actionType = "onCandleTooltipFeatureClick";
          var featureInfo = {
            paneId: paneId_1,
            feature
          };
          if (isValid(indicator)) {
            actionType = "onIndicatorTooltipFeatureClick";
            featureInfo.indicator = indicator;
          }
          var eventHandler = {
            mouseDownEvent: _this._featureClickEvent(actionType, featureInfo),
            mouseMoveEvent: _this._featureMouseMoveEvent(featureInfo)
          };
          var contentWidth = 0;
          if (type === "icon_font") {
            var iconFont = content;
            (_c = _this.createFigure({
              name: "text",
              attrs: { text: iconFont.code, x: coordinate.x + marginLeft, y: coordinate.y + marginTop },
              styles: {
                paddingLeft,
                paddingTop,
                paddingRight,
                paddingBottom,
                borderRadius,
                size,
                family: iconFont.family,
                color: finalColor,
                backgroundColor: finalBackgroundColor
              }
            }, eventHandler)) === null || _c === void 0 ? void 0 : _c.draw(ctx);
            contentWidth = ctx.measureText(iconFont.code).width;
          } else {
            (_d = _this.createFigure({
              name: "rect",
              attrs: { x: coordinate.x + marginLeft, y: coordinate.y + marginTop, width: size, height: size },
              styles: {
                paddingLeft,
                paddingTop,
                paddingRight,
                paddingBottom,
                color: finalBackgroundColor
              }
            }, eventHandler)) === null || _d === void 0 ? void 0 : _d.draw(ctx);
            var path2 = content;
            (_e = _this.createFigure({
              name: "path",
              attrs: { path: path2.path, x: coordinate.x + marginLeft + paddingLeft, y: coordinate.y + marginTop + paddingTop, width: size, height: size },
              styles: {
                style: path2.style,
                lineWidth: path2.lineWidth,
                color: finalColor
              }
            })) === null || _e === void 0 ? void 0 : _e.draw(ctx);
            contentWidth = size;
          }
          coordinate.x += marginLeft + paddingLeft + contentWidth + paddingRight + marginRight;
        });
      }
      return prevRowHeight;
    };
    IndicatorTooltipView2.prototype.drawStandardTooltipLegends = function(ctx, legends, coordinate, left, prevRowHeight, maxWidth, styles2) {
      var _this = this;
      if (legends.length > 0) {
        var marginLeft_1 = styles2.marginLeft, marginTop_1 = styles2.marginTop, marginRight_1 = styles2.marginRight, marginBottom_1 = styles2.marginBottom, size_1 = styles2.size, family_1 = styles2.family, weight_1 = styles2.weight;
        ctx.font = createFont(size_1, weight_1, family_1);
        legends.forEach(function(data) {
          var _a, _b;
          var title = data.title;
          var value = data.value;
          var titleTextWidth = ctx.measureText(title.text).width;
          var valueTextWidth = ctx.measureText(value.text).width;
          var totalTextWidth = titleTextWidth + valueTextWidth;
          var h = marginTop_1 + size_1 + marginBottom_1;
          if (coordinate.x + marginLeft_1 + totalTextWidth + marginRight_1 > maxWidth) {
            coordinate.x = left;
            coordinate.y += prevRowHeight;
            prevRowHeight = h;
          } else {
            prevRowHeight = Math.max(prevRowHeight, h);
          }
          if (title.text.length > 0) {
            (_a = _this.createFigure({
              name: "text",
              attrs: { x: coordinate.x + marginLeft_1, y: coordinate.y + marginTop_1, text: title.text },
              styles: { color: title.color, size: size_1, family: family_1, weight: weight_1 }
            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
          }
          (_b = _this.createFigure({
            name: "text",
            attrs: { x: coordinate.x + marginLeft_1 + titleTextWidth, y: coordinate.y + marginTop_1, text: value.text },
            styles: { color: value.color, size: size_1, family: family_1, weight: weight_1 }
          })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
          coordinate.x += marginLeft_1 + totalTextWidth + marginRight_1;
        });
      }
      return prevRowHeight;
    };
    IndicatorTooltipView2.prototype.isDrawTooltip = function(crosshair, styles2) {
      var showRule = styles2.showRule;
      return showRule === "always" || showRule === "follow_cross" && isString(crosshair.paneId);
    };
    IndicatorTooltipView2.prototype.getIndicatorTooltipData = function(indicator) {
      var _a;
      var chartStore = this.getWidget().getPane().getChart().getChartStore();
      var styles2 = chartStore.getStyles().indicator;
      var tooltipStyles = styles2.tooltip;
      var tooltipTitleStyles = tooltipStyles.title;
      var name = "";
      var calcParamsText = "";
      if (tooltipTitleStyles.show) {
        if (tooltipTitleStyles.showName) {
          name = indicator.shortName;
        }
        if (tooltipTitleStyles.showParams) {
          var calcParams = indicator.calcParams;
          if (calcParams.length > 0) {
            calcParamsText = "(".concat(calcParams.join(","), ")");
          }
        }
      }
      var tooltipData = { name, calcParamsText, legends: [], features: tooltipStyles.features };
      var dataIndex = chartStore.getCrosshair().dataIndex;
      var result = indicator.result;
      var formatter = chartStore.getInnerFormatter();
      var decimalFold = chartStore.getDecimalFold();
      var thousandsSeparator = chartStore.getThousandsSeparator();
      var legends = [];
      if (indicator.visible) {
        var data_1 = (_a = result[dataIndex]) !== null && _a !== void 0 ? _a : {};
        var defaultValue_1 = tooltipStyles.legend.defaultValue;
        eachFigures(indicator, dataIndex, styles2, function(figure, figureStyles) {
          if (isString(figure.title)) {
            var color = figureStyles.color;
            var value = data_1[figure.key];
            if (isNumber(value)) {
              value = formatPrecision(value, indicator.precision);
              if (indicator.shouldFormatBigNumber) {
                value = formatter.formatBigNumber(value);
              }
              value = decimalFold.format(thousandsSeparator.format(value));
            }
            legends.push({ title: { text: figure.title, color }, value: { text: value !== null && value !== void 0 ? value : defaultValue_1, color } });
          }
        });
        tooltipData.legends = legends;
      }
      if (isFunction(indicator.createTooltipDataSource)) {
        var widget = this.getWidget();
        var pane = widget.getPane();
        var chart = pane.getChart();
        var _b = indicator.createTooltipDataSource({
          chart,
          indicator,
          crosshair: chartStore.getCrosshair(),
          bounding: widget.getBounding(),
          xAxis: pane.getChart().getXAxisPane().getAxisComponent(),
          yAxis: pane.getAxisComponent()
        }), customName = _b.name, customCalcParamsText = _b.calcParamsText, customLegends = _b.legends, customFeatures = _b.features;
        if (tooltipTitleStyles.show) {
          if (isString(customName) && tooltipTitleStyles.showName) {
            tooltipData.name = customName;
          }
          if (isString(customCalcParamsText) && tooltipTitleStyles.showParams) {
            tooltipData.calcParamsText = customCalcParamsText;
          }
        }
        if (isValid(customFeatures)) {
          tooltipData.features = customFeatures;
        }
        if (isValid(customLegends) && indicator.visible) {
          var optimizedLegends_1 = [];
          var color_1 = styles2.tooltip.legend.color;
          customLegends.forEach(function(data) {
            var title = { text: "", color: color_1 };
            if (isObject(data.title)) {
              title = data.title;
            } else {
              title.text = data.title;
            }
            var value = { text: "", color: color_1 };
            if (isObject(data.value)) {
              value = data.value;
            } else {
              value.text = data.value;
            }
            if (isNumber(Number(value.text))) {
              value.text = decimalFold.format(thousandsSeparator.format(value.text));
            }
            optimizedLegends_1.push({ title, value });
          });
          tooltipData.legends = optimizedLegends_1;
        }
      }
      return tooltipData;
    };
    IndicatorTooltipView2.prototype.classifyTooltipFeatures = function(features) {
      var leftFeatures = [];
      var middleFeatures = [];
      var rightFeatures = [];
      features.forEach(function(feature) {
        switch (feature.position) {
          case "left": {
            leftFeatures.push(feature);
            break;
          }
          case "middle": {
            middleFeatures.push(feature);
            break;
          }
          case "right": {
            rightFeatures.push(feature);
            break;
          }
        }
      });
      return [leftFeatures, middleFeatures, rightFeatures];
    };
    return IndicatorTooltipView2;
  }(View)
);
var OverlayView = (
  /** @class */
  function(_super) {
    __extends(OverlayView2, _super);
    function OverlayView2(widget) {
      var _this = _super.call(this, widget) || this;
      _this._initEvent();
      return _this;
    }
    OverlayView2.prototype._initEvent = function() {
      var _this = this;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var paneId = pane.getId();
      var chart = pane.getChart();
      var chartStore = chart.getChartStore();
      this.registerEvent("mouseMoveEvent", function(event) {
        var _a;
        var progressOverlayInfo = chartStore.getProgressOverlayInfo();
        if (progressOverlayInfo !== null) {
          var overlay = progressOverlayInfo.overlay;
          var progressOverlayPaneId = progressOverlayInfo.paneId;
          if (overlay.isStart()) {
            chartStore.updateProgressOverlayInfo(paneId);
            progressOverlayPaneId = paneId;
          }
          var index = overlay.points.length - 1;
          if (overlay.isDrawing() && progressOverlayPaneId === paneId) {
            overlay.eventMoveForDrawing(_this._coordinateToPoint(overlay, event));
            (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart, overlay }, event));
          }
          return _this._figureMouseMoveEvent(overlay, "point", index, { key: "".concat(OVERLAY_FIGURE_KEY_PREFIX, "point_").concat(index), type: "circle", attrs: {} })(event);
        }
        chartStore.setHoverOverlayInfo({
          paneId,
          overlay: null,
          figureType: "none",
          figureIndex: -1,
          figure: null
        }, function(o, f) {
          return _this._processOverlayMouseEnterEvent(o, f, event);
        }, function(o, f) {
          return _this._processOverlayMouseLeaveEvent(o, f, event);
        });
        widget.setForceCursor(null);
        return false;
      }).registerEvent("mouseClickEvent", function(event) {
        var _a, _b;
        var progressOverlayInfo = chartStore.getProgressOverlayInfo();
        if (progressOverlayInfo !== null) {
          var overlay = progressOverlayInfo.overlay;
          var progressOverlayPaneId = progressOverlayInfo.paneId;
          if (overlay.isStart()) {
            chartStore.updateProgressOverlayInfo(paneId, true);
            progressOverlayPaneId = paneId;
          }
          var index = overlay.points.length - 1;
          if (overlay.isDrawing() && progressOverlayPaneId === paneId) {
            overlay.eventMoveForDrawing(_this._coordinateToPoint(overlay, event));
            (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart, overlay }, event));
            overlay.nextStep();
            if (!overlay.isDrawing()) {
              chartStore.progressOverlayComplete();
              (_b = overlay.onDrawEnd) === null || _b === void 0 ? void 0 : _b.call(overlay, __assign({ chart, overlay }, event));
            }
          }
          return _this._figureMouseClickEvent(overlay, "point", index, {
            key: "".concat(OVERLAY_FIGURE_KEY_PREFIX, "point_").concat(index),
            type: "circle",
            attrs: {}
          })(event);
        }
        chartStore.setClickOverlayInfo({
          paneId,
          overlay: null,
          figureType: "none",
          figureIndex: -1,
          figure: null
        }, function(o, f) {
          return _this._processOverlaySelectedEvent(o, f, event);
        }, function(o, f) {
          return _this._processOverlayDeselectedEvent(o, f, event);
        });
        return false;
      }).registerEvent("mouseDoubleClickEvent", function(event) {
        var _a;
        var progressOverlayInfo = chartStore.getProgressOverlayInfo();
        if (progressOverlayInfo !== null) {
          var overlay = progressOverlayInfo.overlay;
          var progressOverlayPaneId = progressOverlayInfo.paneId;
          if (overlay.isDrawing() && progressOverlayPaneId === paneId) {
            overlay.forceComplete();
            if (!overlay.isDrawing()) {
              chartStore.progressOverlayComplete();
              (_a = overlay.onDrawEnd) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart, overlay }, event));
            }
          }
          var index = overlay.points.length - 1;
          return _this._figureMouseClickEvent(overlay, "point", index, {
            key: "".concat(OVERLAY_FIGURE_KEY_PREFIX, "point_").concat(index),
            type: "circle",
            attrs: {}
          })(event);
        }
        return false;
      }).registerEvent("mouseRightClickEvent", function(event) {
        var progressOverlayInfo = chartStore.getProgressOverlayInfo();
        if (progressOverlayInfo !== null) {
          var overlay = progressOverlayInfo.overlay;
          if (overlay.isDrawing()) {
            var index = overlay.points.length - 1;
            return _this._figureMouseRightClickEvent(overlay, "point", index, {
              key: "".concat(OVERLAY_FIGURE_KEY_PREFIX, "point_").concat(index),
              type: "circle",
              attrs: {}
            })(event);
          }
        }
        return false;
      }).registerEvent("mouseUpEvent", function(event) {
        var _a;
        var _b = chartStore.getPressedOverlayInfo(), overlay = _b.overlay, figure = _b.figure;
        if (overlay !== null) {
          if (checkOverlayFigureEvent("onPressedMoveEnd", figure)) {
            (_a = overlay.onPressedMoveEnd) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart, overlay, figure: figure !== null && figure !== void 0 ? figure : void 0 }, event));
          }
        }
        chartStore.setPressedOverlayInfo({
          paneId,
          overlay: null,
          figureType: "none",
          figureIndex: -1,
          figure: null
        });
        return false;
      }).registerEvent("pressedMouseMoveEvent", function(event) {
        var _a;
        var _b = chartStore.getPressedOverlayInfo(), overlay = _b.overlay, figureType = _b.figureType, figureIndex = _b.figureIndex, figure = _b.figure;
        if (overlay !== null) {
          if (checkOverlayFigureEvent("onPressedMoving", figure)) {
            if (!overlay.lock) {
              var point = _this._coordinateToPoint(overlay, event);
              if (figureType === "point") {
                overlay.eventPressedPointMove(point, figureIndex);
              } else {
                overlay.eventPressedOtherMove(point, _this.getWidget().getPane().getChart().getChartStore());
              }
              var prevented_1 = false;
              (_a = overlay.onPressedMoving) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign(__assign({ chart, overlay, figure: figure !== null && figure !== void 0 ? figure : void 0 }, event), { preventDefault: function() {
                prevented_1 = true;
              } }));
              if (prevented_1) {
                _this.getWidget().setForceCursor(null);
              } else {
                _this.getWidget().setForceCursor("pointer");
              }
            }
            return true;
          }
        }
        _this.getWidget().setForceCursor(null);
        return false;
      });
    };
    OverlayView2.prototype._createFigureEvents = function(overlay, figureType, figureIndex, figure) {
      if (overlay.isDrawing()) {
        return null;
      }
      return {
        mouseMoveEvent: this._figureMouseMoveEvent(overlay, figureType, figureIndex, figure),
        mouseDownEvent: this._figureMouseDownEvent(overlay, figureType, figureIndex, figure),
        mouseClickEvent: this._figureMouseClickEvent(overlay, figureType, figureIndex, figure),
        mouseRightClickEvent: this._figureMouseRightClickEvent(overlay, figureType, figureIndex, figure),
        mouseDoubleClickEvent: this._figureMouseDoubleClickEvent(overlay, figureType, figureIndex, figure)
      };
    };
    OverlayView2.prototype._processOverlayMouseEnterEvent = function(overlay, figure, event) {
      if (isFunction(overlay.onMouseEnter) && checkOverlayFigureEvent("onMouseEnter", figure)) {
        overlay.onMouseEnter(__assign({ chart: this.getWidget().getPane().getChart(), overlay, figure: figure !== null && figure !== void 0 ? figure : void 0 }, event));
        return true;
      }
      return false;
    };
    OverlayView2.prototype._processOverlayMouseLeaveEvent = function(overlay, figure, event) {
      if (isFunction(overlay.onMouseLeave) && checkOverlayFigureEvent("onMouseLeave", figure)) {
        overlay.onMouseLeave(__assign({ chart: this.getWidget().getPane().getChart(), overlay, figure: figure !== null && figure !== void 0 ? figure : void 0 }, event));
        return true;
      }
      return false;
    };
    OverlayView2.prototype._processOverlaySelectedEvent = function(overlay, figure, event) {
      var _a;
      if (checkOverlayFigureEvent("onSelected", figure)) {
        (_a = overlay.onSelected) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: this.getWidget().getPane().getChart(), overlay, figure: figure !== null && figure !== void 0 ? figure : void 0 }, event));
        return true;
      }
      return false;
    };
    OverlayView2.prototype._processOverlayDeselectedEvent = function(overlay, figure, event) {
      var _a;
      if (checkOverlayFigureEvent("onDeselected", figure)) {
        (_a = overlay.onDeselected) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: this.getWidget().getPane().getChart(), overlay, figure: figure !== null && figure !== void 0 ? figure : void 0 }, event));
        return true;
      }
      return false;
    };
    OverlayView2.prototype._figureMouseMoveEvent = function(overlay, figureType, figureIndex, figure) {
      var _this = this;
      return function(event) {
        var _a;
        var pane = _this.getWidget().getPane();
        var check = !overlay.isDrawing() && checkOverlayFigureEvent("onMouseMove", figure);
        if (check) {
          var prevented_2 = false;
          (_a = overlay.onMouseMove) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign(__assign({ chart: pane.getChart(), overlay, figure }, event), { preventDefault: function() {
            prevented_2 = true;
          } }));
          if (prevented_2) {
            _this.getWidget().setForceCursor(null);
          } else {
            _this.getWidget().setForceCursor("pointer");
          }
        }
        pane.getChart().getChartStore().setHoverOverlayInfo({ paneId: pane.getId(), overlay, figureType, figure, figureIndex }, function(o, f) {
          return _this._processOverlayMouseEnterEvent(o, f, event);
        }, function(o, f) {
          return _this._processOverlayMouseLeaveEvent(o, f, event);
        });
        return check;
      };
    };
    OverlayView2.prototype._figureMouseDownEvent = function(overlay, figureType, figureIndex, figure) {
      var _this = this;
      return function(event) {
        var _a;
        var pane = _this.getWidget().getPane();
        var paneId = pane.getId();
        overlay.startPressedMove(_this._coordinateToPoint(overlay, event));
        if (checkOverlayFigureEvent("onPressedMoveStart", figure)) {
          (_a = overlay.onPressedMoveStart) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: pane.getChart(), overlay, figure }, event));
          pane.getChart().getChartStore().setPressedOverlayInfo({ paneId, overlay, figureType, figureIndex, figure });
          return !overlay.isDrawing();
        }
        return false;
      };
    };
    OverlayView2.prototype._figureMouseClickEvent = function(overlay, figureType, figureIndex, figure) {
      var _this = this;
      return function(event) {
        var _a;
        var pane = _this.getWidget().getPane();
        var paneId = pane.getId();
        var check = !overlay.isDrawing() && checkOverlayFigureEvent("onClick", figure);
        if (check) {
          (_a = overlay.onClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign({ chart: _this.getWidget().getPane().getChart(), overlay, figure }, event));
        }
        pane.getChart().getChartStore().setClickOverlayInfo({ paneId, overlay, figureType, figureIndex, figure }, function(o, f) {
          return _this._processOverlaySelectedEvent(o, f, event);
        }, function(o, f) {
          return _this._processOverlayDeselectedEvent(o, f, event);
        });
        return check;
      };
    };
    OverlayView2.prototype._figureMouseDoubleClickEvent = function(overlay, _figureType, _figureIndex, figure) {
      var _this = this;
      return function(event) {
        var _a;
        if (checkOverlayFigureEvent("onDoubleClick", figure)) {
          (_a = overlay.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign(__assign({}, event), { chart: _this.getWidget().getPane().getChart(), figure, overlay }));
          return !overlay.isDrawing();
        }
        return false;
      };
    };
    OverlayView2.prototype._figureMouseRightClickEvent = function(overlay, _figureType, _figureIndex, figure) {
      var _this = this;
      return function(event) {
        var _a;
        if (checkOverlayFigureEvent("onRightClick", figure)) {
          var prevented_3 = false;
          (_a = overlay.onRightClick) === null || _a === void 0 ? void 0 : _a.call(overlay, __assign(__assign({ chart: _this.getWidget().getPane().getChart(), overlay, figure }, event), { preventDefault: function() {
            prevented_3 = true;
          } }));
          if (!prevented_3) {
            _this.getWidget().getPane().getChart().getChartStore().removeOverlay(overlay);
          }
          return !overlay.isDrawing();
        }
        return false;
      };
    };
    OverlayView2.prototype._coordinateToPoint = function(o, coordinate) {
      var _a;
      var point = {};
      var pane = this.getWidget().getPane();
      var chart = pane.getChart();
      var paneId = pane.getId();
      var chartStore = chart.getChartStore();
      if (this.coordinateToPointTimestampDataIndexFlag()) {
        var xAxis = chart.getXAxisPane().getAxisComponent();
        var dataIndex = xAxis.convertFromPixel(coordinate.x);
        var timestamp = (_a = chartStore.dataIndexToTimestamp(dataIndex)) !== null && _a !== void 0 ? _a : void 0;
        point.timestamp = timestamp;
        point.dataIndex = dataIndex;
      }
      if (this.coordinateToPointValueFlag()) {
        var yAxis = pane.getAxisComponent();
        var value = yAxis.convertFromPixel(coordinate.y);
        if (o.mode !== "normal" && paneId === PaneIdConstants.CANDLE && isNumber(point.dataIndex)) {
          var kLineData = chartStore.getDataByDataIndex(point.dataIndex);
          if (kLineData !== null) {
            var modeSensitivity = o.modeSensitivity;
            if (value > kLineData.high) {
              if (o.mode === "weak_magnet") {
                var highY = yAxis.convertToPixel(kLineData.high);
                var buffValue = yAxis.convertFromPixel(highY - modeSensitivity);
                if (value < buffValue) {
                  value = kLineData.high;
                }
              } else {
                value = kLineData.high;
              }
            } else if (value < kLineData.low) {
              if (o.mode === "weak_magnet") {
                var lowY = yAxis.convertToPixel(kLineData.low);
                var buffValue = yAxis.convertFromPixel(lowY - modeSensitivity);
                if (value > buffValue) {
                  value = kLineData.low;
                }
              } else {
                value = kLineData.low;
              }
            } else {
              var max = Math.max(kLineData.open, kLineData.close);
              var min = Math.min(kLineData.open, kLineData.close);
              if (value > max) {
                if (value - max < kLineData.high - value) {
                  value = max;
                } else {
                  value = kLineData.high;
                }
              } else if (value < min) {
                if (value - kLineData.low < min - value) {
                  value = kLineData.low;
                } else {
                  value = min;
                }
              } else if (max - value < value - min) {
                value = max;
              } else {
                value = min;
              }
            }
          }
        }
        point.value = value;
      }
      return point;
    };
    OverlayView2.prototype.coordinateToPointValueFlag = function() {
      return true;
    };
    OverlayView2.prototype.coordinateToPointTimestampDataIndexFlag = function() {
      return true;
    };
    OverlayView2.prototype.dispatchEvent = function(name, event) {
      if (this.getWidget().getPane().getChart().getChartStore().isOverlayDrawing()) {
        return this.onEvent(name, event);
      }
      return _super.prototype.dispatchEvent.call(this, name, event);
    };
    OverlayView2.prototype.drawImp = function(ctx) {
      var _this = this;
      var overlays2 = this.getCompleteOverlays();
      overlays2.forEach(function(overlay) {
        if (overlay.visible) {
          _this._drawOverlay(ctx, overlay);
        }
      });
      var progressOverlay = this.getProgressOverlay();
      if (isValid(progressOverlay) && progressOverlay.visible) {
        this._drawOverlay(ctx, progressOverlay);
      }
    };
    OverlayView2.prototype._drawOverlay = function(ctx, overlay) {
      var points = overlay.points;
      var pane = this.getWidget().getPane();
      var chart = pane.getChart();
      var chartStore = chart.getChartStore();
      var yAxis = pane.getAxisComponent();
      var xAxis = chart.getXAxisPane().getAxisComponent();
      var coordinates = points.map(function(point) {
        var _a;
        var dataIndex = null;
        if (isNumber(point.timestamp)) {
          dataIndex = chartStore.timestampToDataIndex(point.timestamp);
        }
        var coordinate = { x: 0, y: 0 };
        if (isNumber(dataIndex)) {
          coordinate.x = xAxis.convertToPixel(dataIndex);
        }
        if (isNumber(point.value)) {
          coordinate.y = (_a = yAxis === null || yAxis === void 0 ? void 0 : yAxis.convertToPixel(point.value)) !== null && _a !== void 0 ? _a : 0;
        }
        return coordinate;
      });
      if (coordinates.length > 0) {
        var figures2 = [].concat(this.getFigures(overlay, coordinates));
        this.drawFigures(ctx, overlay, figures2);
      }
      this.drawDefaultFigures(ctx, overlay, coordinates);
    };
    OverlayView2.prototype.drawFigures = function(ctx, overlay, figures2) {
      var _this = this;
      var defaultStyles = this.getWidget().getPane().getChart().getStyles().overlay;
      figures2.forEach(function(figure, figureIndex) {
        var type = figure.type, styles2 = figure.styles, attrs = figure.attrs;
        var attrsArray = [].concat(attrs);
        attrsArray.forEach(function(ats) {
          var _a, _b;
          var events = _this._createFigureEvents(overlay, "other", figureIndex, figure);
          var ss = __assign(__assign(__assign({}, defaultStyles[type]), (_a = overlay.styles) === null || _a === void 0 ? void 0 : _a[type]), styles2);
          (_b = _this.createFigure({
            name: type,
            attrs: ats,
            styles: ss
          }, events !== null && events !== void 0 ? events : void 0)) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        });
      });
    };
    OverlayView2.prototype.getCompleteOverlays = function() {
      var pane = this.getWidget().getPane();
      return pane.getChart().getChartStore().getOverlaysByPaneId(pane.getId());
    };
    OverlayView2.prototype.getProgressOverlay = function() {
      var pane = this.getWidget().getPane();
      var info = pane.getChart().getChartStore().getProgressOverlayInfo();
      if (isValid(info) && info.paneId === pane.getId()) {
        return info.overlay;
      }
      return null;
    };
    OverlayView2.prototype.getFigures = function(o, coordinates) {
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chart = pane.getChart();
      var yAxis = pane.getAxisComponent();
      var xAxis = chart.getXAxisPane().getAxisComponent();
      var bounding = widget.getBounding();
      return (_b = (_a = o.createPointFigures) === null || _a === void 0 ? void 0 : _a.call(o, { chart, overlay: o, coordinates, bounding, xAxis, yAxis })) !== null && _b !== void 0 ? _b : [];
    };
    OverlayView2.prototype.drawDefaultFigures = function(ctx, overlay, coordinates) {
      var _this = this;
      var _a, _b;
      if (overlay.needDefaultPointFigure) {
        var chartStore = this.getWidget().getPane().getChart().getChartStore();
        var hoverOverlayInfo_1 = chartStore.getHoverOverlayInfo();
        var clickOverlayInfo = chartStore.getClickOverlayInfo();
        if (((_a = hoverOverlayInfo_1.overlay) === null || _a === void 0 ? void 0 : _a.id) === overlay.id && hoverOverlayInfo_1.figureType !== "none" || ((_b = clickOverlayInfo.overlay) === null || _b === void 0 ? void 0 : _b.id) === overlay.id && clickOverlayInfo.figureType !== "none") {
          var defaultStyles = chartStore.getStyles().overlay;
          var styles2 = overlay.styles;
          var pointStyles_1 = __assign(__assign({}, defaultStyles.point), styles2 === null || styles2 === void 0 ? void 0 : styles2.point);
          coordinates.forEach(function(_a2, index) {
            var _b2, _c, _d, _e, _f;
            var x = _a2.x, y = _a2.y;
            var radius = pointStyles_1.radius;
            var color = pointStyles_1.color;
            var borderColor = pointStyles_1.borderColor;
            var borderSize = pointStyles_1.borderSize;
            if (((_b2 = hoverOverlayInfo_1.overlay) === null || _b2 === void 0 ? void 0 : _b2.id) === overlay.id && hoverOverlayInfo_1.figureType === "point" && ((_c = hoverOverlayInfo_1.figure) === null || _c === void 0 ? void 0 : _c.key) === "".concat(OVERLAY_FIGURE_KEY_PREFIX, "point_").concat(index)) {
              radius = pointStyles_1.activeRadius;
              color = pointStyles_1.activeColor;
              borderColor = pointStyles_1.activeBorderColor;
              borderSize = pointStyles_1.activeBorderSize;
            }
            (_e = _this.createFigure({
              name: "circle",
              attrs: { x, y, r: radius + borderSize },
              styles: { color: borderColor }
            }, (_d = _this._createFigureEvents(overlay, "point", index, {
              key: "".concat(OVERLAY_FIGURE_KEY_PREFIX, "point_").concat(index),
              type: "circle",
              attrs: { x, y, r: radius + borderSize },
              styles: { color: borderColor }
            })) !== null && _d !== void 0 ? _d : void 0)) === null || _e === void 0 ? void 0 : _e.draw(ctx);
            (_f = _this.createFigure({
              name: "circle",
              attrs: { x, y, r: radius },
              styles: { color }
            })) === null || _f === void 0 ? void 0 : _f.draw(ctx);
          });
        }
      }
    };
    return OverlayView2;
  }(View)
);
var IndicatorWidget = (
  /** @class */
  function(_super) {
    __extends(IndicatorWidget2, _super);
    function IndicatorWidget2(rootContainer, pane) {
      var _this = _super.call(this, rootContainer, pane) || this;
      _this._gridView = new GridView(_this);
      _this._indicatorView = new IndicatorView(_this);
      _this._crosshairLineView = new CrosshairLineView(_this);
      _this._tooltipView = _this.createTooltipView();
      _this._overlayView = new OverlayView(_this);
      _this.addChild(_this._tooltipView);
      _this.addChild(_this._overlayView);
      return _this;
    }
    IndicatorWidget2.prototype.getName = function() {
      return WidgetNameConstants.MAIN;
    };
    IndicatorWidget2.prototype.updateMain = function(ctx) {
      if (this.getPane().getOptions().state !== "minimize") {
        this.updateMainContent(ctx);
        this._indicatorView.draw(ctx);
        this._gridView.draw(ctx);
      }
    };
    IndicatorWidget2.prototype.createTooltipView = function() {
      return new IndicatorTooltipView(this);
    };
    IndicatorWidget2.prototype.updateMainContent = function(_ctx) {
    };
    IndicatorWidget2.prototype.updateOverlayContent = function(_ctx) {
    };
    IndicatorWidget2.prototype.updateOverlay = function(ctx) {
      if (this.getPane().getOptions().state !== "minimize") {
        this._overlayView.draw(ctx);
        this._crosshairLineView.draw(ctx);
        this.updateOverlayContent(ctx);
      }
      this._tooltipView.draw(ctx);
    };
    return IndicatorWidget2;
  }(DrawWidget)
);
var CandleAreaView = (
  /** @class */
  function(_super) {
    __extends(CandleAreaView2, _super);
    function CandleAreaView2() {
      var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
      _this._ripplePoint = _this.createFigure({
        name: "circle",
        attrs: {
          x: 0,
          y: 0,
          r: 0
        },
        styles: {
          style: "fill"
        }
      });
      _this._animationFrameTime = 0;
      _this._animation = new Animation({ iterationCount: Infinity }).doFrame(function(time) {
        _this._animationFrameTime = time;
        var pane = _this.getWidget().getPane();
        pane.getChart().updatePane(0, pane.getId());
      });
      return _this;
    }
    CandleAreaView2.prototype.drawImp = function(ctx) {
      var _a, _b, _c;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chart = pane.getChart();
      var dataList = chart.getDataList();
      var lastDataIndex = dataList.length - 1;
      var bounding = widget.getBounding();
      var yAxis = pane.getAxisComponent();
      var styles2 = chart.getStyles().candle.area;
      var coordinates = [];
      var minY = Number.MAX_SAFE_INTEGER;
      var areaStartX = Number.MIN_SAFE_INTEGER;
      var ripplePointCoordinate = null;
      this.eachChildren(function(data) {
        var x = data.x;
        var kLineData = data.data.current;
        var value = kLineData === null || kLineData === void 0 ? void 0 : kLineData[styles2.value];
        if (isNumber(value)) {
          var y = yAxis.convertToPixel(value);
          if (areaStartX === Number.MIN_SAFE_INTEGER) {
            areaStartX = x;
          }
          coordinates.push({ x, y });
          minY = Math.min(minY, y);
          if (data.dataIndex === lastDataIndex) {
            ripplePointCoordinate = { x, y };
          }
        }
      });
      if (coordinates.length > 0) {
        (_a = this.createFigure({
          name: "line",
          attrs: { coordinates },
          styles: {
            color: styles2.lineColor,
            size: styles2.lineSize,
            smooth: styles2.smooth
          }
        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        var backgroundColor = styles2.backgroundColor;
        var color = "";
        if (isArray(backgroundColor)) {
          var gradient_1 = ctx.createLinearGradient(0, bounding.height, 0, minY);
          try {
            backgroundColor.forEach(function(_a2) {
              var offset = _a2.offset, color2 = _a2.color;
              gradient_1.addColorStop(offset, color2);
            });
          } catch (e) {
          }
          color = gradient_1;
        } else {
          color = backgroundColor;
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(areaStartX, bounding.height);
        ctx.lineTo(coordinates[0].x, coordinates[0].y);
        lineTo(ctx, coordinates, styles2.smooth);
        ctx.lineTo(coordinates[coordinates.length - 1].x, bounding.height);
        ctx.closePath();
        ctx.fill();
      }
      var pointStyles = styles2.point;
      if (pointStyles.show && isValid(ripplePointCoordinate)) {
        (_b = this.createFigure({
          name: "circle",
          attrs: {
            x: ripplePointCoordinate.x,
            y: ripplePointCoordinate.y,
            r: pointStyles.radius
          },
          styles: {
            style: "fill",
            color: pointStyles.color
          }
        })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        var rippleRadius = pointStyles.rippleRadius;
        if (pointStyles.animation) {
          rippleRadius = pointStyles.radius + this._animationFrameTime / pointStyles.animationDuration * (pointStyles.rippleRadius - pointStyles.radius);
          this._animation.setDuration(pointStyles.animationDuration).start();
        }
        (_c = this._ripplePoint) === null || _c === void 0 ? void 0 : _c.setAttrs({
          x: ripplePointCoordinate.x,
          y: ripplePointCoordinate.y,
          r: rippleRadius
        }).setStyles({ style: "fill", color: pointStyles.rippleColor }).draw(ctx);
      } else {
        this.stopAnimation();
      }
    };
    CandleAreaView2.prototype.stopAnimation = function() {
      this._animation.stop();
    };
    return CandleAreaView2;
  }(ChildrenView)
);
var CandleHighLowPriceView = (
  /** @class */
  function(_super) {
    __extends(CandleHighLowPriceView2, _super);
    function CandleHighLowPriceView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CandleHighLowPriceView2.prototype.drawImp = function(ctx) {
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = pane.getChart().getChartStore();
      var priceMarkStyles = chartStore.getStyles().candle.priceMark;
      var highPriceMarkStyles = priceMarkStyles.high;
      var lowPriceMarkStyles = priceMarkStyles.low;
      if (priceMarkStyles.show && (highPriceMarkStyles.show || lowPriceMarkStyles.show)) {
        var highestLowestPrice = chartStore.getVisibleRangeHighLowPrice();
        var precision = (_b = (_a = chartStore.getSymbol()) === null || _a === void 0 ? void 0 : _a.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE;
        var yAxis = pane.getAxisComponent();
        var _c = highestLowestPrice[0], high = _c.price, highX = _c.x;
        var _d = highestLowestPrice[1], low = _d.price, lowX = _d.x;
        var highY = yAxis.convertToPixel(high);
        var lowY = yAxis.convertToPixel(low);
        var decimalFold = chartStore.getDecimalFold();
        var thousandsSeparator = chartStore.getThousandsSeparator();
        if (highPriceMarkStyles.show && high !== Number.MIN_SAFE_INTEGER) {
          this._drawMark(ctx, decimalFold.format(thousandsSeparator.format(formatPrecision(high, precision))), { x: highX, y: highY }, highY < lowY ? [-2, -5] : [2, 5], highPriceMarkStyles);
        }
        if (lowPriceMarkStyles.show && low !== Number.MAX_SAFE_INTEGER) {
          this._drawMark(ctx, decimalFold.format(thousandsSeparator.format(formatPrecision(low, precision))), { x: lowX, y: lowY }, highY < lowY ? [2, 5] : [-2, -5], lowPriceMarkStyles);
        }
      }
    };
    CandleHighLowPriceView2.prototype._drawMark = function(ctx, text2, coordinate, offsets, styles2) {
      var _a, _b, _c;
      var startX = coordinate.x;
      var startY = coordinate.y + offsets[0];
      (_a = this.createFigure({
        name: "line",
        attrs: {
          coordinates: [
            { x: startX - 2, y: startY + offsets[0] },
            { x: startX, y: startY },
            { x: startX + 2, y: startY + offsets[0] }
          ]
        },
        styles: { color: styles2.color }
      })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
      var lineEndX = 0;
      var textStartX = 0;
      var textAlign = "left";
      var width = this.getWidget().getBounding().width;
      if (startX > width / 2) {
        lineEndX = startX - 5;
        textStartX = lineEndX - styles2.textOffset;
        textAlign = "right";
      } else {
        lineEndX = startX + 5;
        textAlign = "left";
        textStartX = lineEndX + styles2.textOffset;
      }
      var y = startY + offsets[1];
      (_b = this.createFigure({
        name: "line",
        attrs: {
          coordinates: [
            { x: startX, y: startY },
            { x: startX, y },
            { x: lineEndX, y }
          ]
        },
        styles: { color: styles2.color }
      })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
      (_c = this.createFigure({
        name: "text",
        attrs: {
          x: textStartX,
          y,
          text: text2,
          align: textAlign,
          baseline: "middle"
        },
        styles: {
          color: styles2.color,
          size: styles2.textSize,
          family: styles2.textFamily,
          weight: styles2.textWeight
        }
      })) === null || _c === void 0 ? void 0 : _c.draw(ctx);
    };
    return CandleHighLowPriceView2;
  }(View)
);
var CandleLastPriceView = (
  /** @class */
  function(_super) {
    __extends(CandleLastPriceView2, _super);
    function CandleLastPriceView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CandleLastPriceView2.prototype.drawImp = function(ctx) {
      var _a, _b, _c;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var bounding = widget.getBounding();
      var chartStore = pane.getChart().getChartStore();
      var priceMarkStyles = chartStore.getStyles().candle.priceMark;
      var lastPriceMarkStyles = priceMarkStyles.last;
      var lastPriceMarkLineStyles = lastPriceMarkStyles.line;
      if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkLineStyles.show) {
        var yAxis = pane.getAxisComponent();
        var dataList = chartStore.getDataList();
        var data = dataList[dataList.length - 1];
        if (isValid(data)) {
          var close_1 = data.close, open_1 = data.open;
          var comparePrice = lastPriceMarkStyles.compareRule === "current_open" ? open_1 : (_b = (_a = dataList[dataList.length - 2]) === null || _a === void 0 ? void 0 : _a.close) !== null && _b !== void 0 ? _b : close_1;
          var priceY = yAxis.convertToNicePixel(close_1);
          var color = "";
          if (close_1 > comparePrice) {
            color = lastPriceMarkStyles.upColor;
          } else if (close_1 < comparePrice) {
            color = lastPriceMarkStyles.downColor;
          } else {
            color = lastPriceMarkStyles.noChangeColor;
          }
          (_c = this.createFigure({
            name: "line",
            attrs: {
              coordinates: [
                { x: 0, y: priceY },
                { x: bounding.width, y: priceY }
              ]
            },
            styles: {
              style: lastPriceMarkLineStyles.style,
              color,
              size: lastPriceMarkLineStyles.size,
              dashedValue: lastPriceMarkLineStyles.dashedValue
            }
          })) === null || _c === void 0 ? void 0 : _c.draw(ctx);
        }
      }
    };
    return CandleLastPriceView2;
  }(View)
);
var PeriodTypeXAxisFormat = {
  second: "HH:mm:ss",
  minute: "HH:mm",
  hour: "MM-DD HH:mm",
  day: "YYYY-MM-DD",
  week: "YYYY-MM-DD",
  month: "YYYY-MM",
  year: "YYYY"
};
var PeriodTypeCrosshairTooltipFormat = {
  second: "HH:mm:ss",
  minute: "YYYY-MM-DD HH:mm",
  hour: "YYYY-MM-DD HH:mm",
  day: "YYYY-MM-DD",
  week: "YYYY-MM-DD",
  month: "YYYY-MM",
  year: "YYYY"
};
var zhCN = {
  time: "Êó∂Èó¥Ôºö",
  open: "ÂºÄÔºö",
  high: "È´òÔºö",
  low: "‰ΩéÔºö",
  close: "Êî∂Ôºö",
  volume: "Êàê‰∫§ÈáèÔºö",
  turnover: "Êàê‰∫§È¢ùÔºö",
  change: "Ê∂®ÂπÖÔºö",
  second: "Áßí",
  minute: "",
  hour: "Â∞èÊó∂",
  day: "Â§©",
  week: "Âë®",
  month: "Êúà",
  year: "Âπ¥"
};
var enUS = {
  time: "Time: ",
  open: "Open: ",
  high: "High: ",
  low: "Low: ",
  close: "Close: ",
  volume: "Volume: ",
  turnover: "Turnover: ",
  change: "Change: ",
  second: "S",
  minute: "",
  hour: "H",
  day: "D",
  week: "W",
  month: "M",
  year: "Y"
};
var locales = {
  "zh-CN": zhCN,
  "en-US": enUS
};
function registerLocale(locale, ls) {
  locales[locale] = __assign(__assign({}, locales[locale]), ls);
}
function getSupportedLocales() {
  return Object.keys(locales);
}
function i18n(key, locale) {
  var _a;
  return (_a = locales[locale][key]) !== null && _a !== void 0 ? _a : key;
}
var CandleTooltipView = (
  /** @class */
  function(_super) {
    __extends(CandleTooltipView2, _super);
    function CandleTooltipView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CandleTooltipView2.prototype.drawImp = function(ctx) {
      var widget = this.getWidget();
      var chartStore = widget.getPane().getChart().getChartStore();
      var crosshair = chartStore.getCrosshair();
      if (isValid(crosshair.kLineData)) {
        var bounding = widget.getBounding();
        var styles2 = chartStore.getStyles();
        var candleStyles = styles2.candle;
        var indicatorStyles = styles2.indicator;
        if (candleStyles.tooltip.showType === "rect" && indicatorStyles.tooltip.showType === "rect") {
          var isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);
          var isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);
          this._drawRectTooltip(ctx, isDrawCandleTooltip, isDrawIndicatorTooltip, candleStyles.tooltip.offsetTop);
        } else if (candleStyles.tooltip.showType === "standard" && indicatorStyles.tooltip.showType === "standard") {
          var _a = candleStyles.tooltip, offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop, offsetRight = _a.offsetRight;
          var maxWidth = bounding.width - offsetRight;
          var top_1 = this._drawCandleStandardTooltip(ctx, offsetLeft, offsetTop, maxWidth);
          this.drawIndicatorTooltip(ctx, offsetLeft, top_1, maxWidth);
        } else if (candleStyles.tooltip.showType === "rect" && indicatorStyles.tooltip.showType === "standard") {
          var _b = candleStyles.tooltip, offsetLeft = _b.offsetLeft, offsetTop = _b.offsetTop, offsetRight = _b.offsetRight;
          var maxWidth = bounding.width - offsetRight;
          var top_2 = this.drawIndicatorTooltip(ctx, offsetLeft, offsetTop, maxWidth);
          var isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);
          this._drawRectTooltip(ctx, isDrawCandleTooltip, false, top_2);
        } else {
          var _c = candleStyles.tooltip, offsetLeft = _c.offsetLeft, offsetTop = _c.offsetTop, offsetRight = _c.offsetRight;
          var maxWidth = bounding.width - offsetRight;
          var top_3 = this._drawCandleStandardTooltip(ctx, offsetLeft, offsetTop, maxWidth);
          var isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);
          this._drawRectTooltip(ctx, false, isDrawIndicatorTooltip, top_3);
        }
      }
    };
    CandleTooltipView2.prototype._drawCandleStandardTooltip = function(ctx, left, top, maxWidth) {
      var _a;
      var chartStore = this.getWidget().getPane().getChart().getChartStore();
      var styles2 = chartStore.getStyles().candle;
      var tooltipStyles = styles2.tooltip;
      var tooltipLegendStyles = tooltipStyles.legend;
      var prevRowHeight = 0;
      var coordinate = { x: left, y: top };
      var crosshair = chartStore.getCrosshair();
      if (this.isDrawTooltip(crosshair, tooltipStyles)) {
        var tooltipTitleStyles = tooltipStyles.title;
        if (tooltipTitleStyles.show) {
          var _b = (_a = chartStore.getPeriod()) !== null && _a !== void 0 ? _a : {}, _c = _b.type, type = _c === void 0 ? "" : _c, _d = _b.span, span = _d === void 0 ? "" : _d;
          var text2 = formatTemplateString(tooltipTitleStyles.template, __assign(__assign({}, chartStore.getSymbol()), { period: "".concat(span).concat(i18n(type, chartStore.getLocale())) }));
          var color = tooltipTitleStyles.color;
          var height = this.drawStandardTooltipLegends(ctx, [
            {
              title: { text: "", color },
              value: { text: text2, color }
            }
          ], { x: left, y: top }, left, 0, maxWidth, tooltipTitleStyles);
          coordinate.y = coordinate.y + height;
        }
        var legends = this._getCandleTooltipLegends();
        var features = this.classifyTooltipFeatures(tooltipStyles.features);
        prevRowHeight = this.drawStandardTooltipFeatures(ctx, features[0], coordinate, null, left, prevRowHeight, maxWidth);
        prevRowHeight = this.drawStandardTooltipFeatures(ctx, features[1], coordinate, null, left, prevRowHeight, maxWidth);
        if (legends.length > 0) {
          prevRowHeight = this.drawStandardTooltipLegends(ctx, legends, coordinate, left, prevRowHeight, maxWidth, tooltipLegendStyles);
        }
        prevRowHeight = this.drawStandardTooltipFeatures(ctx, features[2], coordinate, null, left, prevRowHeight, maxWidth);
      }
      return coordinate.y + prevRowHeight;
    };
    CandleTooltipView2.prototype._drawRectTooltip = function(ctx, isDrawCandleTooltip, isDrawIndicatorTooltip, top) {
      var _this = this;
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = pane.getChart().getChartStore();
      var styles2 = chartStore.getStyles();
      var candleStyles = styles2.candle;
      var indicatorStyles = styles2.indicator;
      var candleTooltipStyles = candleStyles.tooltip;
      var indicatorTooltipStyles = indicatorStyles.tooltip;
      if (isDrawCandleTooltip || isDrawIndicatorTooltip) {
        var candleLegends = this._getCandleTooltipLegends();
        var offsetLeft = candleTooltipStyles.offsetLeft, offsetTop = candleTooltipStyles.offsetTop, offsetRight = candleTooltipStyles.offsetRight, offsetBottom = candleTooltipStyles.offsetBottom;
        var _c = candleTooltipStyles.legend, baseLegendMarginLeft_1 = _c.marginLeft, baseLegendMarginRight_1 = _c.marginRight, baseLegendMarginTop_1 = _c.marginTop, baseLegendMarginBottom_1 = _c.marginBottom, baseLegendSize_1 = _c.size, baseLegendWeight_1 = _c.weight, baseLegendFamily_1 = _c.family;
        var _d = candleTooltipStyles.rect, rectPosition = _d.position, rectPaddingLeft = _d.paddingLeft, rectPaddingRight_1 = _d.paddingRight, rectPaddingTop = _d.paddingTop, rectPaddingBottom = _d.paddingBottom, rectOffsetLeft = _d.offsetLeft, rectOffsetRight = _d.offsetRight, rectOffsetTop = _d.offsetTop, rectOffsetBottom = _d.offsetBottom, rectBorderSize_1 = _d.borderSize, rectBorderRadius = _d.borderRadius, rectBorderColor = _d.borderColor, rectBackgroundColor = _d.color;
        var maxTextWidth_1 = 0;
        var rectWidth_1 = 0;
        var rectHeight_1 = 0;
        if (isDrawCandleTooltip) {
          ctx.font = createFont(baseLegendSize_1, baseLegendWeight_1, baseLegendFamily_1);
          candleLegends.forEach(function(data) {
            var title = data.title;
            var value = data.value;
            var text2 = "".concat(title.text).concat(value.text);
            var labelWidth = ctx.measureText(text2).width + baseLegendMarginLeft_1 + baseLegendMarginRight_1;
            maxTextWidth_1 = Math.max(maxTextWidth_1, labelWidth);
          });
          rectHeight_1 += (baseLegendMarginBottom_1 + baseLegendMarginTop_1 + baseLegendSize_1) * candleLegends.length;
        }
        var _e = indicatorTooltipStyles.legend, indicatorLegendMarginLeft_1 = _e.marginLeft, indicatorLegendMarginRight_1 = _e.marginRight, indicatorLegendMarginTop_1 = _e.marginTop, indicatorLegendMarginBottom_1 = _e.marginBottom, indicatorLegendSize_1 = _e.size, indicatorLegendWeight_1 = _e.weight, indicatorLegendFamily_1 = _e.family;
        var indicatorLegendsArray_1 = [];
        if (isDrawIndicatorTooltip) {
          var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
          ctx.font = createFont(indicatorLegendSize_1, indicatorLegendWeight_1, indicatorLegendFamily_1);
          indicators2.forEach(function(indicator) {
            var tooltipDataLegends = _this.getIndicatorTooltipData(indicator).legends;
            indicatorLegendsArray_1.push(tooltipDataLegends);
            tooltipDataLegends.forEach(function(data) {
              var title = data.title;
              var value = data.value;
              var text2 = "".concat(title.text).concat(value.text);
              var textWidth = ctx.measureText(text2).width + indicatorLegendMarginLeft_1 + indicatorLegendMarginRight_1;
              maxTextWidth_1 = Math.max(maxTextWidth_1, textWidth);
              rectHeight_1 += indicatorLegendMarginTop_1 + indicatorLegendMarginBottom_1 + indicatorLegendSize_1;
            });
          });
        }
        rectWidth_1 += maxTextWidth_1;
        if (rectWidth_1 !== 0 && rectHeight_1 !== 0) {
          var crosshair = chartStore.getCrosshair();
          var bounding = widget.getBounding();
          var yAxisBounding = pane.getYAxisWidget().getBounding();
          rectWidth_1 += rectBorderSize_1 * 2 + rectPaddingLeft + rectPaddingRight_1;
          rectHeight_1 += rectBorderSize_1 * 2 + rectPaddingTop + rectPaddingBottom;
          var centerX = bounding.width / 2;
          var isPointer = rectPosition === "pointer" && crosshair.paneId === PaneIdConstants.CANDLE;
          var isLeft = ((_a = crosshair.realX) !== null && _a !== void 0 ? _a : 0) > centerX;
          var rectX_1 = 0;
          if (isPointer) {
            var realX = crosshair.realX;
            if (isLeft) {
              rectX_1 = realX - rectOffsetRight - rectWidth_1;
            } else {
              rectX_1 = realX + rectOffsetLeft;
            }
          } else {
            var yAxis = this.getWidget().getPane().getAxisComponent();
            if (isLeft) {
              rectX_1 = rectOffsetLeft + offsetLeft;
              if (yAxis.inside && yAxis.position === "left") {
                rectX_1 += yAxisBounding.width;
              }
            } else {
              rectX_1 = bounding.width - rectOffsetRight - rectWidth_1 - offsetRight;
              if (yAxis.inside && yAxis.position === "right") {
                rectX_1 -= yAxisBounding.width;
              }
            }
          }
          var rectY = top + rectOffsetTop;
          if (isPointer) {
            var y = crosshair.y;
            rectY = y - rectHeight_1 / 2;
            if (rectY + rectHeight_1 > bounding.height - rectOffsetBottom - offsetBottom) {
              rectY = bounding.height - rectOffsetBottom - rectHeight_1 - offsetBottom;
            }
            if (rectY < top + rectOffsetTop) {
              rectY = top + rectOffsetTop + offsetTop;
            }
          }
          (_b = this.createFigure({
            name: "rect",
            attrs: {
              x: rectX_1,
              y: rectY,
              width: rectWidth_1,
              height: rectHeight_1
            },
            styles: {
              style: "stroke_fill",
              color: rectBackgroundColor,
              borderColor: rectBorderColor,
              borderSize: rectBorderSize_1,
              borderRadius: rectBorderRadius
            }
          })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
          var candleTextX_1 = rectX_1 + rectBorderSize_1 + rectPaddingLeft + baseLegendMarginLeft_1;
          var textY_1 = rectY + rectBorderSize_1 + rectPaddingTop;
          if (isDrawCandleTooltip) {
            candleLegends.forEach(function(data) {
              var _a2, _b2;
              textY_1 += baseLegendMarginTop_1;
              var title = data.title;
              (_a2 = _this.createFigure({
                name: "text",
                attrs: {
                  x: candleTextX_1,
                  y: textY_1,
                  text: title.text
                },
                styles: {
                  color: title.color,
                  size: baseLegendSize_1,
                  family: baseLegendFamily_1,
                  weight: baseLegendWeight_1
                }
              })) === null || _a2 === void 0 ? void 0 : _a2.draw(ctx);
              var value = data.value;
              (_b2 = _this.createFigure({
                name: "text",
                attrs: {
                  x: rectX_1 + rectWidth_1 - rectBorderSize_1 - baseLegendMarginRight_1 - rectPaddingRight_1,
                  y: textY_1,
                  text: value.text,
                  align: "right"
                },
                styles: {
                  color: value.color,
                  size: baseLegendSize_1,
                  family: baseLegendFamily_1,
                  weight: baseLegendWeight_1
                }
              })) === null || _b2 === void 0 ? void 0 : _b2.draw(ctx);
              textY_1 += baseLegendSize_1 + baseLegendMarginBottom_1;
            });
          }
          if (isDrawIndicatorTooltip) {
            var indicatorTextX_1 = rectX_1 + rectBorderSize_1 + rectPaddingLeft + indicatorLegendMarginLeft_1;
            indicatorLegendsArray_1.forEach(function(legends) {
              legends.forEach(function(data) {
                var _a2, _b2;
                textY_1 += indicatorLegendMarginTop_1;
                var title = data.title;
                var value = data.value;
                (_a2 = _this.createFigure({
                  name: "text",
                  attrs: {
                    x: indicatorTextX_1,
                    y: textY_1,
                    text: title.text
                  },
                  styles: {
                    color: title.color,
                    size: indicatorLegendSize_1,
                    family: indicatorLegendFamily_1,
                    weight: indicatorLegendWeight_1
                  }
                })) === null || _a2 === void 0 ? void 0 : _a2.draw(ctx);
                (_b2 = _this.createFigure({
                  name: "text",
                  attrs: {
                    x: rectX_1 + rectWidth_1 - rectBorderSize_1 - indicatorLegendMarginRight_1 - rectPaddingRight_1,
                    y: textY_1,
                    text: value.text,
                    align: "right"
                  },
                  styles: {
                    color: value.color,
                    size: indicatorLegendSize_1,
                    family: indicatorLegendFamily_1,
                    weight: indicatorLegendWeight_1
                  }
                })) === null || _b2 === void 0 ? void 0 : _b2.draw(ctx);
                textY_1 += indicatorLegendSize_1 + indicatorLegendMarginBottom_1;
              });
            });
          }
        }
      }
    };
    CandleTooltipView2.prototype._getCandleTooltipLegends = function() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var chartStore = this.getWidget().getPane().getChart().getChartStore();
      var styles2 = chartStore.getStyles().candle;
      var dataList = chartStore.getDataList();
      var formatter = chartStore.getInnerFormatter();
      var decimalFold = chartStore.getDecimalFold();
      var thousandsSeparator = chartStore.getThousandsSeparator();
      var locale = chartStore.getLocale();
      var _j = (_a = chartStore.getSymbol()) !== null && _a !== void 0 ? _a : {}, _k = _j.pricePrecision, pricePrecision = _k === void 0 ? SymbolDefaultPrecisionConstants.PRICE : _k, _l = _j.volumePrecision, volumePrecision = _l === void 0 ? SymbolDefaultPrecisionConstants.VOLUME : _l;
      var period = chartStore.getPeriod();
      var dataIndex = (_b = chartStore.getCrosshair().dataIndex) !== null && _b !== void 0 ? _b : 0;
      var tooltipStyles = styles2.tooltip;
      var _m = tooltipStyles.legend, textColor = _m.color, defaultValue = _m.defaultValue, template = _m.template;
      var prev = (_c = dataList[dataIndex - 1]) !== null && _c !== void 0 ? _c : null;
      var current = dataList[dataIndex];
      var prevClose = (_d = prev === null || prev === void 0 ? void 0 : prev.close) !== null && _d !== void 0 ? _d : current.close;
      var changeValue = current.close - prevClose;
      var mapping = __assign(__assign({}, current), { time: formatter.formatDate(current.timestamp, PeriodTypeCrosshairTooltipFormat[(_e = period === null || period === void 0 ? void 0 : period.type) !== null && _e !== void 0 ? _e : "day"], "tooltip"), open: decimalFold.format(thousandsSeparator.format(formatPrecision(current.open, pricePrecision))), high: decimalFold.format(thousandsSeparator.format(formatPrecision(current.high, pricePrecision))), low: decimalFold.format(thousandsSeparator.format(formatPrecision(current.low, pricePrecision))), close: decimalFold.format(thousandsSeparator.format(formatPrecision(current.close, pricePrecision))), volume: decimalFold.format(thousandsSeparator.format(formatter.formatBigNumber(formatPrecision((_f = current.volume) !== null && _f !== void 0 ? _f : defaultValue, volumePrecision)))), turnover: decimalFold.format(thousandsSeparator.format(formatPrecision((_g = current.turnover) !== null && _g !== void 0 ? _g : defaultValue, pricePrecision))), change: prevClose === 0 ? defaultValue : "".concat(thousandsSeparator.format(formatPrecision(changeValue / prevClose * 100)), "%") });
      var legends = isFunction(template) ? template({ prev, current, next: (_h = dataList[dataIndex + 1]) !== null && _h !== void 0 ? _h : null }, styles2) : template;
      return legends.map(function(_a2) {
        var title = _a2.title, value = _a2.value;
        var t = { text: "", color: textColor };
        if (isObject(title)) {
          t = __assign({}, title);
        } else {
          t.text = title;
        }
        t.text = i18n(t.text, locale);
        var v = { text: defaultValue, color: textColor };
        if (isObject(value)) {
          v = __assign({}, value);
        } else {
          v.text = value;
        }
        if (isValid(/{change}/.exec(v.text))) {
          v.color = changeValue === 0 ? styles2.priceMark.last.noChangeColor : changeValue > 0 ? styles2.priceMark.last.upColor : styles2.priceMark.last.downColor;
        }
        v.text = formatTemplateString(v.text, mapping);
        return { title: t, value: v };
      });
    };
    return CandleTooltipView2;
  }(IndicatorTooltipView)
);
var CrosshairFeatureView = (
  /** @class */
  function(_super) {
    __extends(CrosshairFeatureView2, _super);
    function CrosshairFeatureView2(widget) {
      var _this = _super.call(this, widget) || this;
      _this._activeFeatureInfo = null;
      _this._featureClickEvent = function(featureInfo) {
        return function() {
          var pane = _this.getWidget().getPane();
          pane.getChart().getChartStore().executeAction("onCrosshairFeatureClick", featureInfo);
          return true;
        };
      };
      _this._featureMouseMoveEvent = function(featureInfo) {
        return function() {
          _this._activeFeatureInfo = featureInfo;
          _this.getWidget().setForceCursor("pointer");
          return true;
        };
      };
      _this.registerEvent("mouseMoveEvent", function(_) {
        _this._activeFeatureInfo = null;
        _this.getWidget().setForceCursor(null);
        return false;
      });
      return _this;
    }
    CrosshairFeatureView2.prototype.drawImp = function(ctx) {
      var _this = this;
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = widget.getPane().getChart().getChartStore();
      var crosshair = chartStore.getCrosshair();
      var weight = this.getWidget();
      var yAxis = weight.getPane().getAxisComponent();
      if (isString(crosshair.paneId) && crosshair.paneId === pane.getId() && yAxis.isInCandle()) {
        var styles2 = chartStore.getStyles().crosshair;
        var features = styles2.horizontal.features;
        if (styles2.show && styles2.horizontal.show && features.length > 0) {
          var isRight_1 = yAxis.position === "right";
          var bounding = weight.getBounding();
          var yAxisTextWidth = 0;
          var horizontalTextStyles = styles2.horizontal.text;
          if (yAxis.inside && horizontalTextStyles.show) {
            var value = yAxis.convertFromPixel(crosshair.y);
            var range = yAxis.getRange();
            var text2 = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(value, { range }), { range }), (_b = (_a = chartStore.getSymbol()) === null || _a === void 0 ? void 0 : _a.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE);
            text2 = chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(text2));
            yAxisTextWidth = horizontalTextStyles.paddingLeft + calcTextWidth(text2, horizontalTextStyles.size, horizontalTextStyles.weight, horizontalTextStyles.family) + horizontalTextStyles.paddingRight;
          }
          var x_1 = yAxisTextWidth;
          if (isRight_1) {
            x_1 = bounding.width - yAxisTextWidth;
          }
          var y_1 = crosshair.y;
          features.forEach(function(feature) {
            var _a2, _b2, _c, _d;
            var _e = feature.marginLeft, marginLeft = _e === void 0 ? 0 : _e, _f = feature.marginTop, marginTop = _f === void 0 ? 0 : _f, _g = feature.marginRight, marginRight = _g === void 0 ? 0 : _g, _h = feature.paddingLeft, paddingLeft = _h === void 0 ? 0 : _h, _j = feature.paddingTop, paddingTop = _j === void 0 ? 0 : _j, _k = feature.paddingRight, paddingRight = _k === void 0 ? 0 : _k, _l = feature.paddingBottom, paddingBottom = _l === void 0 ? 0 : _l, color = feature.color, activeColor = feature.activeColor, backgroundColor = feature.backgroundColor, activeBackgroundColor = feature.activeBackgroundColor, borderRadius = feature.borderRadius, _m = feature.size, size = _m === void 0 ? 0 : _m, type = feature.type, content = feature.content;
            var width = size;
            if (type === "icon_font") {
              var iconFont = content;
              width = paddingLeft + calcTextWidth(iconFont.code, size, "normal", iconFont.family) + paddingRight;
            }
            if (isRight_1) {
              x_1 -= width + marginRight;
            } else {
              x_1 += marginLeft;
            }
            var finalColor = color;
            var finalBackgroundColor = backgroundColor;
            if (((_a2 = _this._activeFeatureInfo) === null || _a2 === void 0 ? void 0 : _a2.feature.id) === feature.id) {
              finalColor = activeColor !== null && activeColor !== void 0 ? activeColor : color;
              finalBackgroundColor = activeBackgroundColor !== null && activeBackgroundColor !== void 0 ? activeBackgroundColor : backgroundColor;
            }
            var eventHandler = {
              mouseDownEvent: _this._featureClickEvent({ crosshair, feature }),
              mouseMoveEvent: _this._featureMouseMoveEvent({ crosshair, feature })
            };
            if (type === "icon_font") {
              var iconFont = content;
              (_b2 = _this.createFigure({
                name: "text",
                attrs: {
                  text: iconFont.code,
                  x: x_1,
                  y: y_1 + marginTop,
                  baseline: "middle"
                },
                styles: {
                  paddingLeft,
                  paddingTop,
                  paddingRight,
                  paddingBottom,
                  borderRadius,
                  size,
                  family: iconFont.family,
                  color: finalColor,
                  backgroundColor: finalBackgroundColor
                }
              }, eventHandler)) === null || _b2 === void 0 ? void 0 : _b2.draw(ctx);
            } else {
              (_c = _this.createFigure({
                name: "rect",
                attrs: { x: x_1, y: y_1 + marginTop - size / 2, width: size, height: size },
                styles: {
                  paddingLeft,
                  paddingTop,
                  paddingRight,
                  paddingBottom,
                  color: finalBackgroundColor
                }
              }, eventHandler)) === null || _c === void 0 ? void 0 : _c.draw(ctx);
              var path2 = content;
              (_d = _this.createFigure({
                name: "path",
                attrs: { path: path2.path, x: x_1, y: y_1 + marginTop + paddingTop - size / 2, width: size, height: size },
                styles: {
                  style: path2.style,
                  lineWidth: path2.lineWidth,
                  color: finalColor
                }
              })) === null || _d === void 0 ? void 0 : _d.draw(ctx);
            }
            if (isRight_1) {
              x_1 -= marginLeft;
            } else {
              x_1 += width + marginRight;
            }
          });
        }
      }
    };
    return CrosshairFeatureView2;
  }(View)
);
var CandleWidget = (
  /** @class */
  function(_super) {
    __extends(CandleWidget2, _super);
    function CandleWidget2(rootContainer, pane) {
      var _this = _super.call(this, rootContainer, pane) || this;
      _this._candleBarView = new CandleBarView(_this);
      _this._candleAreaView = new CandleAreaView(_this);
      _this._candleHighLowPriceView = new CandleHighLowPriceView(_this);
      _this._candleLastPriceLineView = new CandleLastPriceView(_this);
      _this._crosshairFeatureView = new CrosshairFeatureView(_this);
      _this.addChild(_this._candleBarView);
      _this.addChild(_this._crosshairFeatureView);
      return _this;
    }
    CandleWidget2.prototype.updateMainContent = function(ctx) {
      var candleStyles = this.getPane().getChart().getStyles().candle;
      if (candleStyles.type !== "area") {
        this._candleBarView.draw(ctx);
        this._candleHighLowPriceView.draw(ctx);
        this._candleAreaView.stopAnimation();
      } else {
        this._candleAreaView.draw(ctx);
      }
      this._candleLastPriceLineView.draw(ctx);
    };
    CandleWidget2.prototype.updateOverlayContent = function(ctx) {
      this._crosshairFeatureView.draw(ctx);
    };
    CandleWidget2.prototype.createTooltipView = function() {
      return new CandleTooltipView(this);
    };
    return CandleWidget2;
  }(IndicatorWidget)
);
var AxisView = (
  /** @class */
  function(_super) {
    __extends(AxisView2, _super);
    function AxisView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisView2.prototype.drawImp = function(ctx, extend) {
      var _this = this;
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var bounding = widget.getBounding();
      var axis = pane.getAxisComponent();
      var styles2 = this.getAxisStyles(pane.getChart().getStyles());
      if (styles2.show) {
        if (styles2.axisLine.show) {
          (_a = this.createFigure({
            name: "line",
            attrs: this.createAxisLine(bounding, styles2),
            styles: styles2.axisLine
          })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        }
        if (!extend[0]) {
          var ticks = axis.getTicks();
          if (styles2.tickLine.show) {
            var lines = this.createTickLines(ticks, bounding, styles2);
            lines.forEach(function(line2) {
              var _a2;
              (_a2 = _this.createFigure({
                name: "line",
                attrs: line2,
                styles: styles2.tickLine
              })) === null || _a2 === void 0 ? void 0 : _a2.draw(ctx);
            });
          }
          if (styles2.tickText.show) {
            var texts = this.createTickTexts(ticks, bounding, styles2);
            (_b = this.createFigure({
              name: "text",
              attrs: texts,
              styles: styles2.tickText
            })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
          }
        }
      }
    };
    return AxisView2;
  }(View)
);
var YAxisView = (
  /** @class */
  function(_super) {
    __extends(YAxisView2, _super);
    function YAxisView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    YAxisView2.prototype.getAxisStyles = function(styles2) {
      return styles2.yAxis;
    };
    YAxisView2.prototype.createAxisLine = function(bounding, styles2) {
      var yAxis = this.getWidget().getPane().getAxisComponent();
      var size = styles2.axisLine.size;
      var x = 0;
      if (yAxis.isFromZero()) {
        x = 0;
      } else {
        x = bounding.width - size;
      }
      return {
        coordinates: [
          { x, y: 0 },
          { x, y: bounding.height }
        ]
      };
    };
    YAxisView2.prototype.createTickLines = function(ticks, bounding, styles2) {
      var yAxis = this.getWidget().getPane().getAxisComponent();
      var axisLineStyles = styles2.axisLine;
      var tickLineStyles = styles2.tickLine;
      var startX = 0;
      var endX = 0;
      if (yAxis.isFromZero()) {
        startX = 0;
        if (axisLineStyles.show) {
          startX += axisLineStyles.size;
        }
        endX = startX + tickLineStyles.length;
      } else {
        startX = bounding.width;
        if (axisLineStyles.show) {
          startX -= axisLineStyles.size;
        }
        endX = startX - tickLineStyles.length;
      }
      return ticks.map(function(tick) {
        return {
          coordinates: [
            { x: startX, y: tick.coord },
            { x: endX, y: tick.coord }
          ]
        };
      });
    };
    YAxisView2.prototype.createTickTexts = function(ticks, bounding, styles2) {
      var yAxis = this.getWidget().getPane().getAxisComponent();
      var axisLineStyles = styles2.axisLine;
      var tickLineStyles = styles2.tickLine;
      var tickTextStyles = styles2.tickText;
      var x = 0;
      if (yAxis.isFromZero()) {
        x = tickTextStyles.marginStart;
        if (axisLineStyles.show) {
          x += axisLineStyles.size;
        }
        if (tickLineStyles.show) {
          x += tickLineStyles.length;
        }
      } else {
        x = bounding.width - tickTextStyles.marginEnd;
        if (axisLineStyles.show) {
          x -= axisLineStyles.size;
        }
        if (tickLineStyles.show) {
          x -= tickLineStyles.length;
        }
      }
      var textAlign = this.getWidget().getPane().getAxisComponent().isFromZero() ? "left" : "right";
      return ticks.map(function(tick) {
        return {
          x,
          y: tick.coord,
          text: tick.text,
          align: textAlign,
          baseline: "middle"
        };
      });
    };
    return YAxisView2;
  }(AxisView)
);
var CandleLastPriceLabelView = (
  /** @class */
  function(_super) {
    __extends(CandleLastPriceLabelView2, _super);
    function CandleLastPriceLabelView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CandleLastPriceLabelView2.prototype.drawImp = function(ctx) {
      var _this = this;
      var _a, _b, _c, _d;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var bounding = widget.getBounding();
      var chartStore = pane.getChart().getChartStore();
      var priceMarkStyles = chartStore.getStyles().candle.priceMark;
      var lastPriceMarkStyles = priceMarkStyles.last;
      var lastPriceMarkTextStyles = lastPriceMarkStyles.text;
      if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkTextStyles.show) {
        var precision = (_b = (_a = chartStore.getSymbol()) === null || _a === void 0 ? void 0 : _a.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE;
        var yAxis = pane.getAxisComponent();
        var dataList = chartStore.getDataList();
        var data_1 = dataList[dataList.length - 1];
        if (isValid(data_1)) {
          var close_1 = data_1.close, open_1 = data_1.open;
          var comparePrice = lastPriceMarkStyles.compareRule === "current_open" ? open_1 : (_d = (_c = dataList[dataList.length - 2]) === null || _c === void 0 ? void 0 : _c.close) !== null && _d !== void 0 ? _d : close_1;
          var priceY = yAxis.convertToNicePixel(close_1);
          var backgroundColor_1 = "";
          if (close_1 > comparePrice) {
            backgroundColor_1 = lastPriceMarkStyles.upColor;
          } else if (close_1 < comparePrice) {
            backgroundColor_1 = lastPriceMarkStyles.downColor;
          } else {
            backgroundColor_1 = lastPriceMarkStyles.noChangeColor;
          }
          var x_1 = 0;
          var textAlgin_1 = "left";
          if (yAxis.isFromZero()) {
            x_1 = 0;
            textAlgin_1 = "left";
          } else {
            x_1 = bounding.width;
            textAlgin_1 = "right";
          }
          var textFigures_1 = [];
          var yAxisRange = yAxis.getRange();
          var priceText = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(close_1, { range: yAxisRange }), { range: yAxisRange }), precision);
          priceText = chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(priceText));
          var paddingLeft = lastPriceMarkTextStyles.paddingLeft, paddingRight = lastPriceMarkTextStyles.paddingRight, paddingTop = lastPriceMarkTextStyles.paddingTop, paddingBottom = lastPriceMarkTextStyles.paddingBottom, size = lastPriceMarkTextStyles.size, family = lastPriceMarkTextStyles.family, weight = lastPriceMarkTextStyles.weight;
          var textWidth_1 = paddingLeft + calcTextWidth(priceText, size, weight, family) + paddingRight;
          var priceTextHeight = paddingTop + size + paddingBottom;
          textFigures_1.push({
            name: "text",
            attrs: {
              x: x_1,
              y: priceY,
              width: textWidth_1,
              height: priceTextHeight,
              text: priceText,
              align: textAlgin_1,
              baseline: "middle"
            },
            styles: __assign(__assign({}, lastPriceMarkTextStyles), { backgroundColor: backgroundColor_1 })
          });
          var formatExtendText_1 = chartStore.getInnerFormatter().formatExtendText;
          var priceTextHalfHeight = size / 2;
          var aboveY_1 = priceY - priceTextHalfHeight - paddingTop;
          var belowY_1 = priceY + priceTextHalfHeight + paddingBottom;
          lastPriceMarkStyles.extendTexts.forEach(function(item, index) {
            var text2 = formatExtendText_1({ type: "last_price", data: data_1, index });
            if (text2.length > 0 && item.show) {
              var textHalfHeight = item.size / 2;
              var textY = 0;
              if (item.position === "above_price") {
                aboveY_1 -= item.paddingBottom + textHalfHeight;
                textY = aboveY_1;
                aboveY_1 -= textHalfHeight + item.paddingTop;
              } else {
                belowY_1 += item.paddingTop + textHalfHeight;
                textY = belowY_1;
                belowY_1 += textHalfHeight + item.paddingBottom;
              }
              textWidth_1 = Math.max(textWidth_1, item.paddingLeft + calcTextWidth(text2, item.size, item.weight, item.family) + item.paddingRight);
              textFigures_1.push({
                name: "text",
                attrs: {
                  x: x_1,
                  y: textY,
                  width: textWidth_1,
                  height: item.paddingTop + item.size + item.paddingBottom,
                  text: text2,
                  align: textAlgin_1,
                  baseline: "middle"
                },
                styles: __assign(__assign({}, item), { backgroundColor: backgroundColor_1 })
              });
            }
          });
          textFigures_1.forEach(function(figure) {
            var _a2;
            figure.attrs.width = textWidth_1;
            (_a2 = _this.createFigure(figure)) === null || _a2 === void 0 ? void 0 : _a2.draw(ctx);
          });
        }
      }
    };
    return CandleLastPriceLabelView2;
  }(View)
);
var IndicatorLastValueView = (
  /** @class */
  function(_super) {
    __extends(IndicatorLastValueView2, _super);
    function IndicatorLastValueView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IndicatorLastValueView2.prototype.drawImp = function(ctx) {
      var _this = this;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var bounding = widget.getBounding();
      var chartStore = pane.getChart().getChartStore();
      var defaultStyles = chartStore.getStyles().indicator;
      var lastValueMarkStyles = defaultStyles.lastValueMark;
      var lastValueMarkTextStyles = lastValueMarkStyles.text;
      if (lastValueMarkStyles.show) {
        var yAxis_1 = pane.getAxisComponent();
        var yAxisRange_1 = yAxis_1.getRange();
        var dataList = chartStore.getDataList();
        var dataIndex_1 = dataList.length - 1;
        var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
        var formatter_1 = chartStore.getInnerFormatter();
        var decimalFold_1 = chartStore.getDecimalFold();
        var thousandsSeparator_1 = chartStore.getThousandsSeparator();
        indicators2.forEach(function(indicator) {
          var _a;
          var result = indicator.result;
          var data = (_a = result[dataIndex_1]) !== null && _a !== void 0 ? _a : {};
          if (isValid(data) && indicator.visible) {
            var precision_1 = indicator.precision;
            eachFigures(indicator, dataIndex_1, defaultStyles, function(figure, figureStyles) {
              var _a2;
              var value = data[figure.key];
              if (isNumber(value)) {
                var y = yAxis_1.convertToNicePixel(value);
                var text2 = yAxis_1.displayValueToText(yAxis_1.realValueToDisplayValue(yAxis_1.valueToRealValue(value, { range: yAxisRange_1 }), { range: yAxisRange_1 }), precision_1);
                if (indicator.shouldFormatBigNumber) {
                  text2 = formatter_1.formatBigNumber(text2);
                }
                text2 = decimalFold_1.format(thousandsSeparator_1.format(text2));
                var x = 0;
                var textAlign = "left";
                if (yAxis_1.isFromZero()) {
                  x = 0;
                  textAlign = "left";
                } else {
                  x = bounding.width;
                  textAlign = "right";
                }
                (_a2 = _this.createFigure({
                  name: "text",
                  attrs: {
                    x,
                    y,
                    text: text2,
                    align: textAlign,
                    baseline: "middle"
                  },
                  styles: __assign(__assign({}, lastValueMarkTextStyles), { backgroundColor: figureStyles.color })
                })) === null || _a2 === void 0 ? void 0 : _a2.draw(ctx);
              }
            });
          }
        });
      }
    };
    return IndicatorLastValueView2;
  }(View)
);
var OverlayYAxisView = (
  /** @class */
  function(_super) {
    __extends(OverlayYAxisView2, _super);
    function OverlayYAxisView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    OverlayYAxisView2.prototype.coordinateToPointTimestampDataIndexFlag = function() {
      return false;
    };
    OverlayYAxisView2.prototype.drawDefaultFigures = function(ctx, overlay, coordinates) {
      this.drawFigures(ctx, overlay, this.getDefaultFigures(overlay, coordinates));
    };
    OverlayYAxisView2.prototype.getDefaultFigures = function(overlay, coordinates) {
      var _a;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = pane.getChart().getChartStore();
      var clickOverlayInfo = chartStore.getClickOverlayInfo();
      var figures2 = [];
      if (overlay.needDefaultYAxisFigure && overlay.id === ((_a = clickOverlayInfo.overlay) === null || _a === void 0 ? void 0 : _a.id) && clickOverlayInfo.paneId === pane.getId()) {
        var yAxis = pane.getAxisComponent();
        var bounding = widget.getBounding();
        var topY_1 = Number.MAX_SAFE_INTEGER;
        var bottomY_1 = Number.MIN_SAFE_INTEGER;
        var isFromZero = yAxis.isFromZero();
        var textAlign_1 = "left";
        var x_1 = 0;
        if (isFromZero) {
          textAlign_1 = "left";
          x_1 = 0;
        } else {
          textAlign_1 = "right";
          x_1 = bounding.width;
        }
        var decimalFold_1 = chartStore.getDecimalFold();
        var thousandsSeparator_1 = chartStore.getThousandsSeparator();
        coordinates.forEach(function(coordinate, index) {
          var _a2, _b;
          var point = overlay.points[index];
          if (isNumber(point.value)) {
            topY_1 = Math.min(topY_1, coordinate.y);
            bottomY_1 = Math.max(bottomY_1, coordinate.y);
            var text2 = decimalFold_1.format(thousandsSeparator_1.format(formatPrecision(point.value, (_b = (_a2 = chartStore.getSymbol()) === null || _a2 === void 0 ? void 0 : _a2.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE)));
            figures2.push({ type: "text", attrs: { x: x_1, y: coordinate.y, text: text2, align: textAlign_1, baseline: "middle" }, ignoreEvent: true });
          }
        });
        if (coordinates.length > 1) {
          figures2.unshift({ type: "rect", attrs: { x: 0, y: topY_1, width: bounding.width, height: bottomY_1 - topY_1 }, ignoreEvent: true });
        }
      }
      return figures2;
    };
    OverlayYAxisView2.prototype.getFigures = function(overlay, coordinates) {
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chart = pane.getChart();
      var yAxis = pane.getAxisComponent();
      var xAxis = chart.getXAxisPane().getAxisComponent();
      var bounding = widget.getBounding();
      return (_b = (_a = overlay.createYAxisFigures) === null || _a === void 0 ? void 0 : _a.call(overlay, { chart, overlay, coordinates, bounding, xAxis, yAxis })) !== null && _b !== void 0 ? _b : [];
    };
    return OverlayYAxisView2;
  }(OverlayView)
);
var CrosshairHorizontalLabelView = (
  /** @class */
  function(_super) {
    __extends(CrosshairHorizontalLabelView2, _super);
    function CrosshairHorizontalLabelView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairHorizontalLabelView2.prototype.drawImp = function(ctx) {
      var _a;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = widget.getPane().getChart().getChartStore();
      var crosshair = chartStore.getCrosshair();
      if (isString(crosshair.paneId) && this.compare(crosshair, pane.getId())) {
        var styles2 = chartStore.getStyles().crosshair;
        if (styles2.show) {
          var directionStyles = this.getDirectionStyles(styles2);
          var textStyles = directionStyles.text;
          if (directionStyles.show && textStyles.show) {
            var bounding = widget.getBounding();
            var axis = pane.getAxisComponent();
            var text2 = this.getText(crosshair, chartStore, axis);
            ctx.font = createFont(textStyles.size, textStyles.weight, textStyles.family);
            (_a = this.createFigure({
              name: "text",
              attrs: this.getTextAttrs(text2, ctx.measureText(text2).width, crosshair, bounding, axis, textStyles),
              styles: textStyles
            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
          }
        }
      }
    };
    CrosshairHorizontalLabelView2.prototype.compare = function(crosshair, paneId) {
      return crosshair.paneId === paneId;
    };
    CrosshairHorizontalLabelView2.prototype.getDirectionStyles = function(styles2) {
      return styles2.horizontal;
    };
    CrosshairHorizontalLabelView2.prototype.getText = function(crosshair, chartStore, axis) {
      var _a, _b;
      var yAxis = axis;
      var value = axis.convertFromPixel(crosshair.y);
      var precision = 0;
      var shouldFormatBigNumber = false;
      if (yAxis.isInCandle()) {
        precision = (_b = (_a = chartStore.getSymbol()) === null || _a === void 0 ? void 0 : _a.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE;
      } else {
        var indicators2 = chartStore.getIndicatorsByPaneId(crosshair.paneId);
        indicators2.forEach(function(indicator) {
          precision = Math.max(indicator.precision, precision);
          shouldFormatBigNumber || (shouldFormatBigNumber = indicator.shouldFormatBigNumber);
        });
      }
      var yAxisRange = yAxis.getRange();
      var text2 = yAxis.displayValueToText(yAxis.realValueToDisplayValue(yAxis.valueToRealValue(value, { range: yAxisRange }), { range: yAxisRange }), precision);
      if (shouldFormatBigNumber) {
        text2 = chartStore.getInnerFormatter().formatBigNumber(text2);
      }
      return chartStore.getDecimalFold().format(chartStore.getThousandsSeparator().format(text2));
    };
    CrosshairHorizontalLabelView2.prototype.getTextAttrs = function(text2, _textWidth, crosshair, bounding, axis, _styles) {
      var yAxis = axis;
      var x = 0;
      var textAlign = "left";
      if (yAxis.isFromZero()) {
        x = 0;
        textAlign = "left";
      } else {
        x = bounding.width;
        textAlign = "right";
      }
      return { x, y: crosshair.y, text: text2, align: textAlign, baseline: "middle" };
    };
    return CrosshairHorizontalLabelView2;
  }(View)
);
var YAxisWidget = (
  /** @class */
  function(_super) {
    __extends(YAxisWidget2, _super);
    function YAxisWidget2(rootContainer, pane) {
      var _this = _super.call(this, rootContainer, pane) || this;
      _this._yAxisView = new YAxisView(_this);
      _this._candleLastPriceLabelView = new CandleLastPriceLabelView(_this);
      _this._indicatorLastValueView = new IndicatorLastValueView(_this);
      _this._overlayYAxisView = new OverlayYAxisView(_this);
      _this._crosshairHorizontalLabelView = new CrosshairHorizontalLabelView(_this);
      _this.setCursor("ns-resize");
      _this.addChild(_this._overlayYAxisView);
      return _this;
    }
    YAxisWidget2.prototype.getName = function() {
      return WidgetNameConstants.Y_AXIS;
    };
    YAxisWidget2.prototype.updateMain = function(ctx) {
      var minimize = this.getPane().getOptions().state === "minimize";
      this._yAxisView.draw(ctx, minimize);
      if (!minimize) {
        if (this.getPane().getAxisComponent().isInCandle()) {
          this._candleLastPriceLabelView.draw(ctx);
        }
        this._indicatorLastValueView.draw(ctx);
      }
    };
    YAxisWidget2.prototype.updateOverlay = function(ctx) {
      if (this.getPane().getOptions().state !== "minimize") {
        this._overlayYAxisView.draw(ctx);
        this._crosshairHorizontalLabelView.draw(ctx);
      }
    };
    return YAxisWidget2;
  }(DrawWidget)
);
function getDefaultAxisRange() {
  return {
    from: 0,
    to: 0,
    range: 0,
    realFrom: 0,
    realTo: 0,
    realRange: 0,
    displayFrom: 0,
    displayTo: 0,
    displayRange: 0
  };
}
var AxisImp = (
  /** @class */
  function() {
    function AxisImp2(parent) {
      this.scrollZoomEnabled = true;
      this._range = getDefaultAxisRange();
      this._prevRange = getDefaultAxisRange();
      this._ticks = [];
      this._autoCalcTickFlag = true;
      this._parent = parent;
    }
    AxisImp2.prototype.getParent = function() {
      return this._parent;
    };
    AxisImp2.prototype.buildTicks = function(force) {
      if (this._autoCalcTickFlag) {
        this._range = this.createRangeImp();
      }
      if (this._prevRange.from !== this._range.from || this._prevRange.to !== this._range.to || force) {
        this._prevRange = this._range;
        this._ticks = this.createTicksImp();
        return true;
      }
      return false;
    };
    AxisImp2.prototype.getTicks = function() {
      return this._ticks;
    };
    AxisImp2.prototype.setRange = function(range) {
      this._autoCalcTickFlag = false;
      this._range = range;
    };
    AxisImp2.prototype.getRange = function() {
      return this._range;
    };
    AxisImp2.prototype.setAutoCalcTickFlag = function(flag) {
      this._autoCalcTickFlag = flag;
    };
    AxisImp2.prototype.getAutoCalcTickFlag = function() {
      return this._autoCalcTickFlag;
    };
    return AxisImp2;
  }()
);
var TICK_COUNT = 8;
var YAxisImp = (
  /** @class */
  function(_super) {
    __extends(YAxisImp2, _super);
    function YAxisImp2(parent, yAxis) {
      var _this = _super.call(this, parent) || this;
      _this.reverse = false;
      _this.inside = false;
      _this.position = "right";
      _this.gap = {
        top: 0.2,
        bottom: 0.1
      };
      _this.createRange = function(params) {
        return params.defaultRange;
      };
      _this.minSpan = function(precision) {
        return index10(-precision);
      };
      _this.valueToRealValue = function(value) {
        return value;
      };
      _this.realValueToDisplayValue = function(value) {
        return value;
      };
      _this.displayValueToRealValue = function(value) {
        return value;
      };
      _this.realValueToValue = function(value) {
        return value;
      };
      _this.displayValueToText = function(value, precision) {
        return formatPrecision(value, precision);
      };
      _this.override(yAxis);
      return _this;
    }
    YAxisImp2.prototype.override = function(yAxis) {
      var name = yAxis.name, gap = yAxis.gap, others = __rest(yAxis, ["name", "gap"]);
      if (!isString(this.name)) {
        this.name = name;
      }
      merge(this.gap, gap);
      merge(this, others);
    };
    YAxisImp2.prototype.createRangeImp = function() {
      var _a, _b;
      var parent = this.getParent();
      var chart = parent.getChart();
      var chartStore = chart.getChartStore();
      var paneId = parent.getId();
      var min = Number.MAX_SAFE_INTEGER;
      var max = Number.MIN_SAFE_INTEGER;
      var shouldOhlc = false;
      var specifyMin = Number.MAX_SAFE_INTEGER;
      var specifyMax = Number.MIN_SAFE_INTEGER;
      var indicatorPrecision = Number.MAX_SAFE_INTEGER;
      var indicators2 = chartStore.getIndicatorsByPaneId(paneId);
      indicators2.forEach(function(indicator) {
        shouldOhlc || (shouldOhlc = indicator.shouldOhlc);
        indicatorPrecision = Math.min(indicatorPrecision, indicator.precision);
        if (isNumber(indicator.minValue)) {
          specifyMin = Math.min(specifyMin, indicator.minValue);
        }
        if (isNumber(indicator.maxValue)) {
          specifyMax = Math.max(specifyMax, indicator.maxValue);
        }
      });
      var precision = 4;
      var inCandle = this.isInCandle();
      if (inCandle) {
        var pricePrecision = (_b = (_a = chartStore.getSymbol()) === null || _a === void 0 ? void 0 : _a.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE;
        if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {
          precision = Math.min(indicatorPrecision, pricePrecision);
        } else {
          precision = pricePrecision;
        }
      } else {
        if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {
          precision = indicatorPrecision;
        }
      }
      var visibleRangeDataList = chartStore.getVisibleRangeDataList();
      var candleStyles = chart.getStyles().candle;
      var isArea = candleStyles.type === "area";
      var areaValueKey = candleStyles.area.value;
      var shouldCompareHighLow = inCandle && !isArea || !inCandle && shouldOhlc;
      visibleRangeDataList.forEach(function(visibleData) {
        var dataIndex = visibleData.dataIndex;
        var data = visibleData.data.current;
        if (isValid(data)) {
          if (shouldCompareHighLow) {
            min = Math.min(min, data.low);
            max = Math.max(max, data.high);
          }
          if (inCandle && isArea) {
            var value = data[areaValueKey];
            if (isNumber(value)) {
              min = Math.min(min, value);
              max = Math.max(max, value);
            }
          }
        }
        indicators2.forEach(function(_a2) {
          var _b2;
          var result = _a2.result, figures2 = _a2.figures;
          var data2 = (_b2 = result[dataIndex]) !== null && _b2 !== void 0 ? _b2 : {};
          figures2.forEach(function(figure) {
            var value2 = data2[figure.key];
            if (isNumber(value2)) {
              min = Math.min(min, value2);
              max = Math.max(max, value2);
            }
          });
        });
      });
      if (min !== Number.MAX_SAFE_INTEGER && max !== Number.MIN_SAFE_INTEGER) {
        min = Math.min(specifyMin, min);
        max = Math.max(specifyMax, max);
      } else {
        min = 0;
        max = 10;
      }
      var defaultDiff = max - min;
      var defaultRange = {
        from: min,
        to: max,
        range: defaultDiff,
        realFrom: min,
        realTo: max,
        realRange: defaultDiff,
        displayFrom: min,
        displayTo: max,
        displayRange: defaultDiff
      };
      var range = this.createRange({
        chart,
        paneId,
        defaultRange
      });
      var realFrom = range.realFrom;
      var realTo = range.realTo;
      var realRange = range.realRange;
      var minSpan = this.minSpan(precision);
      if (realFrom === realTo || realRange < minSpan) {
        var minCheck = specifyMin === realFrom;
        var maxCheck = specifyMax === realTo;
        var halfTickCount = TICK_COUNT / 2;
        realFrom = minCheck ? realFrom : maxCheck ? realFrom - TICK_COUNT * minSpan : realFrom - halfTickCount * minSpan;
        realTo = maxCheck ? realTo : minCheck ? realTo + TICK_COUNT * minSpan : realTo + halfTickCount * minSpan;
      }
      var height = this.getBounding().height;
      var _c = this.gap, top = _c.top, bottom = _c.bottom;
      var topRate = top;
      if (topRate >= 1) {
        topRate = topRate / height;
      }
      var bottomRate = bottom;
      if (bottomRate >= 1) {
        bottomRate = bottomRate / height;
      }
      realRange = realTo - realFrom;
      realFrom = realFrom - realRange * bottomRate;
      realTo = realTo + realRange * topRate;
      var from = this.realValueToValue(realFrom, { range });
      var to = this.realValueToValue(realTo, { range });
      var displayFrom = this.realValueToDisplayValue(realFrom, { range });
      var displayTo = this.realValueToDisplayValue(realTo, { range });
      return {
        from,
        to,
        range: to - from,
        realFrom,
        realTo,
        realRange: realTo - realFrom,
        displayFrom,
        displayTo,
        displayRange: displayTo - displayFrom
      };
    };
    YAxisImp2.prototype.isInCandle = function() {
      return this.getParent().getId() === PaneIdConstants.CANDLE;
    };
    YAxisImp2.prototype.isFromZero = function() {
      return this.position === "left" && this.inside || this.position === "right" && !this.inside;
    };
    YAxisImp2.prototype.createTicksImp = function() {
      var _this = this;
      var _a, _b, _c, _d;
      var range = this.getRange();
      var displayFrom = range.displayFrom, displayTo = range.displayTo, displayRange = range.displayRange;
      var ticks = [];
      if (displayRange >= 0) {
        var interval = nice(displayRange / TICK_COUNT);
        var precision_1 = getPrecision(interval);
        var first = round(Math.ceil(displayFrom / interval) * interval, precision_1);
        var last = round(Math.floor(displayTo / interval) * interval, precision_1);
        var n = 0;
        var f = first;
        if (interval !== 0) {
          while (f <= last) {
            var v = f.toFixed(precision_1);
            ticks[n] = { text: v, coord: 0, value: v };
            ++n;
            f += interval;
          }
        }
      }
      var pane = this.getParent();
      var height = (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
      var chartStore = pane.getChart().getChartStore();
      var optimalTicks = [];
      var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
      var styles2 = chartStore.getStyles();
      var precision = 0;
      var shouldFormatBigNumber = false;
      if (this.isInCandle()) {
        precision = (_d = (_c = chartStore.getSymbol()) === null || _c === void 0 ? void 0 : _c.pricePrecision) !== null && _d !== void 0 ? _d : SymbolDefaultPrecisionConstants.PRICE;
      } else {
        indicators2.forEach(function(indicator) {
          precision = Math.max(precision, indicator.precision);
          shouldFormatBigNumber || (shouldFormatBigNumber = indicator.shouldFormatBigNumber);
        });
      }
      var formatter = chartStore.getInnerFormatter();
      var thousandsSeparator = chartStore.getThousandsSeparator();
      var decimalFold = chartStore.getDecimalFold();
      var textHeight = styles2.xAxis.tickText.size;
      var validY = NaN;
      ticks.forEach(function(_a2) {
        var value = _a2.value;
        var v2 = _this.displayValueToText(+value, precision);
        var y = _this.convertToPixel(_this.realValueToValue(_this.displayValueToRealValue(+value, { range }), { range }));
        if (shouldFormatBigNumber) {
          v2 = formatter.formatBigNumber(value);
        }
        v2 = decimalFold.format(thousandsSeparator.format(v2));
        var validYNumber = isNumber(validY);
        if (y > textHeight && y < height - textHeight && (validYNumber && Math.abs(validY - y) > textHeight * 2 || !validYNumber)) {
          optimalTicks.push({ text: v2, coord: y, value });
          validY = y;
        }
      });
      if (isFunction(this.createTicks)) {
        return this.createTicks({
          range: this.getRange(),
          bounding: this.getBounding(),
          defaultTicks: optimalTicks
        });
      }
      return optimalTicks;
    };
    YAxisImp2.prototype.getAutoSize = function() {
      var _a, _b;
      var pane = this.getParent();
      var chart = pane.getChart();
      var chartStore = chart.getChartStore();
      var styles2 = chartStore.getStyles();
      var yAxisStyles = styles2.yAxis;
      var width = yAxisStyles.size;
      if (width !== "auto") {
        return width;
      }
      var yAxisWidth = 0;
      if (yAxisStyles.show) {
        if (yAxisStyles.axisLine.show) {
          yAxisWidth += yAxisStyles.axisLine.size;
        }
        if (yAxisStyles.tickLine.show) {
          yAxisWidth += yAxisStyles.tickLine.length;
        }
        if (yAxisStyles.tickText.show) {
          var textWidth_1 = 0;
          this.getTicks().forEach(function(tick) {
            textWidth_1 = Math.max(textWidth_1, calcTextWidth(tick.text, yAxisStyles.tickText.size, yAxisStyles.tickText.weight, yAxisStyles.tickText.family));
          });
          yAxisWidth += yAxisStyles.tickText.marginStart + yAxisStyles.tickText.marginEnd + textWidth_1;
        }
      }
      var priceMarkStyles = styles2.candle.priceMark;
      var lastPriceMarkTextVisible = priceMarkStyles.show && priceMarkStyles.last.show && priceMarkStyles.last.text.show;
      var lastPriceTextWidth = 0;
      var crosshairStyles = styles2.crosshair;
      var crosshairHorizontalTextVisible = crosshairStyles.show && crosshairStyles.horizontal.show && crosshairStyles.horizontal.text.show;
      var crosshairHorizontalTextWidth = 0;
      if (lastPriceMarkTextVisible || crosshairHorizontalTextVisible) {
        var pricePrecision = (_b = (_a = chartStore.getSymbol()) === null || _a === void 0 ? void 0 : _a.pricePrecision) !== null && _b !== void 0 ? _b : SymbolDefaultPrecisionConstants.PRICE;
        var max = this.getRange().displayTo;
        if (lastPriceMarkTextVisible) {
          var dataList = chartStore.getDataList();
          var data_1 = dataList[dataList.length - 1];
          if (isValid(data_1)) {
            var _c = priceMarkStyles.last.text, paddingLeft = _c.paddingLeft, paddingRight = _c.paddingRight, size = _c.size, family = _c.family, weight = _c.weight;
            lastPriceTextWidth = paddingLeft + calcTextWidth(formatPrecision(data_1.close, pricePrecision), size, weight, family) + paddingRight;
            var formatExtendText_1 = chartStore.getInnerFormatter().formatExtendText;
            priceMarkStyles.last.extendTexts.forEach(function(item, index) {
              var text2 = formatExtendText_1({ type: "last_price", data: data_1, index });
              if (text2.length > 0 && item.show) {
                lastPriceTextWidth = Math.max(lastPriceTextWidth, item.paddingLeft + calcTextWidth(text2, item.size, item.weight, item.family) + item.paddingRight);
              }
            });
          }
        }
        if (crosshairHorizontalTextVisible) {
          var indicators2 = chartStore.getIndicatorsByPaneId(pane.getId());
          var indicatorPrecision_1 = 0;
          var shouldFormatBigNumber_1 = false;
          indicators2.forEach(function(indicator) {
            indicatorPrecision_1 = Math.max(indicator.precision, indicatorPrecision_1);
            shouldFormatBigNumber_1 || (shouldFormatBigNumber_1 = indicator.shouldFormatBigNumber);
          });
          var precision = 2;
          if (this.isInCandle()) {
            var lastValueMarkStyles = styles2.indicator.lastValueMark;
            if (lastValueMarkStyles.show && lastValueMarkStyles.text.show) {
              precision = Math.max(indicatorPrecision_1, pricePrecision);
            } else {
              precision = pricePrecision;
            }
          } else {
            precision = indicatorPrecision_1;
          }
          var valueText = formatPrecision(max, precision);
          if (shouldFormatBigNumber_1) {
            valueText = chartStore.getInnerFormatter().formatBigNumber(valueText);
          }
          valueText = chartStore.getDecimalFold().format(valueText);
          crosshairHorizontalTextWidth += crosshairStyles.horizontal.text.paddingLeft + crosshairStyles.horizontal.text.paddingRight + crosshairStyles.horizontal.text.borderSize * 2 + calcTextWidth(valueText, crosshairStyles.horizontal.text.size, crosshairStyles.horizontal.text.weight, crosshairStyles.horizontal.text.family);
        }
      }
      return Math.max(yAxisWidth, lastPriceTextWidth, crosshairHorizontalTextWidth);
    };
    YAxisImp2.prototype.getBounding = function() {
      return this.getParent().getYAxisWidget().getBounding();
    };
    YAxisImp2.prototype.convertFromPixel = function(pixel) {
      var height = this.getBounding().height;
      var range = this.getRange();
      var realFrom = range.realFrom, realRange = range.realRange;
      var rate = this.reverse ? pixel / height : 1 - pixel / height;
      var realValue = rate * realRange + realFrom;
      return this.realValueToValue(realValue, { range });
    };
    YAxisImp2.prototype.convertToPixel = function(value) {
      var _a, _b;
      var range = this.getRange();
      var realValue = this.valueToRealValue(value, { range });
      var height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
      var realFrom = range.realFrom, realRange = range.realRange;
      var rate = (realValue - realFrom) / realRange;
      return this.reverse ? Math.round(rate * height) : Math.round((1 - rate) * height);
    };
    YAxisImp2.prototype.convertToNicePixel = function(value) {
      var _a, _b;
      var height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
      var pixel = this.convertToPixel(value);
      return Math.round(Math.max(height * 0.05, Math.min(pixel, height * 0.98)));
    };
    YAxisImp2.extend = function(template) {
      var Custom = (
        /** @class */
        function(_super2) {
          __extends(Custom2, _super2);
          function Custom2(parent) {
            return _super2.call(this, parent, template) || this;
          }
          return Custom2;
        }(YAxisImp2)
      );
      return Custom;
    };
    return YAxisImp2;
  }(AxisImp)
);
var normal$1 = {
  name: "normal"
};
var percentage = {
  name: "percentage",
  minSpan: function() {
    return Math.pow(10, -2);
  },
  displayValueToText: function(value) {
    return "".concat(formatPrecision(value, 2), "%");
  },
  valueToRealValue: function(value, _a) {
    var range = _a.range;
    return (value - range.from) / range.range * range.realRange + range.realFrom;
  },
  realValueToValue: function(value, _a) {
    var range = _a.range;
    return (value - range.realFrom) / range.realRange * range.range + range.from;
  },
  createRange: function(_a) {
    var chart = _a.chart, defaultRange = _a.defaultRange;
    var kLineDataList = chart.getDataList();
    var visibleRange = chart.getVisibleRange();
    var kLineData = kLineDataList[visibleRange.from];
    if (isValid(kLineData)) {
      var from = defaultRange.from, to = defaultRange.to, range = defaultRange.range;
      var realFrom = (defaultRange.from - kLineData.close) / kLineData.close * 100;
      var realTo = (defaultRange.to - kLineData.close) / kLineData.close * 100;
      var realRange = realTo - realFrom;
      return {
        from,
        to,
        range,
        realFrom,
        realTo,
        realRange,
        displayFrom: realFrom,
        displayTo: realTo,
        displayRange: realRange
      };
    }
    return defaultRange;
  }
};
var logarithm = {
  name: "logarithm",
  minSpan: function(precision) {
    return 0.05 * index10(-precision);
  },
  valueToRealValue: function(value) {
    return value < 0 ? -log10(Math.abs(value)) : log10(value);
  },
  realValueToDisplayValue: function(value) {
    return value < 0 ? -index10(Math.abs(value)) : index10(value);
  },
  displayValueToRealValue: function(value) {
    return value < 0 ? -log10(Math.abs(value)) : log10(value);
  },
  realValueToValue: function(value) {
    return value < 0 ? -index10(Math.abs(value)) : index10(value);
  },
  createRange: function(_a) {
    var defaultRange = _a.defaultRange;
    var from = defaultRange.from, to = defaultRange.to, range = defaultRange.range;
    var realFrom = from < 0 ? -log10(Math.abs(from)) : log10(from);
    var realTo = to < 0 ? -log10(Math.abs(to)) : log10(to);
    return {
      from,
      to,
      range,
      realFrom,
      realTo,
      realRange: realTo - realFrom,
      displayFrom: from,
      displayTo: to,
      displayRange: range
    };
  }
};
var yAxises = {
  normal: YAxisImp.extend(normal$1),
  percentage: YAxisImp.extend(percentage),
  logarithm: YAxisImp.extend(logarithm)
};
function registerYAxis(axis) {
  yAxises[axis.name] = YAxisImp.extend(axis);
}
function getYAxisClass(name) {
  var _a;
  return (_a = yAxises[name]) !== null && _a !== void 0 ? _a : yAxises.normal;
}
var Pane = (
  /** @class */
  function() {
    function Pane2(chart, id) {
      this._bounding = createDefaultBounding();
      this._originalBounding = createDefaultBounding();
      this._visible = true;
      this._chart = chart;
      this._id = id;
      this._container = createDom("div", {
        width: "100%",
        margin: "0",
        padding: "0",
        position: "relative",
        overflow: "hidden",
        boxSizing: "border-box"
      });
    }
    Pane2.prototype.getContainer = function() {
      return this._container;
    };
    Pane2.prototype.setVisible = function(visible) {
      if (this._visible !== visible) {
        this._container.style.display = visible ? "block" : "none";
        this._visible = visible;
      }
    };
    Pane2.prototype.getVisible = function() {
      return this._visible;
    };
    Pane2.prototype.getId = function() {
      return this._id;
    };
    Pane2.prototype.getChart = function() {
      return this._chart;
    };
    Pane2.prototype.getBounding = function() {
      return this._bounding;
    };
    Pane2.prototype.setOriginalBounding = function(bounding) {
      merge(this._originalBounding, bounding);
    };
    Pane2.prototype.getOriginalBounding = function() {
      return this._originalBounding;
    };
    Pane2.prototype.update = function(level) {
      if (this._bounding.height !== this._container.clientHeight) {
        this._container.style.height = "".concat(this._bounding.height, "px");
      }
      this.updateImp(level !== null && level !== void 0 ? level : 3, this._container, this._bounding);
    };
    return Pane2;
  }()
);
var DrawPane = (
  /** @class */
  function(_super) {
    __extends(DrawPane2, _super);
    function DrawPane2(chart, id, options) {
      var _this = _super.call(this, chart, id) || this;
      _this._yAxisWidget = null;
      _this._options = {
        id: "",
        minHeight: PANE_MIN_HEIGHT,
        dragEnabled: true,
        order: 0,
        height: PANE_DEFAULT_HEIGHT,
        state: "normal",
        axis: { name: "normal", scrollZoomEnabled: true }
      };
      var container = _this.getContainer();
      _this._mainWidget = _this.createMainWidget(container);
      _this._yAxisWidget = _this.createYAxisWidget(container);
      _this.setOptions(options);
      return _this;
    }
    DrawPane2.prototype.setOptions = function(options) {
      var _a, _b, _c, _d, _e;
      var paneId = this.getId();
      if (paneId === PaneIdConstants.CANDLE || paneId === PaneIdConstants.X_AXIS) {
        var axisName = (_a = options.axis) === null || _a === void 0 ? void 0 : _a.name;
        if (!isValid(this._axis) || isValid(axisName) && this._options.axis.name !== axisName) {
          this._axis = this.createAxisComponent(axisName !== null && axisName !== void 0 ? axisName : "normal");
        }
      } else {
        if (!isValid(this._axis)) {
          this._axis = this.createAxisComponent("normal");
        }
      }
      if (this._axis instanceof YAxisImp) {
        this._axis.setAutoCalcTickFlag(true);
      }
      merge(this._options, options);
      this._axis.override(__assign(__assign({}, this._options.axis), { name: (_c = (_b = options.axis) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : "normal" }));
      var container = null;
      var cursor = "default";
      if (this.getId() === PaneIdConstants.X_AXIS) {
        container = this.getMainWidget().getContainer();
        cursor = "ew-resize";
      } else {
        container = this.getYAxisWidget().getContainer();
        cursor = "ns-resize";
      }
      if ((_e = (_d = options.axis) === null || _d === void 0 ? void 0 : _d.scrollZoomEnabled) !== null && _e !== void 0 ? _e : true) {
        container.style.cursor = cursor;
      } else {
        container.style.cursor = "default";
      }
      return this;
    };
    DrawPane2.prototype.getOptions = function() {
      return this._options;
    };
    DrawPane2.prototype.getAxisComponent = function() {
      return this._axis;
    };
    DrawPane2.prototype.setBounding = function(rootBounding, mainBounding, leftYAxisBounding, rightYAxisBounding) {
      var _a, _b, _c, _d;
      merge(this.getBounding(), rootBounding);
      var contentBounding = {};
      if (isValid(rootBounding.height)) {
        contentBounding.height = rootBounding.height;
      }
      if (isValid(rootBounding.top)) {
        contentBounding.top = rootBounding.top;
      }
      this._mainWidget.setBounding(contentBounding);
      var mainBoundingValid = isValid(mainBounding);
      if (mainBoundingValid) {
        this._mainWidget.setBounding(mainBounding);
      }
      if (isValid(this._yAxisWidget)) {
        this._yAxisWidget.setBounding(contentBounding);
        var yAxis = this._axis;
        if (yAxis.position === "left") {
          if (isValid(leftYAxisBounding)) {
            this._yAxisWidget.setBounding(__assign(__assign({}, leftYAxisBounding), { left: 0 }));
          }
        } else {
          if (isValid(rightYAxisBounding)) {
            this._yAxisWidget.setBounding(rightYAxisBounding);
            if (mainBoundingValid) {
              this._yAxisWidget.setBounding({
                left: ((_a = mainBounding.left) !== null && _a !== void 0 ? _a : 0) + ((_b = mainBounding.width) !== null && _b !== void 0 ? _b : 0) + ((_c = mainBounding.right) !== null && _c !== void 0 ? _c : 0) - ((_d = rightYAxisBounding.width) !== null && _d !== void 0 ? _d : 0)
              });
            }
          }
        }
      }
      return this;
    };
    DrawPane2.prototype.getMainWidget = function() {
      return this._mainWidget;
    };
    DrawPane2.prototype.getYAxisWidget = function() {
      return this._yAxisWidget;
    };
    DrawPane2.prototype.updateImp = function(level) {
      var _a;
      this._mainWidget.update(level);
      (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.update(level);
    };
    DrawPane2.prototype.destroy = function() {
      var _a;
      this._mainWidget.destroy();
      (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.destroy();
    };
    DrawPane2.prototype.getImage = function(includeOverlay) {
      var _a = this.getBounding(), width = _a.width, height = _a.height;
      var canvas = createDom("canvas", {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: "border-box"
      });
      var ctx = canvas.getContext("2d");
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      var mainBounding = this._mainWidget.getBounding();
      ctx.drawImage(this._mainWidget.getImage(includeOverlay), mainBounding.left, 0, mainBounding.width, mainBounding.height);
      if (this._yAxisWidget !== null) {
        var yAxisBounding = this._yAxisWidget.getBounding();
        ctx.drawImage(this._yAxisWidget.getImage(includeOverlay), yAxisBounding.left, 0, yAxisBounding.width, yAxisBounding.height);
      }
      return canvas;
    };
    DrawPane2.prototype.createYAxisWidget = function(_container) {
      return null;
    };
    return DrawPane2;
  }(Pane)
);
var IndicatorPane = (
  /** @class */
  function(_super) {
    __extends(IndicatorPane2, _super);
    function IndicatorPane2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IndicatorPane2.prototype.createAxisComponent = function(name) {
      var YAxisClass = getYAxisClass(name !== null && name !== void 0 ? name : "default");
      return new YAxisClass(this);
    };
    IndicatorPane2.prototype.createMainWidget = function(container) {
      return new IndicatorWidget(container, this);
    };
    IndicatorPane2.prototype.createYAxisWidget = function(container) {
      return new YAxisWidget(container, this);
    };
    return IndicatorPane2;
  }(DrawPane)
);
var CandlePane = (
  /** @class */
  function(_super) {
    __extends(CandlePane2, _super);
    function CandlePane2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CandlePane2.prototype.createMainWidget = function(container) {
      return new CandleWidget(container, this);
    };
    return CandlePane2;
  }(IndicatorPane)
);
var XAxisView = (
  /** @class */
  function(_super) {
    __extends(XAxisView2, _super);
    function XAxisView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    XAxisView2.prototype.getAxisStyles = function(styles2) {
      return styles2.xAxis;
    };
    XAxisView2.prototype.createAxisLine = function(bounding) {
      return {
        coordinates: [
          { x: 0, y: 0 },
          { x: bounding.width, y: 0 }
        ]
      };
    };
    XAxisView2.prototype.createTickLines = function(ticks, _bounding, styles2) {
      var tickLineStyles = styles2.tickLine;
      var axisLineSize = styles2.axisLine.size;
      return ticks.map(function(tick) {
        return {
          coordinates: [
            { x: tick.coord, y: 0 },
            { x: tick.coord, y: axisLineSize + tickLineStyles.length }
          ]
        };
      });
    };
    XAxisView2.prototype.createTickTexts = function(ticks, _bounding, styles2) {
      var tickTickStyles = styles2.tickText;
      var axisLineSize = styles2.axisLine.size;
      var tickLineLength = styles2.tickLine.length;
      return ticks.map(function(tick) {
        return {
          x: tick.coord,
          y: axisLineSize + tickLineLength + tickTickStyles.marginStart,
          text: tick.text,
          align: "center",
          baseline: "top"
        };
      });
    };
    return XAxisView2;
  }(AxisView)
);
var OverlayXAxisView = (
  /** @class */
  function(_super) {
    __extends(OverlayXAxisView2, _super);
    function OverlayXAxisView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    OverlayXAxisView2.prototype.coordinateToPointTimestampDataIndexFlag = function() {
      return true;
    };
    OverlayXAxisView2.prototype.coordinateToPointValueFlag = function() {
      return false;
    };
    OverlayXAxisView2.prototype.getCompleteOverlays = function() {
      return this.getWidget().getPane().getChart().getChartStore().getOverlaysByPaneId();
    };
    OverlayXAxisView2.prototype.getProgressOverlay = function() {
      var _a, _b;
      return (_b = (_a = this.getWidget().getPane().getChart().getChartStore().getProgressOverlayInfo()) === null || _a === void 0 ? void 0 : _a.overlay) !== null && _b !== void 0 ? _b : null;
    };
    OverlayXAxisView2.prototype.getDefaultFigures = function(overlay, coordinates) {
      var _a;
      var figures2 = [];
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chartStore = pane.getChart().getChartStore();
      var clickOverlayInfo = chartStore.getClickOverlayInfo();
      if (overlay.needDefaultXAxisFigure && overlay.id === ((_a = clickOverlayInfo.overlay) === null || _a === void 0 ? void 0 : _a.id)) {
        var leftX_1 = Number.MAX_SAFE_INTEGER;
        var rightX_1 = Number.MIN_SAFE_INTEGER;
        coordinates.forEach(function(coordinate, index) {
          leftX_1 = Math.min(leftX_1, coordinate.x);
          rightX_1 = Math.max(rightX_1, coordinate.x);
          var point = overlay.points[index];
          if (isNumber(point.timestamp)) {
            var text2 = chartStore.getInnerFormatter().formatDate(point.timestamp, "YYYY-MM-DD HH:mm", "crosshair");
            figures2.push({ type: "text", attrs: { x: coordinate.x, y: 0, text: text2, align: "center" }, ignoreEvent: true });
          }
        });
        if (coordinates.length > 1) {
          figures2.unshift({ type: "rect", attrs: { x: leftX_1, y: 0, width: rightX_1 - leftX_1, height: widget.getBounding().height }, ignoreEvent: true });
        }
      }
      return figures2;
    };
    OverlayXAxisView2.prototype.getFigures = function(o, coordinates) {
      var _a, _b;
      var widget = this.getWidget();
      var pane = widget.getPane();
      var chart = pane.getChart();
      var yAxis = pane.getAxisComponent();
      var xAxis = chart.getXAxisPane().getAxisComponent();
      var bounding = widget.getBounding();
      return (_b = (_a = o.createXAxisFigures) === null || _a === void 0 ? void 0 : _a.call(o, { chart, overlay: o, coordinates, bounding, xAxis, yAxis })) !== null && _b !== void 0 ? _b : [];
    };
    return OverlayXAxisView2;
  }(OverlayYAxisView)
);
var CrosshairVerticalLabelView = (
  /** @class */
  function(_super) {
    __extends(CrosshairVerticalLabelView2, _super);
    function CrosshairVerticalLabelView2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairVerticalLabelView2.prototype.compare = function(crosshair) {
      return isValid(crosshair.timestamp);
    };
    CrosshairVerticalLabelView2.prototype.getDirectionStyles = function(styles2) {
      return styles2.vertical;
    };
    CrosshairVerticalLabelView2.prototype.getText = function(crosshair, chartStore) {
      var _a, _b;
      var timestamp = crosshair.timestamp;
      return chartStore.getInnerFormatter().formatDate(timestamp, PeriodTypeCrosshairTooltipFormat[(_b = (_a = chartStore.getPeriod()) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : "day"], "crosshair");
    };
    CrosshairVerticalLabelView2.prototype.getTextAttrs = function(text2, textWidth, crosshair, bounding, _axis, styles2) {
      var x = crosshair.realX;
      var optimalX = 0;
      var align = "center";
      if (x - textWidth / 2 - styles2.paddingLeft < 0) {
        optimalX = 0;
        align = "left";
      } else if (x + textWidth / 2 + styles2.paddingRight > bounding.width) {
        optimalX = bounding.width;
        align = "right";
      } else {
        optimalX = x;
      }
      return { x: optimalX, y: 0, text: text2, align, baseline: "top" };
    };
    return CrosshairVerticalLabelView2;
  }(CrosshairHorizontalLabelView)
);
var XAxisWidget = (
  /** @class */
  function(_super) {
    __extends(XAxisWidget2, _super);
    function XAxisWidget2(rootContainer, pane) {
      var _this = _super.call(this, rootContainer, pane) || this;
      _this._xAxisView = new XAxisView(_this);
      _this._overlayXAxisView = new OverlayXAxisView(_this);
      _this._crosshairVerticalLabelView = new CrosshairVerticalLabelView(_this);
      _this.setCursor("ew-resize");
      _this.addChild(_this._overlayXAxisView);
      return _this;
    }
    XAxisWidget2.prototype.getName = function() {
      return WidgetNameConstants.X_AXIS;
    };
    XAxisWidget2.prototype.updateMain = function(ctx) {
      this._xAxisView.draw(ctx);
    };
    XAxisWidget2.prototype.updateOverlay = function(ctx) {
      this._overlayXAxisView.draw(ctx);
      this._crosshairVerticalLabelView.draw(ctx);
    };
    return XAxisWidget2;
  }(DrawWidget)
);
var XAxisImp = (
  /** @class */
  function(_super) {
    __extends(XAxisImp2, _super);
    function XAxisImp2(parent, xAxis) {
      var _this = _super.call(this, parent) || this;
      _this.override(xAxis);
      return _this;
    }
    XAxisImp2.prototype.override = function(xAxis) {
      var name = xAxis.name, scrollZoomEnabled = xAxis.scrollZoomEnabled, createTicks = xAxis.createTicks;
      if (!isString(this.name)) {
        this.name = name;
      }
      this.scrollZoomEnabled = scrollZoomEnabled !== null && scrollZoomEnabled !== void 0 ? scrollZoomEnabled : this.scrollZoomEnabled;
      this.createTicks = createTicks !== null && createTicks !== void 0 ? createTicks : this.createTicks;
    };
    XAxisImp2.prototype.createRangeImp = function() {
      var chartStore = this.getParent().getChart().getChartStore();
      var visibleDataRange = chartStore.getVisibleRange();
      var realFrom = visibleDataRange.realFrom, realTo = visibleDataRange.realTo;
      var af = realFrom;
      var at = realTo;
      var diff = realTo - realFrom + 1;
      var range = {
        from: af,
        to: at,
        range: diff,
        realFrom: af,
        realTo: at,
        realRange: diff,
        displayFrom: af,
        displayTo: at,
        displayRange: diff
      };
      return range;
    };
    XAxisImp2.prototype.createTicksImp = function() {
      var _a;
      var _b = this.getRange(), realFrom = _b.realFrom, realTo = _b.realTo, from = _b.from;
      var chartStore = this.getParent().getChart().getChartStore();
      var formatDate = chartStore.getInnerFormatter().formatDate;
      var period = chartStore.getPeriod();
      var ticks = [];
      var barSpace = chartStore.getBarSpace().bar;
      var textStyles = chartStore.getStyles().xAxis.tickText;
      var tickTextWidth = Math.max(calcTextWidth("YYYY-MM-DD HH:mm:ss", textStyles.size, textStyles.weight, textStyles.family), this.getBounding().width / 8);
      var tickBetweenBarCount = Math.ceil(tickTextWidth / barSpace);
      if (tickBetweenBarCount % 2 !== 0) {
        tickBetweenBarCount += 1;
      }
      var startDataIndex = Math.max(0, Math.floor(realFrom / tickBetweenBarCount) * tickBetweenBarCount);
      for (var i = startDataIndex; i < realTo; i += tickBetweenBarCount) {
        if (i >= from) {
          var timestamp = chartStore.dataIndexToTimestamp(i);
          if (isNumber(timestamp)) {
            ticks.push({
              coord: this.convertToPixel(i),
              value: timestamp,
              text: formatDate(timestamp, PeriodTypeXAxisFormat[(_a = period === null || period === void 0 ? void 0 : period.type) !== null && _a !== void 0 ? _a : "day"], "xAxis")
            });
          }
        }
      }
      if (isFunction(this.createTicks)) {
        return this.createTicks({
          range: this.getRange(),
          bounding: this.getBounding(),
          defaultTicks: ticks
        });
      }
      return ticks;
    };
    XAxisImp2.prototype.getAutoSize = function() {
      var styles2 = this.getParent().getChart().getStyles();
      var xAxisStyles = styles2.xAxis;
      var height = xAxisStyles.size;
      if (height !== "auto") {
        return height;
      }
      var crosshairStyles = styles2.crosshair;
      var xAxisHeight = 0;
      if (xAxisStyles.show) {
        if (xAxisStyles.axisLine.show) {
          xAxisHeight += xAxisStyles.axisLine.size;
        }
        if (xAxisStyles.tickLine.show) {
          xAxisHeight += xAxisStyles.tickLine.length;
        }
        if (xAxisStyles.tickText.show) {
          xAxisHeight += xAxisStyles.tickText.marginStart + xAxisStyles.tickText.marginEnd + xAxisStyles.tickText.size;
        }
      }
      var crosshairVerticalTextHeight = 0;
      if (crosshairStyles.show && crosshairStyles.vertical.show && crosshairStyles.vertical.text.show) {
        crosshairVerticalTextHeight += crosshairStyles.vertical.text.paddingTop + crosshairStyles.vertical.text.paddingBottom + crosshairStyles.vertical.text.borderSize * 2 + crosshairStyles.vertical.text.size;
      }
      return Math.max(xAxisHeight, crosshairVerticalTextHeight);
    };
    XAxisImp2.prototype.getBounding = function() {
      return this.getParent().getMainWidget().getBounding();
    };
    XAxisImp2.prototype.convertTimestampFromPixel = function(pixel) {
      var chartStore = this.getParent().getChart().getChartStore();
      var dataIndex = chartStore.coordinateToDataIndex(pixel);
      return chartStore.dataIndexToTimestamp(dataIndex);
    };
    XAxisImp2.prototype.convertTimestampToPixel = function(timestamp) {
      var chartStore = this.getParent().getChart().getChartStore();
      var dataIndex = chartStore.timestampToDataIndex(timestamp);
      return chartStore.dataIndexToCoordinate(dataIndex);
    };
    XAxisImp2.prototype.convertFromPixel = function(pixel) {
      return this.getParent().getChart().getChartStore().coordinateToDataIndex(pixel);
    };
    XAxisImp2.prototype.convertToPixel = function(value) {
      return this.getParent().getChart().getChartStore().dataIndexToCoordinate(value);
    };
    XAxisImp2.extend = function(template) {
      var Custom = (
        /** @class */
        function(_super2) {
          __extends(Custom2, _super2);
          function Custom2(parent) {
            return _super2.call(this, parent, template) || this;
          }
          return Custom2;
        }(XAxisImp2)
      );
      return Custom;
    };
    return XAxisImp2;
  }(AxisImp)
);
var normal = {
  name: "normal"
};
var xAxises = {
  normal: XAxisImp.extend(normal)
};
function registerXAxis(axis) {
  xAxises[axis.name] = XAxisImp.extend(axis);
}
function getXAxisClass(name) {
  var _a;
  return (_a = xAxises[name]) !== null && _a !== void 0 ? _a : xAxises.normal;
}
var XAxisPane = (
  /** @class */
  function(_super) {
    __extends(XAxisPane2, _super);
    function XAxisPane2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    XAxisPane2.prototype.createAxisComponent = function(name) {
      var XAxisClass = getXAxisClass(name);
      return new XAxisClass(this);
    };
    XAxisPane2.prototype.createMainWidget = function(container) {
      return new XAxisWidget(container, this);
    };
    return XAxisPane2;
  }(DrawPane)
);
function throttle(func, wait) {
  var previous = 0;
  return function() {
    var now = Date.now();
    if (now - previous > wait) {
      func.apply(this, arguments);
      previous = now;
    }
  };
}
var SeparatorWidget = (
  /** @class */
  function(_super) {
    __extends(SeparatorWidget2, _super);
    function SeparatorWidget2(rootContainer, pane) {
      var _this = _super.call(this, rootContainer, pane) || this;
      _this._dragFlag = false;
      _this._dragStartY = 0;
      _this._topPaneHeight = 0;
      _this._bottomPaneHeight = 0;
      _this._topPane = null;
      _this._bottomPane = null;
      _this._pressedMouseMoveEvent = throttle(_this._pressedTouchMouseMoveEvent, 20);
      _this.registerEvent("touchStartEvent", _this._mouseDownEvent.bind(_this)).registerEvent("touchMoveEvent", _this._pressedMouseMoveEvent.bind(_this)).registerEvent("touchEndEvent", _this._mouseUpEvent.bind(_this)).registerEvent("mouseDownEvent", _this._mouseDownEvent.bind(_this)).registerEvent("mouseUpEvent", _this._mouseUpEvent.bind(_this)).registerEvent("pressedMouseMoveEvent", _this._pressedMouseMoveEvent.bind(_this)).registerEvent("mouseEnterEvent", _this._mouseEnterEvent.bind(_this)).registerEvent("mouseLeaveEvent", _this._mouseLeaveEvent.bind(_this));
      return _this;
    }
    SeparatorWidget2.prototype.getName = function() {
      return WidgetNameConstants.SEPARATOR;
    };
    SeparatorWidget2.prototype._mouseDownEvent = function(event) {
      var _this = this;
      this._dragFlag = true;
      this._dragStartY = event.pageY;
      var pane = this.getPane();
      var chart = pane.getChart();
      this._topPane = pane.getTopPane();
      this._bottomPane = pane.getBottomPane();
      var drawPanes = chart.getDrawPanes();
      if (this._topPane.getOptions().state === "minimize") {
        var index = drawPanes.findIndex(function(pane2) {
          var _a;
          return pane2.getId() === ((_a = _this._topPane) === null || _a === void 0 ? void 0 : _a.getId());
        });
        for (var i = index - 1; i > -1; i--) {
          var pane_1 = drawPanes[i];
          if (pane_1.getOptions().state !== "minimize") {
            this._topPane = pane_1;
            break;
          }
        }
      }
      if (this._bottomPane.getOptions().state === "minimize") {
        var index = drawPanes.findIndex(function(pane2) {
          var _a;
          return pane2.getId() === ((_a = _this._bottomPane) === null || _a === void 0 ? void 0 : _a.getId());
        });
        for (var i = index + 1; i < drawPanes.length; i++) {
          var pane_2 = drawPanes[i];
          if (pane_2.getOptions().state !== "minimize") {
            this._bottomPane = pane_2;
            break;
          }
        }
      }
      this._topPaneHeight = this._topPane.getBounding().height;
      this._bottomPaneHeight = this._bottomPane.getBounding().height;
      return true;
    };
    SeparatorWidget2.prototype._mouseUpEvent = function() {
      this._dragFlag = false;
      this._topPane = null;
      this._bottomPane = null;
      this._topPaneHeight = 0;
      this._bottomPaneHeight = 0;
      return this._mouseLeaveEvent();
    };
    SeparatorWidget2.prototype._pressedTouchMouseMoveEvent = function(event) {
      var dragDistance = event.pageY - this._dragStartY;
      var isUpDrag = dragDistance < 0;
      if (isValid(this._topPane) && isValid(this._bottomPane)) {
        var bottomPaneOptions = this._bottomPane.getOptions();
        if (this._topPane.getOptions().state !== "minimize" && bottomPaneOptions.state !== "minimize" && bottomPaneOptions.dragEnabled) {
          var reducedPane = null;
          var increasedPane = null;
          var startDragReducedPaneHeight = 0;
          var startDragIncreasedPaneHeight = 0;
          if (isUpDrag) {
            reducedPane = this._topPane;
            increasedPane = this._bottomPane;
            startDragReducedPaneHeight = this._topPaneHeight;
            startDragIncreasedPaneHeight = this._bottomPaneHeight;
          } else {
            reducedPane = this._bottomPane;
            increasedPane = this._topPane;
            startDragReducedPaneHeight = this._bottomPaneHeight;
            startDragIncreasedPaneHeight = this._topPaneHeight;
          }
          var reducedPaneMinHeight = reducedPane.getOptions().minHeight;
          if (startDragReducedPaneHeight > reducedPaneMinHeight) {
            var reducedPaneHeight = Math.max(startDragReducedPaneHeight - Math.abs(dragDistance), reducedPaneMinHeight);
            var diffHeight = startDragReducedPaneHeight - reducedPaneHeight;
            reducedPane.setBounding({ height: reducedPaneHeight });
            increasedPane.setBounding({ height: startDragIncreasedPaneHeight + diffHeight });
            var currentPane = this.getPane();
            var chart = currentPane.getChart();
            chart.getChartStore().executeAction("onPaneDrag", { paneId: currentPane.getId() });
            chart.layout({
              measureHeight: true,
              measureWidth: true,
              update: true,
              buildYAxisTick: true,
              forceBuildYAxisTick: true
            });
          }
        }
      }
      return true;
    };
    SeparatorWidget2.prototype._mouseEnterEvent = function() {
      var pane = this.getPane();
      var bottomPane = pane.getBottomPane();
      if (bottomPane.getOptions().dragEnabled) {
        var chart = pane.getChart();
        var styles2 = chart.getStyles().separator;
        this.getContainer().style.background = styles2.activeBackgroundColor;
        return true;
      }
      return false;
    };
    SeparatorWidget2.prototype._mouseLeaveEvent = function() {
      if (!this._dragFlag) {
        this.getContainer().style.background = "transparent";
        return true;
      }
      return false;
    };
    SeparatorWidget2.prototype.createContainer = function() {
      return createDom("div", {
        width: "100%",
        height: "".concat(REAL_SEPARATOR_HEIGHT, "px"),
        margin: "0",
        padding: "0",
        position: "absolute",
        top: "-3px",
        zIndex: "20",
        boxSizing: "border-box",
        cursor: "ns-resize"
      });
    };
    SeparatorWidget2.prototype.updateImp = function(container, _bounding, level) {
      if (level === 4 || level === 2) {
        var styles2 = this.getPane().getChart().getStyles().separator;
        container.style.top = "".concat(-Math.floor((REAL_SEPARATOR_HEIGHT - styles2.size) / 2), "px");
        container.style.height = "".concat(REAL_SEPARATOR_HEIGHT, "px");
      }
    };
    return SeparatorWidget2;
  }(Widget)
);
var SeparatorPane = (
  /** @class */
  function(_super) {
    __extends(SeparatorPane2, _super);
    function SeparatorPane2(chart, id, topPane, bottomPane) {
      var _this = _super.call(this, chart, id) || this;
      _this.getContainer().style.overflow = "";
      _this._topPane = topPane;
      _this._bottomPane = bottomPane;
      _this._separatorWidget = new SeparatorWidget(_this.getContainer(), _this);
      return _this;
    }
    SeparatorPane2.prototype.setBounding = function(rootBounding) {
      merge(this.getBounding(), rootBounding);
      return this;
    };
    SeparatorPane2.prototype.getTopPane = function() {
      return this._topPane;
    };
    SeparatorPane2.prototype.setTopPane = function(pane) {
      this._topPane = pane;
      return this;
    };
    SeparatorPane2.prototype.getBottomPane = function() {
      return this._bottomPane;
    };
    SeparatorPane2.prototype.setBottomPane = function(pane) {
      this._bottomPane = pane;
      return this;
    };
    SeparatorPane2.prototype.getWidget = function() {
      return this._separatorWidget;
    };
    SeparatorPane2.prototype.getImage = function(_includeOverlay) {
      var _a = this.getBounding(), width = _a.width, height = _a.height;
      var styles2 = this.getChart().getStyles().separator;
      var canvas = createDom("canvas", {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: "border-box"
      });
      var ctx = canvas.getContext("2d");
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      ctx.fillStyle = styles2.color;
      ctx.fillRect(0, 0, width, height);
      return canvas;
    };
    SeparatorPane2.prototype.updateImp = function(level, container, bounding) {
      if (level === 4 || level === 2) {
        var styles2 = this.getChart().getStyles().separator;
        container.style.backgroundColor = styles2.color;
        container.style.height = "".concat(bounding.height, "px");
        container.style.marginLeft = "".concat(bounding.left, "px");
        container.style.width = "".concat(bounding.width, "px");
        this._separatorWidget.update(level);
      }
    };
    return SeparatorPane2;
  }(Pane)
);
function isFF() {
  if (typeof window === "undefined") {
    return false;
  }
  return window.navigator.userAgent.toLowerCase().includes("firefox");
}
function isIOS() {
  if (typeof window === "undefined") {
    return false;
  }
  return /iPhone|iPad|iPod|iOS/.test(window.navigator.userAgent);
}
var Delay = {
  ResetClick: 500,
  LongTap: 500,
  PreventFiresTouchEvents: 500
};
var ManhattanDistance = {
  CancelClick: 5,
  CancelTap: 5,
  DoubleClick: 5,
  DoubleTap: 30
};
var MouseEventButton = {
  Left: 0,
  Middle: 1,
  Right: 2
};
var TOUCH_MIN_RADIUS = 10;
var EventHandlerImp = (
  /** @class */
  function() {
    function EventHandlerImp2(target, handler, options) {
      var _this = this;
      this._clickCount = 0;
      this._clickTimeoutId = null;
      this._clickCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
      this._tapCount = 0;
      this._tapTimeoutId = null;
      this._tapCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
      this._longTapTimeoutId = null;
      this._longTapActive = false;
      this._mouseMoveStartCoordinate = null;
      this._touchMoveStartCoordinate = null;
      this._touchMoveExceededManhattanDistance = false;
      this._cancelClick = false;
      this._cancelTap = false;
      this._unsubscribeOutsideMouseEvents = null;
      this._unsubscribeOutsideTouchEvents = null;
      this._unsubscribeMobileSafariEvents = null;
      this._unsubscribeMousemove = null;
      this._unsubscribeMouseWheel = null;
      this._unsubscribeContextMenu = null;
      this._unsubscribeRootMouseEvents = null;
      this._unsubscribeRootTouchEvents = null;
      this._startPinchMiddleCoordinate = null;
      this._startPinchDistance = 0;
      this._pinchPrevented = false;
      this._preventTouchDragProcess = false;
      this._mousePressed = false;
      this._lastTouchEventTimeStamp = 0;
      this._activeTouchId = null;
      this._acceptMouseLeave = !isIOS();
      this._onFirefoxOutsideMouseUp = function(mouseUpEvent) {
        _this._mouseUpHandler(mouseUpEvent);
      };
      this._onMobileSafariDoubleClick = function(dblClickEvent) {
        if (_this._firesTouchEvents(dblClickEvent)) {
          ++_this._tapCount;
          if (_this._tapTimeoutId !== null && _this._tapCount > 1) {
            var manhattanDistance = _this._mouseTouchMoveWithDownInfo(_this._getCoordinate(dblClickEvent), _this._tapCoordinate).manhattanDistance;
            if (manhattanDistance < ManhattanDistance.DoubleTap && !_this._cancelTap) {
              _this._processEvent(_this._makeCompatEvent(dblClickEvent), _this._handler.doubleTapEvent);
            }
            _this._resetTapTimeout();
          }
        } else {
          ++_this._clickCount;
          if (_this._clickTimeoutId !== null && _this._clickCount > 1) {
            var manhattanDistance = _this._mouseTouchMoveWithDownInfo(_this._getCoordinate(dblClickEvent), _this._clickCoordinate).manhattanDistance;
            if (manhattanDistance < ManhattanDistance.DoubleClick && !_this._cancelClick) {
              _this._processEvent(_this._makeCompatEvent(dblClickEvent), _this._handler.mouseDoubleClickEvent);
            }
            _this._resetClickTimeout();
          }
        }
      };
      this._target = target;
      this._handler = handler;
      this._options = options;
      this._init();
    }
    EventHandlerImp2.prototype.destroy = function() {
      if (this._unsubscribeOutsideMouseEvents !== null) {
        this._unsubscribeOutsideMouseEvents();
        this._unsubscribeOutsideMouseEvents = null;
      }
      if (this._unsubscribeOutsideTouchEvents !== null) {
        this._unsubscribeOutsideTouchEvents();
        this._unsubscribeOutsideTouchEvents = null;
      }
      if (this._unsubscribeMousemove !== null) {
        this._unsubscribeMousemove();
        this._unsubscribeMousemove = null;
      }
      if (this._unsubscribeMouseWheel !== null) {
        this._unsubscribeMouseWheel();
        this._unsubscribeMouseWheel = null;
      }
      if (this._unsubscribeContextMenu !== null) {
        this._unsubscribeContextMenu();
        this._unsubscribeContextMenu = null;
      }
      if (this._unsubscribeRootMouseEvents !== null) {
        this._unsubscribeRootMouseEvents();
        this._unsubscribeRootMouseEvents = null;
      }
      if (this._unsubscribeRootTouchEvents !== null) {
        this._unsubscribeRootTouchEvents();
        this._unsubscribeRootTouchEvents = null;
      }
      if (this._unsubscribeMobileSafariEvents !== null) {
        this._unsubscribeMobileSafariEvents();
        this._unsubscribeMobileSafariEvents = null;
      }
      this._clearLongTapTimeout();
      this._resetClickTimeout();
    };
    EventHandlerImp2.prototype._mouseEnterHandler = function(enterEvent) {
      var _this = this;
      var _a, _b, _c;
      (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);
      (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);
      var boundMouseMoveHandler = this._mouseMoveHandler.bind(this);
      this._unsubscribeMousemove = function() {
        _this._target.removeEventListener("mousemove", boundMouseMoveHandler);
      };
      this._target.addEventListener("mousemove", boundMouseMoveHandler);
      var boundMouseWheel = this._mouseWheelHandler.bind(this);
      this._unsubscribeMouseWheel = function() {
        _this._target.removeEventListener("wheel", boundMouseWheel);
      };
      this._target.addEventListener("wheel", boundMouseWheel, { passive: false });
      var boundContextMenu = this._contextMenuHandler.bind(this);
      this._unsubscribeContextMenu = function() {
        _this._target.removeEventListener("contextmenu", boundContextMenu);
      };
      this._target.addEventListener("contextmenu", boundContextMenu, { passive: false });
      if (this._firesTouchEvents(enterEvent)) {
        return;
      }
      this._processEvent(this._makeCompatEvent(enterEvent), this._handler.mouseEnterEvent);
      this._acceptMouseLeave = true;
    };
    EventHandlerImp2.prototype._resetClickTimeout = function() {
      if (this._clickTimeoutId !== null) {
        clearTimeout(this._clickTimeoutId);
      }
      this._clickCount = 0;
      this._clickTimeoutId = null;
      this._clickCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
    };
    EventHandlerImp2.prototype._resetTapTimeout = function() {
      if (this._tapTimeoutId !== null) {
        clearTimeout(this._tapTimeoutId);
      }
      this._tapCount = 0;
      this._tapTimeoutId = null;
      this._tapCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
    };
    EventHandlerImp2.prototype._mouseMoveHandler = function(moveEvent) {
      if (this._mousePressed || this._touchMoveStartCoordinate !== null) {
        return;
      }
      if (this._firesTouchEvents(moveEvent)) {
        return;
      }
      this._processEvent(this._makeCompatEvent(moveEvent), this._handler.mouseMoveEvent);
      this._acceptMouseLeave = true;
    };
    EventHandlerImp2.prototype._mouseWheelHandler = function(wheelEvent) {
      if (Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {
        if (!isValid(this._handler.mouseWheelHortEvent)) {
          return;
        }
        this._preventDefault(wheelEvent);
        if (Math.abs(wheelEvent.deltaX) === 0) {
          return;
        }
        this._handler.mouseWheelHortEvent(this._makeCompatEvent(wheelEvent), -wheelEvent.deltaX);
      } else {
        if (!isValid(this._handler.mouseWheelVertEvent)) {
          return;
        }
        var deltaY = -(wheelEvent.deltaY / 100);
        if (deltaY === 0) {
          return;
        }
        this._preventDefault(wheelEvent);
        switch (wheelEvent.deltaMode) {
          case wheelEvent.DOM_DELTA_PAGE: {
            deltaY *= 120;
            break;
          }
          case wheelEvent.DOM_DELTA_LINE: {
            deltaY *= 32;
            break;
          }
        }
        if (deltaY !== 0) {
          var scale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));
          this._handler.mouseWheelVertEvent(this._makeCompatEvent(wheelEvent), scale);
        }
      }
    };
    EventHandlerImp2.prototype._contextMenuHandler = function(mouseEvent) {
      this._preventDefault(mouseEvent);
    };
    EventHandlerImp2.prototype._touchMoveHandler = function(moveEvent) {
      var touch = this._touchWithId(moveEvent.changedTouches, this._activeTouchId);
      if (touch === null) {
        return;
      }
      this._lastTouchEventTimeStamp = this._eventTimeStamp(moveEvent);
      if (this._startPinchMiddleCoordinate !== null) {
        return;
      }
      if (this._preventTouchDragProcess) {
        return;
      }
      this._pinchPrevented = true;
      var moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._touchMoveStartCoordinate);
      var xOffset = moveInfo.xOffset, yOffset = moveInfo.yOffset, manhattanDistance = moveInfo.manhattanDistance;
      if (!this._touchMoveExceededManhattanDistance && manhattanDistance < ManhattanDistance.CancelTap) {
        return;
      }
      if (!this._touchMoveExceededManhattanDistance) {
        var correctedXOffset = xOffset * 0.5;
        var isVertDrag = yOffset >= correctedXOffset && !this._options.treatVertDragAsPageScroll();
        var isHorzDrag = correctedXOffset > yOffset && !this._options.treatHorzDragAsPageScroll();
        if (!isVertDrag && !isHorzDrag) {
          this._preventTouchDragProcess = true;
        }
        this._touchMoveExceededManhattanDistance = true;
        this._cancelTap = true;
        this._clearLongTapTimeout();
        this._resetTapTimeout();
      }
      if (!this._preventTouchDragProcess) {
        this._processEvent(this._makeCompatEvent(moveEvent, touch), this._handler.touchMoveEvent);
      }
    };
    EventHandlerImp2.prototype._mouseMoveWithDownHandler = function(moveEvent) {
      if (moveEvent.button !== MouseEventButton.Left) {
        return;
      }
      var moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(moveEvent), this._mouseMoveStartCoordinate);
      var manhattanDistance = moveInfo.manhattanDistance;
      if (manhattanDistance >= ManhattanDistance.CancelClick) {
        this._cancelClick = true;
        this._resetClickTimeout();
      }
      if (this._cancelClick) {
        this._processEvent(this._makeCompatEvent(moveEvent), this._handler.pressedMouseMoveEvent);
      }
    };
    EventHandlerImp2.prototype._mouseTouchMoveWithDownInfo = function(currentCoordinate, startCoordinate) {
      var xOffset = Math.abs(startCoordinate.x - currentCoordinate.x);
      var yOffset = Math.abs(startCoordinate.y - currentCoordinate.y);
      var manhattanDistance = xOffset + yOffset;
      return { xOffset, yOffset, manhattanDistance };
    };
    EventHandlerImp2.prototype._touchEndHandler = function(touchEndEvent) {
      var touch = this._touchWithId(touchEndEvent.changedTouches, this._activeTouchId);
      if (touch === null && touchEndEvent.touches.length === 0) {
        touch = touchEndEvent.changedTouches[0];
      }
      if (touch === null) {
        return;
      }
      this._activeTouchId = null;
      this._lastTouchEventTimeStamp = this._eventTimeStamp(touchEndEvent);
      this._clearLongTapTimeout();
      this._touchMoveStartCoordinate = null;
      if (this._unsubscribeRootTouchEvents !== null) {
        this._unsubscribeRootTouchEvents();
        this._unsubscribeRootTouchEvents = null;
      }
      var compatEvent = this._makeCompatEvent(touchEndEvent, touch);
      this._processEvent(compatEvent, this._handler.touchEndEvent);
      ++this._tapCount;
      if (this._tapTimeoutId !== null && this._tapCount > 1) {
        var manhattanDistance = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._tapCoordinate).manhattanDistance;
        if (manhattanDistance < ManhattanDistance.DoubleTap && !this._cancelTap) {
          this._processEvent(compatEvent, this._handler.doubleTapEvent);
        }
        this._resetTapTimeout();
      } else {
        if (!this._cancelTap) {
          this._processEvent(compatEvent, this._handler.tapEvent);
          if (isValid(this._handler.tapEvent)) {
            this._preventDefault(touchEndEvent);
          }
        }
      }
      if (this._tapCount === 0) {
        this._preventDefault(touchEndEvent);
      }
      if (touchEndEvent.touches.length === 0) {
        if (this._longTapActive) {
          this._longTapActive = false;
          this._preventDefault(touchEndEvent);
        }
      }
    };
    EventHandlerImp2.prototype._mouseUpHandler = function(mouseUpEvent) {
      if (mouseUpEvent.button !== MouseEventButton.Left) {
        return;
      }
      var compatEvent = this._makeCompatEvent(mouseUpEvent);
      this._mouseMoveStartCoordinate = null;
      this._mousePressed = false;
      if (this._unsubscribeRootMouseEvents !== null) {
        this._unsubscribeRootMouseEvents();
        this._unsubscribeRootMouseEvents = null;
      }
      if (isFF()) {
        var rootElement = this._target.ownerDocument.documentElement;
        rootElement.removeEventListener("mouseleave", this._onFirefoxOutsideMouseUp);
      }
      if (this._firesTouchEvents(mouseUpEvent)) {
        return;
      }
      this._processEvent(compatEvent, this._handler.mouseUpEvent);
      ++this._clickCount;
      if (this._clickTimeoutId !== null && this._clickCount > 1) {
        var manhattanDistance = this._mouseTouchMoveWithDownInfo(this._getCoordinate(mouseUpEvent), this._clickCoordinate).manhattanDistance;
        if (manhattanDistance < ManhattanDistance.DoubleClick && !this._cancelClick) {
          this._processEvent(compatEvent, this._handler.mouseDoubleClickEvent);
        }
        this._resetClickTimeout();
      } else {
        if (!this._cancelClick) {
          this._processEvent(compatEvent, this._handler.mouseClickEvent);
        }
      }
    };
    EventHandlerImp2.prototype._clearLongTapTimeout = function() {
      if (this._longTapTimeoutId === null) {
        return;
      }
      clearTimeout(this._longTapTimeoutId);
      this._longTapTimeoutId = null;
    };
    EventHandlerImp2.prototype._touchStartHandler = function(downEvent) {
      if (this._activeTouchId !== null) {
        return;
      }
      var touch = downEvent.changedTouches[0];
      this._activeTouchId = touch.identifier;
      this._lastTouchEventTimeStamp = this._eventTimeStamp(downEvent);
      var rootElement = this._target.ownerDocument.documentElement;
      this._cancelTap = false;
      this._touchMoveExceededManhattanDistance = false;
      this._preventTouchDragProcess = false;
      this._touchMoveStartCoordinate = this._getCoordinate(touch);
      if (this._unsubscribeRootTouchEvents !== null) {
        this._unsubscribeRootTouchEvents();
        this._unsubscribeRootTouchEvents = null;
      }
      {
        var boundTouchMoveWithDownHandler_1 = this._touchMoveHandler.bind(this);
        var boundTouchEndHandler_1 = this._touchEndHandler.bind(this);
        this._unsubscribeRootTouchEvents = function() {
          rootElement.removeEventListener("touchmove", boundTouchMoveWithDownHandler_1);
          rootElement.removeEventListener("touchend", boundTouchEndHandler_1);
        };
        rootElement.addEventListener("touchmove", boundTouchMoveWithDownHandler_1, { passive: false });
        rootElement.addEventListener("touchend", boundTouchEndHandler_1, { passive: false });
        this._clearLongTapTimeout();
        this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, downEvent), Delay.LongTap);
      }
      this._processEvent(this._makeCompatEvent(downEvent, touch), this._handler.touchStartEvent);
      if (this._tapTimeoutId === null) {
        this._tapCount = 0;
        this._tapTimeoutId = setTimeout(this._resetTapTimeout.bind(this), Delay.ResetClick);
        this._tapCoordinate = this._getCoordinate(touch);
      }
    };
    EventHandlerImp2.prototype._mouseDownHandler = function(downEvent) {
      if (downEvent.button === MouseEventButton.Right) {
        this._preventDefault(downEvent);
        this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseRightClickEvent);
        return;
      }
      if (downEvent.button !== MouseEventButton.Left) {
        return;
      }
      var rootElement = this._target.ownerDocument.documentElement;
      if (isFF()) {
        rootElement.addEventListener("mouseleave", this._onFirefoxOutsideMouseUp);
      }
      this._cancelClick = false;
      this._mouseMoveStartCoordinate = this._getCoordinate(downEvent);
      if (this._unsubscribeRootMouseEvents !== null) {
        this._unsubscribeRootMouseEvents();
        this._unsubscribeRootMouseEvents = null;
      }
      {
        var boundMouseMoveWithDownHandler_1 = this._mouseMoveWithDownHandler.bind(this);
        var boundMouseUpHandler_1 = this._mouseUpHandler.bind(this);
        this._unsubscribeRootMouseEvents = function() {
          rootElement.removeEventListener("mousemove", boundMouseMoveWithDownHandler_1);
          rootElement.removeEventListener("mouseup", boundMouseUpHandler_1);
        };
        rootElement.addEventListener("mousemove", boundMouseMoveWithDownHandler_1);
        rootElement.addEventListener("mouseup", boundMouseUpHandler_1);
      }
      this._mousePressed = true;
      if (this._firesTouchEvents(downEvent)) {
        return;
      }
      this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseDownEvent);
      if (this._clickTimeoutId === null) {
        this._clickCount = 0;
        this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), Delay.ResetClick);
        this._clickCoordinate = this._getCoordinate(downEvent);
      }
    };
    EventHandlerImp2.prototype._init = function() {
      var _this = this;
      this._target.addEventListener("mouseenter", this._mouseEnterHandler.bind(this));
      this._target.addEventListener("touchcancel", this._clearLongTapTimeout.bind(this));
      {
        var doc_1 = this._target.ownerDocument;
        var outsideHandler_1 = function(event) {
          if (_this._handler.mouseDownOutsideEvent == null) {
            return;
          }
          if (event.composed && _this._target.contains(event.composedPath()[0])) {
            return;
          }
          if (event.target !== null && _this._target.contains(event.target)) {
            return;
          }
          _this._handler.mouseDownOutsideEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });
        };
        this._unsubscribeOutsideTouchEvents = function() {
          doc_1.removeEventListener("touchstart", outsideHandler_1);
        };
        this._unsubscribeOutsideMouseEvents = function() {
          doc_1.removeEventListener("mousedown", outsideHandler_1);
        };
        doc_1.addEventListener("mousedown", outsideHandler_1);
        doc_1.addEventListener("touchstart", outsideHandler_1, { passive: true });
      }
      if (isIOS()) {
        this._unsubscribeMobileSafariEvents = function() {
          _this._target.removeEventListener("dblclick", _this._onMobileSafariDoubleClick);
        };
        this._target.addEventListener("dblclick", this._onMobileSafariDoubleClick);
      }
      this._target.addEventListener("mouseleave", this._mouseLeaveHandler.bind(this));
      this._target.addEventListener("touchstart", this._touchStartHandler.bind(this), { passive: true });
      this._target.addEventListener("mousedown", function(e) {
        if (e.button === MouseEventButton.Middle) {
          e.preventDefault();
          return false;
        }
        return void 0;
      });
      this._target.addEventListener("mousedown", this._mouseDownHandler.bind(this));
      this._initPinch();
      this._target.addEventListener("touchmove", function() {
      }, { passive: false });
    };
    EventHandlerImp2.prototype._initPinch = function() {
      var _this = this;
      if (!isValid(this._handler.pinchStartEvent) && !isValid(this._handler.pinchEvent) && !isValid(this._handler.pinchEndEvent)) {
        return;
      }
      this._target.addEventListener("touchstart", function(event) {
        _this._checkPinchState(event.touches);
      }, { passive: true });
      this._target.addEventListener("touchmove", function(event) {
        if (event.touches.length !== 2 || _this._startPinchMiddleCoordinate === null) {
          return;
        }
        if (isValid(_this._handler.pinchEvent)) {
          var currentDistance = _this._getTouchDistance(event.touches[0], event.touches[1]);
          var scale = currentDistance / _this._startPinchDistance;
          _this._handler.pinchEvent(__assign(__assign({}, _this._startPinchMiddleCoordinate), { pageX: 0, pageY: 0 }), scale);
          _this._preventDefault(event);
        }
      }, { passive: false });
      this._target.addEventListener("touchend", function(event) {
        _this._checkPinchState(event.touches);
      });
    };
    EventHandlerImp2.prototype._checkPinchState = function(touches) {
      if (touches.length === 1) {
        this._pinchPrevented = false;
      }
      if (touches.length !== 2 || this._pinchPrevented || this._longTapActive) {
        this._stopPinch();
      } else {
        this._startPinch(touches);
      }
    };
    EventHandlerImp2.prototype._startPinch = function(touches) {
      var box = this._target.getBoundingClientRect();
      this._startPinchMiddleCoordinate = {
        x: (touches[0].clientX - box.left + (touches[1].clientX - box.left)) / 2,
        y: (touches[0].clientY - box.top + (touches[1].clientY - box.top)) / 2
      };
      this._startPinchDistance = this._getTouchDistance(touches[0], touches[1]);
      if (isValid(this._handler.pinchStartEvent)) {
        this._handler.pinchStartEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });
      }
      this._clearLongTapTimeout();
    };
    EventHandlerImp2.prototype._stopPinch = function() {
      if (this._startPinchMiddleCoordinate === null) {
        return;
      }
      this._startPinchMiddleCoordinate = null;
      if (isValid(this._handler.pinchEndEvent)) {
        this._handler.pinchEndEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });
      }
    };
    EventHandlerImp2.prototype._mouseLeaveHandler = function(event) {
      var _a, _b, _c;
      (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);
      (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);
      (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);
      if (this._firesTouchEvents(event)) {
        return;
      }
      if (!this._acceptMouseLeave) {
        return;
      }
      this._processEvent(this._makeCompatEvent(event), this._handler.mouseLeaveEvent);
      this._acceptMouseLeave = !isIOS();
    };
    EventHandlerImp2.prototype._longTapHandler = function(event) {
      var touch = this._touchWithId(event.touches, this._activeTouchId);
      if (touch === null) {
        return;
      }
      this._processEvent(this._makeCompatEvent(event, touch), this._handler.longTapEvent);
      this._cancelTap = true;
      this._longTapActive = true;
    };
    EventHandlerImp2.prototype._firesTouchEvents = function(e) {
      var _a;
      if (isValid((_a = e.sourceCapabilities) === null || _a === void 0 ? void 0 : _a.firesTouchEvents)) {
        return e.sourceCapabilities.firesTouchEvents;
      }
      return this._eventTimeStamp(e) < this._lastTouchEventTimeStamp + Delay.PreventFiresTouchEvents;
    };
    EventHandlerImp2.prototype._processEvent = function(event, callback) {
      callback === null || callback === void 0 ? void 0 : callback.call(this._handler, event);
    };
    EventHandlerImp2.prototype._makeCompatEvent = function(event, touch) {
      var _this = this;
      var eventLike = touch !== null && touch !== void 0 ? touch : event;
      var box = this._target.getBoundingClientRect();
      return {
        x: eventLike.clientX - box.left,
        y: eventLike.clientY - box.top,
        pageX: eventLike.pageX,
        pageY: eventLike.pageY,
        isTouch: !event.type.startsWith("mouse") && event.type !== "contextmenu" && event.type !== "click" && event.type !== "wheel",
        preventDefault: function() {
          if (event.type !== "touchstart") {
            _this._preventDefault(event);
          }
        }
      };
    };
    EventHandlerImp2.prototype._getTouchDistance = function(p1, p2) {
      var xDiff = p1.clientX - p2.clientX;
      var yDiff = p1.clientY - p2.clientY;
      return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    };
    EventHandlerImp2.prototype._preventDefault = function(event) {
      if (event.cancelable) {
        event.preventDefault();
      }
    };
    EventHandlerImp2.prototype._getCoordinate = function(eventLike) {
      return {
        x: eventLike.pageX,
        y: eventLike.pageY
      };
    };
    EventHandlerImp2.prototype._eventTimeStamp = function(e) {
      var _a;
      return (_a = e.timeStamp) !== null && _a !== void 0 ? _a : performance.now();
    };
    EventHandlerImp2.prototype._touchWithId = function(touches, id) {
      for (var i = 0; i < touches.length; ++i) {
        if (touches[i].identifier === id) {
          return touches[i];
        }
      }
      return null;
    };
    return EventHandlerImp2;
  }()
);
var Event = (
  /** @class */
  function() {
    function Event2(container, chart) {
      var _this = this;
      this._flingStartTime = (/* @__PURE__ */ new Date()).getTime();
      this._flingScrollRequestId = null;
      this._startScrollCoordinate = null;
      this._touchCoordinate = null;
      this._touchCancelCrosshair = false;
      this._touchZoomed = false;
      this._pinchScale = 1;
      this._mouseDownWidget = null;
      this._prevYAxisRange = null;
      this._xAxisStartScaleCoordinate = null;
      this._xAxisStartScaleDistance = 0;
      this._xAxisScale = 1;
      this._yAxisStartScaleDistance = 0;
      this._mouseMoveTriggerWidgetInfo = { pane: null, widget: null };
      this._boundKeyBoardDownEvent = function(event) {
        if (event.shiftKey) {
          switch (event.code) {
            case "Equal": {
              _this._chart.getChartStore().zoom(0.5, null, "main");
              break;
            }
            case "Minus": {
              _this._chart.getChartStore().zoom(-0.5, null, "main");
              break;
            }
            case "ArrowLeft": {
              var store = _this._chart.getChartStore();
              store.startScroll();
              store.scroll(-3 * store.getBarSpace().bar);
              break;
            }
            case "ArrowRight": {
              var store = _this._chart.getChartStore();
              store.startScroll();
              store.scroll(3 * store.getBarSpace().bar);
              break;
            }
          }
        }
      };
      this._container = container;
      this._chart = chart;
      this._event = new EventHandlerImp(container, this, {
        treatVertDragAsPageScroll: function() {
          return false;
        },
        treatHorzDragAsPageScroll: function() {
          return false;
        }
      });
      container.addEventListener("keydown", this._boundKeyBoardDownEvent);
    }
    Event2.prototype.pinchStartEvent = function() {
      this._touchZoomed = true;
      this._pinchScale = 1;
      return true;
    };
    Event2.prototype.pinchEvent = function(e, scale) {
      var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;
      if ((pane === null || pane === void 0 ? void 0 : pane.getId()) !== PaneIdConstants.X_AXIS && (widget === null || widget === void 0 ? void 0 : widget.getName()) === WidgetNameConstants.MAIN) {
        var event_1 = this._makeWidgetEvent(e, widget);
        var zoomScale = (scale - this._pinchScale) * 5;
        this._pinchScale = scale;
        this._chart.getChartStore().zoom(zoomScale, { x: event_1.x, y: event_1.y }, "main");
        return true;
      }
      return false;
    };
    Event2.prototype.mouseWheelHortEvent = function(_, distance) {
      var store = this._chart.getChartStore();
      store.startScroll();
      store.scroll(distance);
      return true;
    };
    Event2.prototype.mouseWheelVertEvent = function(e, scale) {
      var widget = this._findWidgetByEvent(e).widget;
      var event = this._makeWidgetEvent(e, widget);
      var name = widget === null || widget === void 0 ? void 0 : widget.getName();
      if (name === WidgetNameConstants.MAIN) {
        this._chart.getChartStore().zoom(scale, { x: event.x, y: event.y }, "main");
        return true;
      }
      return false;
    };
    Event2.prototype.mouseDownEvent = function(e) {
      var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;
      this._mouseDownWidget = widget;
      if (widget !== null) {
        var event_2 = this._makeWidgetEvent(e, widget);
        var name_1 = widget.getName();
        switch (name_1) {
          case WidgetNameConstants.SEPARATOR: {
            return widget.dispatchEvent("mouseDownEvent", event_2);
          }
          case WidgetNameConstants.MAIN: {
            var yAxis = pane.getAxisComponent();
            if (!yAxis.getAutoCalcTickFlag()) {
              var range = yAxis.getRange();
              this._prevYAxisRange = __assign({}, range);
            }
            this._startScrollCoordinate = { x: event_2.x, y: event_2.y };
            this._chart.getChartStore().startScroll();
            return widget.dispatchEvent("mouseDownEvent", event_2);
          }
          case WidgetNameConstants.X_AXIS: {
            return this._processXAxisScrollStartEvent(widget, event_2);
          }
          case WidgetNameConstants.Y_AXIS: {
            return this._processYAxisScaleStartEvent(widget, event_2);
          }
        }
      }
      return false;
    };
    Event2.prototype.mouseMoveEvent = function(e) {
      var _a, _b, _c;
      var _d = this._findWidgetByEvent(e), pane = _d.pane, widget = _d.widget;
      var event = this._makeWidgetEvent(e, widget);
      if (((_a = this._mouseMoveTriggerWidgetInfo.pane) === null || _a === void 0 ? void 0 : _a.getId()) !== (pane === null || pane === void 0 ? void 0 : pane.getId()) || ((_b = this._mouseMoveTriggerWidgetInfo.widget) === null || _b === void 0 ? void 0 : _b.getName()) !== (widget === null || widget === void 0 ? void 0 : widget.getName())) {
        widget === null || widget === void 0 ? void 0 : widget.dispatchEvent("mouseEnterEvent", event);
        (_c = this._mouseMoveTriggerWidgetInfo.widget) === null || _c === void 0 ? void 0 : _c.dispatchEvent("mouseLeaveEvent", event);
        this._mouseMoveTriggerWidgetInfo = { pane, widget };
      }
      if (widget !== null) {
        var name_2 = widget.getName();
        switch (name_2) {
          case WidgetNameConstants.MAIN: {
            var consumed = widget.dispatchEvent("mouseMoveEvent", event);
            var crosshair = { x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() };
            if (consumed) {
              if (widget.getForceCursor() !== "pointer") {
                crosshair = void 0;
              }
              widget.setCursor("pointer");
            } else {
              widget.setCursor("crosshair");
            }
            this._chart.getChartStore().setCrosshair(crosshair);
            return consumed;
          }
          case WidgetNameConstants.SEPARATOR:
          case WidgetNameConstants.X_AXIS:
          case WidgetNameConstants.Y_AXIS: {
            var consumed = widget.dispatchEvent("mouseMoveEvent", event);
            this._chart.getChartStore().setCrosshair();
            return consumed;
          }
        }
      }
      return false;
    };
    Event2.prototype.pressedMouseMoveEvent = function(e) {
      var _a, _b;
      if (this._mouseDownWidget !== null && this._mouseDownWidget.getName() === WidgetNameConstants.SEPARATOR) {
        return this._mouseDownWidget.dispatchEvent("pressedMouseMoveEvent", e);
      }
      var _c = this._findWidgetByEvent(e), pane = _c.pane, widget = _c.widget;
      if (widget !== null && ((_a = this._mouseDownWidget) === null || _a === void 0 ? void 0 : _a.getPane().getId()) === (pane === null || pane === void 0 ? void 0 : pane.getId()) && ((_b = this._mouseDownWidget) === null || _b === void 0 ? void 0 : _b.getName()) === widget.getName()) {
        var event_3 = this._makeWidgetEvent(e, widget);
        var name_3 = widget.getName();
        switch (name_3) {
          case WidgetNameConstants.MAIN: {
            var crosshair = void 0;
            var consumed = widget.dispatchEvent("pressedMouseMoveEvent", event_3);
            if (!consumed) {
              this._processMainScrollingEvent(widget, event_3);
            }
            if (!consumed || widget.getForceCursor() === "pointer") {
              crosshair = { x: event_3.x, y: event_3.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() };
            }
            this._chart.getChartStore().setCrosshair(crosshair, { forceInvalidate: true });
            return consumed;
          }
          case WidgetNameConstants.X_AXIS: {
            return this._processXAxisScrollingEvent(widget, event_3);
          }
          case WidgetNameConstants.Y_AXIS: {
            return this._processYAxisScalingEvent(widget, event_3);
          }
        }
      }
      return false;
    };
    Event2.prototype.mouseUpEvent = function(e) {
      var widget = this._findWidgetByEvent(e).widget;
      var consumed = false;
      if (widget !== null) {
        var event_4 = this._makeWidgetEvent(e, widget);
        var name_4 = widget.getName();
        switch (name_4) {
          case WidgetNameConstants.MAIN:
          case WidgetNameConstants.SEPARATOR:
          case WidgetNameConstants.X_AXIS:
          case WidgetNameConstants.Y_AXIS: {
            consumed = widget.dispatchEvent("mouseUpEvent", event_4);
            break;
          }
        }
        if (consumed) {
          this._chart.updatePane(
            1
            /* UpdateLevel.Overlay */
          );
        }
      }
      this._mouseDownWidget = null;
      this._startScrollCoordinate = null;
      this._prevYAxisRange = null;
      this._xAxisStartScaleCoordinate = null;
      this._xAxisStartScaleDistance = 0;
      this._xAxisScale = 1;
      this._yAxisStartScaleDistance = 0;
      return consumed;
    };
    Event2.prototype.mouseClickEvent = function(e) {
      var widget = this._findWidgetByEvent(e).widget;
      if (widget !== null) {
        var event_5 = this._makeWidgetEvent(e, widget);
        return widget.dispatchEvent("mouseClickEvent", event_5);
      }
      return false;
    };
    Event2.prototype.mouseRightClickEvent = function(e) {
      var widget = this._findWidgetByEvent(e).widget;
      var consumed = false;
      if (widget !== null) {
        var event_6 = this._makeWidgetEvent(e, widget);
        var name_5 = widget.getName();
        switch (name_5) {
          case WidgetNameConstants.MAIN:
          case WidgetNameConstants.X_AXIS:
          case WidgetNameConstants.Y_AXIS: {
            consumed = widget.dispatchEvent("mouseRightClickEvent", event_6);
            break;
          }
        }
        if (consumed) {
          this._chart.updatePane(
            1
            /* UpdateLevel.Overlay */
          );
        }
      }
      return false;
    };
    Event2.prototype.mouseDoubleClickEvent = function(e) {
      var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;
      if (widget !== null) {
        var name_6 = widget.getName();
        switch (name_6) {
          case WidgetNameConstants.MAIN: {
            var event_7 = this._makeWidgetEvent(e, widget);
            return widget.dispatchEvent("mouseDoubleClickEvent", event_7);
          }
          case WidgetNameConstants.Y_AXIS: {
            var yAxis = pane.getAxisComponent();
            if (!yAxis.getAutoCalcTickFlag()) {
              yAxis.setAutoCalcTickFlag(true);
              this._chart.layout({
                measureWidth: true,
                update: true,
                buildYAxisTick: true
              });
              return true;
            }
            break;
          }
        }
      }
      return false;
    };
    Event2.prototype.mouseLeaveEvent = function() {
      this._chart.getChartStore().setCrosshair();
      return true;
    };
    Event2.prototype.touchStartEvent = function(e) {
      var _a;
      var _b = this._findWidgetByEvent(e), pane = _b.pane, widget = _b.widget;
      if (widget !== null) {
        var event_8 = this._makeWidgetEvent(e, widget);
        (_a = event_8.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event_8);
        var name_7 = widget.getName();
        switch (name_7) {
          case WidgetNameConstants.MAIN: {
            var chartStore = this._chart.getChartStore();
            if (widget.dispatchEvent("mouseDownEvent", event_8)) {
              this._touchCancelCrosshair = true;
              this._touchCoordinate = null;
              chartStore.setCrosshair(void 0, { notInvalidate: true });
              this._chart.updatePane(
                1
                /* UpdateLevel.Overlay */
              );
              return true;
            }
            if (this._flingScrollRequestId !== null) {
              cancelAnimationFrame(this._flingScrollRequestId);
              this._flingScrollRequestId = null;
            }
            this._flingStartTime = (/* @__PURE__ */ new Date()).getTime();
            var yAxis = pane.getAxisComponent();
            if (!yAxis.getAutoCalcTickFlag()) {
              var range = yAxis.getRange();
              this._prevYAxisRange = __assign({}, range);
            }
            this._startScrollCoordinate = { x: event_8.x, y: event_8.y };
            chartStore.startScroll();
            this._touchZoomed = false;
            if (this._touchCoordinate !== null) {
              var xDif = event_8.x - this._touchCoordinate.x;
              var yDif = event_8.y - this._touchCoordinate.y;
              var radius = Math.sqrt(xDif * xDif + yDif * yDif);
              if (radius < TOUCH_MIN_RADIUS) {
                this._touchCoordinate = { x: event_8.x, y: event_8.y };
                chartStore.setCrosshair({ x: event_8.x, y: event_8.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
              } else {
                this._touchCoordinate = null;
                this._touchCancelCrosshair = true;
                chartStore.setCrosshair();
              }
            }
            return true;
          }
          case WidgetNameConstants.X_AXIS: {
            return this._processXAxisScrollStartEvent(widget, event_8);
          }
          case WidgetNameConstants.Y_AXIS: {
            return this._processYAxisScaleStartEvent(widget, event_8);
          }
        }
      }
      return false;
    };
    Event2.prototype.touchMoveEvent = function(e) {
      var _a, _b, _c;
      var _d = this._findWidgetByEvent(e), pane = _d.pane, widget = _d.widget;
      if (widget !== null) {
        var event_9 = this._makeWidgetEvent(e, widget);
        var name_8 = widget.getName();
        var chartStore = this._chart.getChartStore();
        switch (name_8) {
          case WidgetNameConstants.MAIN: {
            if (widget.dispatchEvent("pressedMouseMoveEvent", event_9)) {
              (_a = event_9.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event_9);
              chartStore.setCrosshair(void 0, { notInvalidate: true });
              this._chart.updatePane(
                1
                /* UpdateLevel.Overlay */
              );
              return true;
            }
            if (this._touchCoordinate !== null) {
              (_b = event_9.preventDefault) === null || _b === void 0 ? void 0 : _b.call(event_9);
              chartStore.setCrosshair({ x: event_9.x, y: event_9.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
            } else {
              this._processMainScrollingEvent(widget, event_9);
            }
            return true;
          }
          case WidgetNameConstants.X_AXIS: {
            (_c = event_9.preventDefault) === null || _c === void 0 ? void 0 : _c.call(event_9);
            return this._processXAxisScrollingEvent(widget, event_9);
          }
          case WidgetNameConstants.Y_AXIS: {
            return this._processYAxisScalingEvent(widget, event_9);
          }
        }
      }
      return false;
    };
    Event2.prototype.touchEndEvent = function(e) {
      var _this = this;
      var widget = this._findWidgetByEvent(e).widget;
      if (widget !== null) {
        var event_10 = this._makeWidgetEvent(e, widget);
        var name_9 = widget.getName();
        switch (name_9) {
          case WidgetNameConstants.MAIN: {
            widget.dispatchEvent("mouseUpEvent", event_10);
            if (this._startScrollCoordinate !== null) {
              var time = (/* @__PURE__ */ new Date()).getTime() - this._flingStartTime;
              var distance = event_10.x - this._startScrollCoordinate.x;
              var v_1 = distance / (time > 0 ? time : 1) * 20;
              if (time < 200 && Math.abs(v_1) > 0) {
                var store_1 = this._chart.getChartStore();
                var flingScroll_1 = function() {
                  _this._flingScrollRequestId = requestAnimationFrame(function() {
                    store_1.startScroll();
                    store_1.scroll(v_1);
                    v_1 = v_1 * (1 - 0.025);
                    if (Math.abs(v_1) < 1) {
                      if (_this._flingScrollRequestId !== null) {
                        cancelAnimationFrame(_this._flingScrollRequestId);
                        _this._flingScrollRequestId = null;
                      }
                    } else {
                      flingScroll_1();
                    }
                  });
                };
                flingScroll_1();
              }
            }
            return true;
          }
          case WidgetNameConstants.X_AXIS:
          case WidgetNameConstants.Y_AXIS: {
            var consumed = widget.dispatchEvent("mouseUpEvent", event_10);
            if (consumed) {
              this._chart.updatePane(
                1
                /* UpdateLevel.Overlay */
              );
            }
          }
        }
        this._startScrollCoordinate = null;
        this._prevYAxisRange = null;
        this._xAxisStartScaleCoordinate = null;
        this._xAxisStartScaleDistance = 0;
        this._xAxisScale = 1;
        this._yAxisStartScaleDistance = 0;
      }
      return false;
    };
    Event2.prototype.tapEvent = function(e) {
      var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;
      var consumed = false;
      if (widget !== null) {
        var event_11 = this._makeWidgetEvent(e, widget);
        var result = widget.dispatchEvent("mouseClickEvent", event_11);
        if (widget.getName() === WidgetNameConstants.MAIN) {
          var event_12 = this._makeWidgetEvent(e, widget);
          var chartStore = this._chart.getChartStore();
          if (result) {
            this._touchCancelCrosshair = true;
            this._touchCoordinate = null;
            chartStore.setCrosshair(void 0, { notInvalidate: true });
            consumed = true;
          } else {
            if (!this._touchCancelCrosshair && !this._touchZoomed) {
              this._touchCoordinate = { x: event_12.x, y: event_12.y };
              chartStore.setCrosshair({ x: event_12.x, y: event_12.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() }, { notInvalidate: true });
              consumed = true;
            }
            this._touchCancelCrosshair = false;
          }
        }
        if (consumed || result) {
          this._chart.updatePane(
            1
            /* UpdateLevel.Overlay */
          );
        }
      }
      return consumed;
    };
    Event2.prototype.doubleTapEvent = function(e) {
      return this.mouseDoubleClickEvent(e);
    };
    Event2.prototype.longTapEvent = function(e) {
      var _a = this._findWidgetByEvent(e), pane = _a.pane, widget = _a.widget;
      if (widget !== null && widget.getName() === WidgetNameConstants.MAIN) {
        var event_13 = this._makeWidgetEvent(e, widget);
        this._touchCoordinate = { x: event_13.x, y: event_13.y };
        this._chart.getChartStore().setCrosshair({ x: event_13.x, y: event_13.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
        return true;
      }
      return false;
    };
    Event2.prototype._processMainScrollingEvent = function(widget, event) {
      var _a;
      if (this._startScrollCoordinate !== null) {
        var yAxis = widget.getPane().getAxisComponent();
        if (this._prevYAxisRange !== null && !yAxis.getAutoCalcTickFlag() && yAxis.scrollZoomEnabled) {
          (_a = event.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event);
          var _b = this._prevYAxisRange, from = _b.from, to = _b.to, range = _b.range;
          var distance_1 = 0;
          if (yAxis.reverse) {
            distance_1 = this._startScrollCoordinate.y - event.y;
          } else {
            distance_1 = event.y - this._startScrollCoordinate.y;
          }
          var bounding = widget.getBounding();
          var scale = distance_1 / bounding.height;
          var difRange = range * scale;
          var newFrom = from + difRange;
          var newTo = to + difRange;
          var newRealFrom = yAxis.valueToRealValue(newFrom, { range: this._prevYAxisRange });
          var newRealTo = yAxis.valueToRealValue(newTo, { range: this._prevYAxisRange });
          var newDisplayFrom = yAxis.realValueToDisplayValue(newRealFrom, { range: this._prevYAxisRange });
          var newDisplayTo = yAxis.realValueToDisplayValue(newRealTo, { range: this._prevYAxisRange });
          yAxis.setRange({
            from: newFrom,
            to: newTo,
            range: newTo - newFrom,
            realFrom: newRealFrom,
            realTo: newRealTo,
            realRange: newRealTo - newRealFrom,
            displayFrom: newDisplayFrom,
            displayTo: newDisplayTo,
            displayRange: newDisplayTo - newDisplayFrom
          });
        }
        var distance = event.x - this._startScrollCoordinate.x;
        this._chart.getChartStore().scroll(distance);
      }
    };
    Event2.prototype._processXAxisScrollStartEvent = function(widget, event) {
      var consumed = widget.dispatchEvent("mouseDownEvent", event);
      if (consumed) {
        this._chart.updatePane(
          1
          /* UpdateLevel.Overlay */
        );
      }
      this._xAxisStartScaleCoordinate = { x: event.x, y: event.y };
      this._xAxisStartScaleDistance = event.pageX;
      return consumed;
    };
    Event2.prototype._processXAxisScrollingEvent = function(widget, event) {
      var consumed = widget.dispatchEvent("pressedMouseMoveEvent", event);
      if (!consumed) {
        var xAxis = widget.getPane().getAxisComponent();
        if (xAxis.scrollZoomEnabled && this._xAxisStartScaleDistance !== 0) {
          var scale = this._xAxisStartScaleDistance / event.pageX;
          if (Number.isFinite(scale)) {
            var zoomScale = (scale - this._xAxisScale) * 10;
            this._xAxisScale = scale;
            this._chart.getChartStore().zoom(zoomScale, this._xAxisStartScaleCoordinate, "xAxis");
          }
        }
      } else {
        this._chart.updatePane(
          1
          /* UpdateLevel.Overlay */
        );
      }
      return consumed;
    };
    Event2.prototype._processYAxisScaleStartEvent = function(widget, event) {
      var consumed = widget.dispatchEvent("mouseDownEvent", event);
      if (consumed) {
        this._chart.updatePane(
          1
          /* UpdateLevel.Overlay */
        );
      }
      var range = widget.getPane().getAxisComponent().getRange();
      this._prevYAxisRange = __assign({}, range);
      this._yAxisStartScaleDistance = event.pageY;
      return consumed;
    };
    Event2.prototype._processYAxisScalingEvent = function(widget, event) {
      var _a;
      var consumed = widget.dispatchEvent("pressedMouseMoveEvent", event);
      if (!consumed) {
        var yAxis = widget.getPane().getAxisComponent();
        if (this._prevYAxisRange !== null && yAxis.scrollZoomEnabled && this._yAxisStartScaleDistance !== 0) {
          (_a = event.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event);
          var _b = this._prevYAxisRange, from = _b.from, to = _b.to, range = _b.range;
          var scale = event.pageY / this._yAxisStartScaleDistance;
          var newRange = range * scale;
          var difRange = (newRange - range) / 2;
          var newFrom = from - difRange;
          var newTo = to + difRange;
          var newRealFrom = yAxis.valueToRealValue(newFrom, { range: this._prevYAxisRange });
          var newRealTo = yAxis.valueToRealValue(newTo, { range: this._prevYAxisRange });
          var newDisplayFrom = yAxis.realValueToDisplayValue(newRealFrom, { range: this._prevYAxisRange });
          var newDisplayTo = yAxis.realValueToDisplayValue(newRealTo, { range: this._prevYAxisRange });
          yAxis.setRange({
            from: newFrom,
            to: newTo,
            range: newRange,
            realFrom: newRealFrom,
            realTo: newRealTo,
            realRange: newRealTo - newRealFrom,
            displayFrom: newDisplayFrom,
            displayTo: newDisplayTo,
            displayRange: newDisplayTo - newDisplayFrom
          });
          this._chart.layout({
            measureWidth: true,
            update: true,
            buildYAxisTick: true
          });
        }
      } else {
        this._chart.updatePane(
          1
          /* UpdateLevel.Overlay */
        );
      }
      return consumed;
    };
    Event2.prototype._findWidgetByEvent = function(event) {
      var e_1, _a, e_2, _b;
      var x = event.x, y = event.y;
      var separatorPanes = this._chart.getSeparatorPanes();
      var separatorSize = this._chart.getStyles().separator.size;
      try {
        for (var separatorPanes_1 = __values(separatorPanes), separatorPanes_1_1 = separatorPanes_1.next(); !separatorPanes_1_1.done; separatorPanes_1_1 = separatorPanes_1.next()) {
          var items = separatorPanes_1_1.value;
          var pane_1 = items[1];
          var bounding = pane_1.getBounding();
          var top_1 = bounding.top - Math.round((REAL_SEPARATOR_HEIGHT - separatorSize) / 2);
          if (x >= bounding.left && x <= bounding.left + bounding.width && y >= top_1 && y <= top_1 + REAL_SEPARATOR_HEIGHT) {
            return { pane: pane_1, widget: pane_1.getWidget() };
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (separatorPanes_1_1 && !separatorPanes_1_1.done && (_a = separatorPanes_1.return)) _a.call(separatorPanes_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      var drawPanes = this._chart.getDrawPanes();
      var pane = null;
      try {
        for (var drawPanes_1 = __values(drawPanes), drawPanes_1_1 = drawPanes_1.next(); !drawPanes_1_1.done; drawPanes_1_1 = drawPanes_1.next()) {
          var p = drawPanes_1_1.value;
          var bounding = p.getBounding();
          if (x >= bounding.left && x <= bounding.left + bounding.width && y >= bounding.top && y <= bounding.top + bounding.height) {
            pane = p;
            break;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (drawPanes_1_1 && !drawPanes_1_1.done && (_b = drawPanes_1.return)) _b.call(drawPanes_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      var widget = null;
      if (pane !== null) {
        if (!isValid(widget)) {
          var mainWidget = pane.getMainWidget();
          var mainBounding = mainWidget.getBounding();
          if (x >= mainBounding.left && x <= mainBounding.left + mainBounding.width && y >= mainBounding.top && y <= mainBounding.top + mainBounding.height) {
            widget = mainWidget;
          }
        }
        if (!isValid(widget)) {
          var yAxisWidget = pane.getYAxisWidget();
          if (yAxisWidget !== null) {
            var yAxisBounding = yAxisWidget.getBounding();
            if (x >= yAxisBounding.left && x <= yAxisBounding.left + yAxisBounding.width && y >= yAxisBounding.top && y <= yAxisBounding.top + yAxisBounding.height) {
              widget = yAxisWidget;
            }
          }
        }
      }
      return { pane, widget };
    };
    Event2.prototype._makeWidgetEvent = function(event, widget) {
      var _a, _b, _c;
      var bounding = (_a = widget === null || widget === void 0 ? void 0 : widget.getBounding()) !== null && _a !== void 0 ? _a : null;
      return __assign(__assign({}, event), { x: event.x - ((_b = bounding === null || bounding === void 0 ? void 0 : bounding.left) !== null && _b !== void 0 ? _b : 0), y: event.y - ((_c = bounding === null || bounding === void 0 ? void 0 : bounding.top) !== null && _c !== void 0 ? _c : 0) });
    };
    Event2.prototype.destroy = function() {
      this._container.removeEventListener("keydown", this._boundKeyBoardDownEvent);
      this._event.destroy();
    };
    return Event2;
  }()
);
var ChartImp = (
  /** @class */
  function() {
    function ChartImp2(container, options) {
      this._chartBounding = createDefaultBounding();
      this._drawPanes = [];
      this._separatorPanes = /* @__PURE__ */ new Map();
      this._layoutOptions = {
        sort: true,
        measureHeight: true,
        measureWidth: true,
        update: true,
        buildYAxisTick: false,
        cacheYAxisWidth: false,
        forceBuildYAxisTick: false
      };
      this._layoutPending = false;
      this._cacheYAxisWidth = { left: 0, right: 0 };
      this._initContainer(container);
      this._chartEvent = new Event(this._chartContainer, this);
      this._chartStore = new StoreImp(this, options);
      this._initPanes(options);
      this._layout();
    }
    ChartImp2.prototype._initContainer = function(container) {
      this._container = container;
      this._chartContainer = createDom("div", {
        position: "relative",
        width: "100%",
        height: "100%",
        outline: "none",
        borderStyle: "none",
        cursor: "crosshair",
        boxSizing: "border-box",
        userSelect: "none",
        webkitUserSelect: "none",
        overflow: "hidden",
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- ignore
        // @ts-expect-error
        msUserSelect: "none",
        MozUserSelect: "none",
        webkitTapHighlightColor: "transparent"
      });
      this._chartContainer.tabIndex = 1;
      container.appendChild(this._chartContainer);
      this._cacheChartBounding();
    };
    ChartImp2.prototype._cacheChartBounding = function() {
      this._chartBounding.width = Math.floor(this._chartContainer.clientWidth);
      this._chartBounding.height = Math.floor(this._chartContainer.clientHeight);
    };
    ChartImp2.prototype._initPanes = function(options) {
      var _this = this;
      var _a;
      var layout = (_a = options === null || options === void 0 ? void 0 : options.layout) !== null && _a !== void 0 ? _a : [{ type: "candle" }];
      var createCandlePane = function(child) {
        var _a2, _b;
        if (!isValid(_this._candlePane)) {
          var paneOptions_1 = (_a2 = child.options) !== null && _a2 !== void 0 ? _a2 : {};
          merge(paneOptions_1, { id: PaneIdConstants.CANDLE });
          _this._candlePane = _this._createPane(CandlePane, PaneIdConstants.CANDLE, paneOptions_1);
          var content = (_b = child.content) !== null && _b !== void 0 ? _b : [];
          content.forEach(function(v) {
            _this.createIndicator(v, true, paneOptions_1);
          });
        }
      };
      var createXAxisPane = function(ops) {
        if (!isValid(_this._xAxisPane)) {
          var pane = _this._createPane(XAxisPane, PaneIdConstants.X_AXIS, ops !== null && ops !== void 0 ? ops : {});
          _this._xAxisPane = pane;
        }
      };
      layout.forEach(function(child) {
        var _a2, _b, _c;
        switch (child.type) {
          case "candle": {
            createCandlePane(child);
            break;
          }
          case "indicator": {
            var content = (_a2 = child.content) !== null && _a2 !== void 0 ? _a2 : [];
            if (content.length > 0) {
              var paneId = (_c = (_b = child.options) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : null;
              if (isValid(paneId)) {
                paneId = createId(PaneIdConstants.INDICATOR);
              }
              var paneOptions_2 = __assign(__assign({}, child.options), { id: paneId });
              content.forEach(function(v) {
                _this.createIndicator(v, true, paneOptions_2);
              });
            }
            break;
          }
          case "xAxis": {
            createXAxisPane(child.options);
            break;
          }
        }
      });
      createCandlePane({});
      createXAxisPane({ order: Number.MAX_SAFE_INTEGER });
    };
    ChartImp2.prototype._createPane = function(DrawPaneClass, id, options) {
      var pane = new DrawPaneClass(this, id, options !== null && options !== void 0 ? options : {});
      this._drawPanes.push(pane);
      return pane;
    };
    ChartImp2.prototype._recalculatePaneHeight = function(currentPane, currentHeight, changeHeight) {
      if (changeHeight === 0) {
        return false;
      }
      var normalStatePanes = this._drawPanes.filter(function(pane) {
        var paneId = pane.getId();
        return pane.getOptions().state === "normal" && paneId !== currentPane.getId() && paneId !== PaneIdConstants.X_AXIS;
      });
      var count = normalStatePanes.length;
      if (count === 0) {
        return false;
      }
      if (currentPane.getId() !== PaneIdConstants.CANDLE && isValid(this._candlePane) && this._candlePane.getOptions().state === "normal") {
        var height = this._candlePane.getBounding().height;
        if (height > 0) {
          var minHeight = this._candlePane.getOptions().minHeight;
          var newHeight = height + changeHeight;
          if (newHeight < minHeight) {
            newHeight = minHeight;
            currentHeight -= height + changeHeight - newHeight;
          }
          this._candlePane.setBounding({ height: newHeight });
        }
      } else {
        var remainingHeight_1 = changeHeight;
        var normalStatePaneChangeHeight_1 = Math.floor(changeHeight / count);
        normalStatePanes.forEach(function(pane, index) {
          var height2 = pane.getBounding().height;
          var newHeight2 = 0;
          if (index === count - 1) {
            newHeight2 = height2 + remainingHeight_1;
          } else {
            newHeight2 = height2 + normalStatePaneChangeHeight_1;
          }
          if (newHeight2 < pane.getOptions().minHeight) {
            newHeight2 = pane.getOptions().minHeight;
          }
          pane.setBounding({ height: newHeight2 });
          remainingHeight_1 -= newHeight2 - height2;
        });
        if (Math.abs(remainingHeight_1) > 0) {
          currentHeight -= remainingHeight_1;
        }
      }
      currentPane.setBounding({ height: currentHeight });
      return true;
    };
    ChartImp2.prototype.getDrawPaneById = function(paneId) {
      if (paneId === PaneIdConstants.CANDLE) {
        return this._candlePane;
      }
      if (paneId === PaneIdConstants.X_AXIS) {
        return this._xAxisPane;
      }
      var pane = this._drawPanes.find(function(p) {
        return p.getId() === paneId;
      });
      return pane !== null && pane !== void 0 ? pane : null;
    };
    ChartImp2.prototype.getContainer = function() {
      return this._container;
    };
    ChartImp2.prototype.getChartStore = function() {
      return this._chartStore;
    };
    ChartImp2.prototype.getXAxisPane = function() {
      return this._xAxisPane;
    };
    ChartImp2.prototype.getDrawPanes = function() {
      return this._drawPanes;
    };
    ChartImp2.prototype.getSeparatorPanes = function() {
      return this._separatorPanes;
    };
    ChartImp2.prototype.layout = function(options) {
      var _this = this;
      var _a, _b, _c, _d, _e, _f, _g;
      if ((_a = options.sort) !== null && _a !== void 0 ? _a : false) {
        this._layoutOptions.sort = options.sort;
      }
      if ((_b = options.measureHeight) !== null && _b !== void 0 ? _b : false) {
        this._layoutOptions.measureHeight = options.measureHeight;
      }
      if ((_c = options.measureWidth) !== null && _c !== void 0 ? _c : false) {
        this._layoutOptions.measureWidth = options.measureWidth;
      }
      if ((_d = options.update) !== null && _d !== void 0 ? _d : false) {
        this._layoutOptions.update = options.update;
      }
      if ((_e = options.buildYAxisTick) !== null && _e !== void 0 ? _e : false) {
        this._layoutOptions.buildYAxisTick = options.buildYAxisTick;
      }
      if ((_f = options.cacheYAxisWidth) !== null && _f !== void 0 ? _f : false) {
        this._layoutOptions.cacheYAxisWidth = options.cacheYAxisWidth;
      }
      if ((_g = options.buildYAxisTick) !== null && _g !== void 0 ? _g : false) {
        this._layoutOptions.forceBuildYAxisTick = options.forceBuildYAxisTick;
      }
      if (!this._layoutPending) {
        this._layoutPending = true;
        Promise.resolve().then(function(_) {
          _this._layout();
          _this._layoutPending = false;
        }).catch(function(_) {
        });
      }
    };
    ChartImp2.prototype._layout = function() {
      var _this = this;
      var _a = this._layoutOptions, sort = _a.sort, measureHeight = _a.measureHeight, measureWidth = _a.measureWidth, update = _a.update, buildYAxisTick = _a.buildYAxisTick, cacheYAxisWidth = _a.cacheYAxisWidth, forceBuildYAxisTick = _a.forceBuildYAxisTick;
      if (sort) {
        while (isValid(this._chartContainer.firstChild)) {
          this._chartContainer.removeChild(this._chartContainer.firstChild);
        }
        this._separatorPanes.clear();
        this._drawPanes.sort(function(a, b) {
          return a.getOptions().order - b.getOptions().order;
        });
        var prevPane_1 = null;
        this._drawPanes.forEach(function(pane) {
          if (pane.getId() !== PaneIdConstants.X_AXIS) {
            if (isValid(prevPane_1)) {
              var separatorPane = new SeparatorPane(_this, "", prevPane_1, pane);
              _this._chartContainer.appendChild(separatorPane.getContainer());
              _this._separatorPanes.set(pane, separatorPane);
            }
            prevPane_1 = pane;
          }
          _this._chartContainer.appendChild(pane.getContainer());
        });
      }
      if (measureHeight) {
        var totalHeight = this._chartBounding.height;
        var separatorSize_1 = this.getStyles().separator.size;
        var xAxisHeight = this._xAxisPane.getAxisComponent().getAutoSize();
        var remainingHeight_2 = totalHeight - xAxisHeight;
        if (remainingHeight_2 < 0) {
          remainingHeight_2 = 0;
        }
        this._drawPanes.forEach(function(pane) {
          var paneId = pane.getId();
          if (isValid(_this._separatorPanes.get(pane))) {
            remainingHeight_2 -= separatorSize_1;
          }
          if (paneId !== PaneIdConstants.X_AXIS && paneId !== PaneIdConstants.CANDLE && pane.getVisible()) {
            var paneHeight = pane.getBounding().height;
            if (paneHeight > remainingHeight_2) {
              paneHeight = remainingHeight_2;
              remainingHeight_2 = 0;
            } else {
              remainingHeight_2 -= paneHeight;
            }
            pane.setBounding({ height: paneHeight });
          }
        });
        this._candlePane.setBounding({ height: Math.max(remainingHeight_2, 0) });
        this._xAxisPane.setBounding({ height: xAxisHeight });
        var top_1 = 0;
        this._drawPanes.forEach(function(pane) {
          var separatorPane = _this._separatorPanes.get(pane);
          if (isValid(separatorPane)) {
            separatorPane.setBounding({ height: separatorSize_1, top: top_1 });
            top_1 += separatorSize_1;
          }
          pane.setBounding({ top: top_1 });
          top_1 += pane.getBounding().height;
        });
      }
      var forceMeasureWidth = measureWidth;
      if (buildYAxisTick || forceBuildYAxisTick) {
        this._drawPanes.forEach(function(pane) {
          var success = pane.getAxisComponent().buildTicks(forceBuildYAxisTick);
          forceMeasureWidth || (forceMeasureWidth = success);
        });
      }
      if (forceMeasureWidth) {
        var totalWidth = this._chartBounding.width;
        var styles2 = this.getStyles();
        var leftYAxisWidth_1 = 0;
        var leftYAxisOutside_1 = true;
        var rightYAxisWidth_1 = 0;
        var rightYAxisOutside_1 = true;
        this._drawPanes.forEach(function(pane) {
          if (pane.getId() !== PaneIdConstants.X_AXIS) {
            var yAxis = pane.getAxisComponent();
            var inside = yAxis.inside;
            var yAxisWidth = yAxis.getAutoSize();
            if (yAxis.position === "left") {
              leftYAxisWidth_1 = Math.max(leftYAxisWidth_1, yAxisWidth);
              if (inside) {
                leftYAxisOutside_1 = false;
              }
            } else {
              rightYAxisWidth_1 = Math.max(rightYAxisWidth_1, yAxisWidth);
              if (inside) {
                rightYAxisOutside_1 = false;
              }
            }
          }
        });
        if (cacheYAxisWidth) {
          leftYAxisWidth_1 = Math.max(this._cacheYAxisWidth.left, leftYAxisWidth_1);
          rightYAxisWidth_1 = Math.max(this._cacheYAxisWidth.right, rightYAxisWidth_1);
        }
        this._cacheYAxisWidth.left = leftYAxisWidth_1;
        this._cacheYAxisWidth.right = rightYAxisWidth_1;
        var mainWidth = totalWidth;
        var mainLeft = 0;
        var mainRight = 0;
        if (leftYAxisOutside_1) {
          mainWidth -= leftYAxisWidth_1;
          mainLeft = leftYAxisWidth_1;
        }
        if (rightYAxisOutside_1) {
          mainWidth -= rightYAxisWidth_1;
          mainRight = rightYAxisWidth_1;
        }
        this._chartStore.setTotalBarSpace(mainWidth);
        var paneBounding_1 = { width: totalWidth };
        var mainBounding_1 = { width: mainWidth, left: mainLeft, right: mainRight };
        var leftYAxisBounding_1 = { width: leftYAxisWidth_1 };
        var rightYAxisBounding_1 = { width: rightYAxisWidth_1 };
        var separatorFill = styles2.separator.fill;
        var separatorBounding_1 = {};
        if (!separatorFill) {
          separatorBounding_1 = mainBounding_1;
        } else {
          separatorBounding_1 = paneBounding_1;
        }
        this._drawPanes.forEach(function(pane) {
          var _a2;
          (_a2 = _this._separatorPanes.get(pane)) === null || _a2 === void 0 ? void 0 : _a2.setBounding(separatorBounding_1);
          pane.setBounding(paneBounding_1, mainBounding_1, leftYAxisBounding_1, rightYAxisBounding_1);
        });
      }
      if (update) {
        this._xAxisPane.getAxisComponent().buildTicks(true);
        this.updatePane(
          4
          /* UpdateLevel.All */
        );
      }
      this._layoutOptions = {
        sort: false,
        measureHeight: false,
        measureWidth: false,
        update: false,
        buildYAxisTick: false,
        cacheYAxisWidth: false,
        forceBuildYAxisTick: false
      };
    };
    ChartImp2.prototype.updatePane = function(level, paneId) {
      var _this = this;
      if (isValid(paneId)) {
        var pane = this.getDrawPaneById(paneId);
        pane === null || pane === void 0 ? void 0 : pane.update(level);
      } else {
        this._drawPanes.forEach(function(pane2) {
          var _a;
          pane2.update(level);
          (_a = _this._separatorPanes.get(pane2)) === null || _a === void 0 ? void 0 : _a.update(level);
        });
      }
    };
    ChartImp2.prototype.getDom = function(paneId, position) {
      var _a, _b;
      if (isValid(paneId)) {
        var pane = this.getDrawPaneById(paneId);
        if (isValid(pane)) {
          var pos = position !== null && position !== void 0 ? position : "root";
          switch (pos) {
            case "root": {
              return pane.getContainer();
            }
            case "main": {
              return pane.getMainWidget().getContainer();
            }
            case "yAxis": {
              return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getContainer()) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      } else {
        return this._chartContainer;
      }
      return null;
    };
    ChartImp2.prototype.getSize = function(paneId, position) {
      var _a, _b;
      if (isValid(paneId)) {
        var pane = this.getDrawPaneById(paneId);
        if (isValid(pane)) {
          var pos = position !== null && position !== void 0 ? position : "root";
          switch (pos) {
            case "root": {
              return pane.getBounding();
            }
            case "main": {
              return pane.getMainWidget().getBounding();
            }
            case "yAxis": {
              return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding()) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      } else {
        return this._chartBounding;
      }
      return null;
    };
    ChartImp2.prototype._resetYAxisAutoCalcTickFlag = function() {
      this._drawPanes.forEach(function(pane) {
        pane.getAxisComponent().setAutoCalcTickFlag(true);
      });
    };
    ChartImp2.prototype.setSymbol = function(symbol) {
      if (symbol !== this.getSymbol()) {
        this._resetYAxisAutoCalcTickFlag();
        this._chartStore.setSymbol(symbol);
      }
    };
    ChartImp2.prototype.getSymbol = function() {
      return this._chartStore.getSymbol();
    };
    ChartImp2.prototype.setPeriod = function(period) {
      if (period !== this.getPeriod()) {
        this._resetYAxisAutoCalcTickFlag();
        this._chartStore.setPeriod(period);
      }
    };
    ChartImp2.prototype.getPeriod = function() {
      return this._chartStore.getPeriod();
    };
    ChartImp2.prototype.setStyles = function(value) {
      var _this = this;
      this._setOptions(function() {
        _this._chartStore.setStyles(value);
      });
    };
    ChartImp2.prototype.getStyles = function() {
      return this._chartStore.getStyles();
    };
    ChartImp2.prototype.setFormatter = function(formatter) {
      var _this = this;
      this._setOptions(function() {
        _this._chartStore.setFormatter(formatter);
      });
    };
    ChartImp2.prototype.getFormatter = function() {
      return this._chartStore.getFormatter();
    };
    ChartImp2.prototype.setLocale = function(locale) {
      var _this = this;
      this._setOptions(function() {
        _this._chartStore.setLocale(locale);
      });
    };
    ChartImp2.prototype.getLocale = function() {
      return this._chartStore.getLocale();
    };
    ChartImp2.prototype.setTimezone = function(timezone) {
      var _this = this;
      this._setOptions(function() {
        _this._chartStore.setTimezone(timezone);
      });
    };
    ChartImp2.prototype.getTimezone = function() {
      return this._chartStore.getTimezone();
    };
    ChartImp2.prototype.setThousandsSeparator = function(thousandsSeparator) {
      var _this = this;
      this._setOptions(function() {
        _this._chartStore.setThousandsSeparator(thousandsSeparator);
      });
    };
    ChartImp2.prototype.getThousandsSeparator = function() {
      return this._chartStore.getThousandsSeparator();
    };
    ChartImp2.prototype.setDecimalFold = function(decimalFold) {
      var _this = this;
      this._setOptions(function() {
        _this._chartStore.setDecimalFold(decimalFold);
      });
    };
    ChartImp2.prototype.getDecimalFold = function() {
      return this._chartStore.getDecimalFold();
    };
    ChartImp2.prototype._setOptions = function(fuc) {
      fuc();
      this.layout({
        measureHeight: true,
        measureWidth: true,
        update: true,
        buildYAxisTick: true,
        forceBuildYAxisTick: true
      });
    };
    ChartImp2.prototype.setOffsetRightDistance = function(distance) {
      this._chartStore.setOffsetRightDistance(distance, true);
    };
    ChartImp2.prototype.getOffsetRightDistance = function() {
      return this._chartStore.getOffsetRightDistance();
    };
    ChartImp2.prototype.setMaxOffsetLeftDistance = function(distance) {
      if (distance < 0) {
        logWarn("setMaxOffsetLeftDistance", "distance", "distance must greater than zero!!!");
        return;
      }
      this._chartStore.setMaxOffsetLeftDistance(distance);
    };
    ChartImp2.prototype.setMaxOffsetRightDistance = function(distance) {
      if (distance < 0) {
        logWarn("setMaxOffsetRightDistance", "distance", "distance must greater than zero!!!");
        return;
      }
      this._chartStore.setMaxOffsetRightDistance(distance);
    };
    ChartImp2.prototype.setLeftMinVisibleBarCount = function(barCount) {
      if (barCount < 0) {
        logWarn("setLeftMinVisibleBarCount", "barCount", "barCount must greater than zero!!!");
        return;
      }
      this._chartStore.setLeftMinVisibleBarCount(Math.ceil(barCount));
    };
    ChartImp2.prototype.setRightMinVisibleBarCount = function(barCount) {
      if (barCount < 0) {
        logWarn("setRightMinVisibleBarCount", "barCount", "barCount must greater than zero!!!");
        return;
      }
      this._chartStore.setRightMinVisibleBarCount(Math.ceil(barCount));
    };
    ChartImp2.prototype.setBarSpace = function(space) {
      this._chartStore.setBarSpace(space);
    };
    ChartImp2.prototype.getBarSpace = function() {
      return this._chartStore.getBarSpace();
    };
    ChartImp2.prototype.getVisibleRange = function() {
      return this._chartStore.getVisibleRange();
    };
    ChartImp2.prototype.resetData = function() {
      this._chartStore.resetData();
    };
    ChartImp2.prototype.getDataList = function() {
      return this._chartStore.getDataList();
    };
    ChartImp2.prototype.setDataLoader = function(dataLoader) {
      this._resetYAxisAutoCalcTickFlag();
      this._chartStore.setDataLoader(dataLoader);
    };
    ChartImp2.prototype.createIndicator = function(value, isStack, paneOptions) {
      var _a;
      var indicator = isString(value) ? { name: value } : value;
      if (getIndicatorClass(indicator.name) === null) {
        logWarn("createIndicator", "value", "indicator not supported, you may need to use registerIndicator to add one!!!");
        return null;
      }
      var paneOpts = paneOptions !== null && paneOptions !== void 0 ? paneOptions : {};
      if (!isString(paneOpts.id)) {
        paneOpts.id = createId(PaneIdConstants.INDICATOR);
      }
      if (!isString(indicator.id)) {
        indicator.id = createId(indicator.name);
      }
      var result = this._chartStore.addIndicator(indicator, paneOpts.id, isStack !== null && isStack !== void 0 ? isStack : false);
      if (result) {
        var shouldSort = false;
        if (!isValid(this.getDrawPaneById(paneOpts.id))) {
          this._createPane(IndicatorPane, paneOpts.id, paneOpts);
          (_a = paneOpts.height) !== null && _a !== void 0 ? _a : paneOpts.height = PANE_DEFAULT_HEIGHT;
          shouldSort = true;
        }
        this.setPaneOptions(paneOpts);
        this.layout({
          sort: shouldSort,
          measureHeight: true,
          measureWidth: true,
          update: true,
          buildYAxisTick: true,
          forceBuildYAxisTick: true
        });
        return indicator.id;
      }
      return null;
    };
    ChartImp2.prototype.overrideIndicator = function(override) {
      return this._chartStore.overrideIndicator(override);
    };
    ChartImp2.prototype.getIndicators = function(filter) {
      return this._chartStore.getIndicatorsByFilter(filter !== null && filter !== void 0 ? filter : {});
    };
    ChartImp2.prototype.removeIndicator = function(filter) {
      var _this = this;
      var removed = this._chartStore.removeIndicator(filter !== null && filter !== void 0 ? filter : {});
      if (removed) {
        var shouldMeasureHeight_1 = false;
        var paneIds_1 = [];
        this._drawPanes.forEach(function(pane) {
          var paneId = pane.getId();
          if (paneId !== PaneIdConstants.CANDLE && paneId !== PaneIdConstants.X_AXIS) {
            paneIds_1.push(paneId);
          }
        });
        paneIds_1.forEach(function(paneId) {
          if (!_this._chartStore.hasIndicators(paneId)) {
            var index = _this._drawPanes.findIndex(function(pane2) {
              return pane2.getId() === paneId;
            });
            var pane = _this._drawPanes[index];
            if (isValid(pane)) {
              shouldMeasureHeight_1 = true;
              _this._recalculatePaneHeight(pane, 0, pane.getBounding().height);
              _this._drawPanes.splice(index, 1);
              pane.destroy();
            }
          }
        });
        if (this._drawPanes.length === 2) {
          this._candlePane.setVisible(true);
          this._candlePane.setBounding({ height: this._chartBounding.height - this._xAxisPane.getBounding().height });
        }
        this.layout({
          sort: shouldMeasureHeight_1,
          measureHeight: shouldMeasureHeight_1,
          measureWidth: true,
          update: true,
          buildYAxisTick: true,
          forceBuildYAxisTick: true
        });
      }
      return removed;
    };
    ChartImp2.prototype.createOverlay = function(value) {
      var _this = this;
      var overlays2 = [];
      var appointPaneFlags = [];
      var build = function(overlay) {
        if (!isValid(overlay.paneId) || _this.getDrawPaneById(overlay.paneId) === null) {
          overlay.paneId = PaneIdConstants.CANDLE;
          appointPaneFlags.push(false);
        } else {
          appointPaneFlags.push(true);
        }
        overlays2.push(overlay);
      };
      if (isString(value)) {
        build({ name: value });
      } else if (isArray(value)) {
        value.forEach(function(v) {
          var overlay = null;
          if (isString(v)) {
            overlay = { name: v };
          } else {
            overlay = v;
          }
          build(overlay);
        });
      } else {
        build(value);
      }
      var ids = this._chartStore.addOverlays(overlays2, appointPaneFlags);
      if (isArray(value)) {
        return ids;
      }
      return ids[0];
    };
    ChartImp2.prototype.getOverlays = function(filter) {
      return this._chartStore.getOverlaysByFilter(filter !== null && filter !== void 0 ? filter : {});
    };
    ChartImp2.prototype.overrideOverlay = function(override) {
      return this._chartStore.overrideOverlay(override);
    };
    ChartImp2.prototype.removeOverlay = function(filter) {
      return this._chartStore.removeOverlay(filter !== null && filter !== void 0 ? filter : {});
    };
    ChartImp2.prototype.setPaneOptions = function(options) {
      var e_1, _a;
      var _this = this;
      var _b;
      var shouldMeasureHeight = false;
      var shouldLayout = false;
      var validId = isValid(options.id);
      var _loop_1 = function(currentPane2) {
        var currentPaneId = currentPane2.getId();
        if (validId && options.id === currentPaneId || !validId) {
          if (currentPaneId !== PaneIdConstants.X_AXIS) {
            if (isNumber(options.height) && options.height > 0) {
              var minHeight = Math.max((_b = options.minHeight) !== null && _b !== void 0 ? _b : currentPane2.getOptions().minHeight, 0);
              var height = Math.max(minHeight, options.height);
              shouldLayout = true;
              shouldMeasureHeight = true;
              currentPane2.setOriginalBounding({ height });
              this_1._recalculatePaneHeight(currentPane2, height, -height);
            }
            if (isValid(options.state) && currentPane2.getOptions().state !== options.state) {
              shouldMeasureHeight = true;
              shouldLayout = true;
              var state = options.state;
              switch (state) {
                case "maximize": {
                  var maximizePane = this_1._drawPanes.find(function(pane) {
                    var paneId = pane.getId();
                    return pane.getOptions().state === "maximize" && paneId !== PaneIdConstants.X_AXIS;
                  });
                  if (!isValid(maximizePane)) {
                    if (currentPane2.getOptions().state === "normal") {
                      currentPane2.setOriginalBounding({ height: currentPane2.getBounding().height });
                    }
                    currentPane2.setOptions({ state });
                    var totalHeight = this_1._chartBounding.height;
                    currentPane2.setBounding({ height: totalHeight - this_1._xAxisPane.getBounding().height });
                    this_1._drawPanes.forEach(function(pane) {
                      var _a2;
                      if (pane.getId() !== PaneIdConstants.X_AXIS && pane.getId() !== currentPaneId) {
                        pane.setBounding({ height: pane.getOriginalBounding().height });
                        pane.setVisible(false);
                        (_a2 = _this._separatorPanes.get(pane)) === null || _a2 === void 0 ? void 0 : _a2.setVisible(false);
                      }
                    });
                  }
                  break;
                }
                case "minimize": {
                  var height = currentPane2.getBounding().height;
                  var currentState = currentPane2.getOptions().state;
                  var changeHeight = height - PANE_MIN_HEIGHT;
                  if (currentState === "maximize") {
                    changeHeight = currentPane2.getOriginalBounding().height - PANE_MIN_HEIGHT;
                  }
                  if (this_1._recalculatePaneHeight(currentPane2, PANE_MIN_HEIGHT, changeHeight)) {
                    if (currentState === "normal") {
                      currentPane2.setOriginalBounding({ height });
                    }
                    currentPane2.setOptions({ state });
                  }
                  this_1._drawPanes.forEach(function(pane) {
                    var _a2;
                    if (pane.getId() !== PaneIdConstants.X_AXIS) {
                      pane.setVisible(true);
                      (_a2 = _this._separatorPanes.get(pane)) === null || _a2 === void 0 ? void 0 : _a2.setVisible(true);
                    }
                  });
                  break;
                }
                default: {
                  var height = currentPane2.getOriginalBounding().height;
                  if (this_1._recalculatePaneHeight(currentPane2, height, currentPane2.getBounding().height - height)) {
                    currentPane2.setOptions({ state });
                  }
                  this_1._drawPanes.forEach(function(pane) {
                    var _a2;
                    if (pane.getId() !== PaneIdConstants.X_AXIS) {
                      pane.setVisible(true);
                      (_a2 = _this._separatorPanes.get(pane)) === null || _a2 === void 0 ? void 0 : _a2.setVisible(true);
                    }
                  });
                  break;
                }
              }
            }
          }
          if (isValid(options.axis)) {
            shouldLayout = true;
          }
          var ops = __assign({}, options);
          delete ops.state;
          currentPane2.setOptions(ops);
          if (currentPaneId === options.id) {
            return "break";
          }
        }
      };
      var this_1 = this;
      try {
        for (var _c = __values(this._drawPanes), _d = _c.next(); !_d.done; _d = _c.next()) {
          var currentPane = _d.value;
          var state_1 = _loop_1(currentPane);
          if (state_1 === "break")
            break;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (shouldLayout) {
        this.layout({
          measureHeight: shouldMeasureHeight,
          measureWidth: true,
          update: true,
          buildYAxisTick: true,
          forceBuildYAxisTick: true
        });
      }
    };
    ChartImp2.prototype.getPaneOptions = function(id) {
      var _a;
      if (isValid(id)) {
        var pane = this.getDrawPaneById(id);
        return (_a = pane === null || pane === void 0 ? void 0 : pane.getOptions()) !== null && _a !== void 0 ? _a : null;
      }
      return this._drawPanes.map(function(pane2) {
        return pane2.getOptions();
      });
    };
    ChartImp2.prototype.setZoomEnabled = function(enabled) {
      this._chartStore.setZoomEnabled(enabled);
    };
    ChartImp2.prototype.isZoomEnabled = function() {
      return this._chartStore.isZoomEnabled();
    };
    ChartImp2.prototype.setZoomAnchor = function(anchor) {
      this._chartStore.setZoomAnchor(anchor);
    };
    ChartImp2.prototype.getZoomAnchor = function() {
      return this._chartStore.getZoomAnchor();
    };
    ChartImp2.prototype.setScrollEnabled = function(enabled) {
      this._chartStore.setScrollEnabled(enabled);
    };
    ChartImp2.prototype.isScrollEnabled = function() {
      return this._chartStore.isScrollEnabled();
    };
    ChartImp2.prototype.scrollByDistance = function(distance, animationDuration) {
      var _this = this;
      var duration = isNumber(animationDuration) && animationDuration > 0 ? animationDuration : 0;
      this._chartStore.startScroll();
      if (duration > 0) {
        var animation = new Animation({ duration });
        animation.doFrame(function(frameTime) {
          var progressDistance = distance * (frameTime / duration);
          _this._chartStore.scroll(progressDistance);
        });
        animation.start();
      } else {
        this._chartStore.scroll(distance);
      }
    };
    ChartImp2.prototype.scrollToRealTime = function(animationDuration) {
      var barSpace = this._chartStore.getBarSpace().bar;
      var difBarCount = this._chartStore.getLastBarRightSideDiffBarCount() - this._chartStore.getInitialOffsetRightDistance() / barSpace;
      var distance = difBarCount * barSpace;
      this.scrollByDistance(distance, animationDuration);
    };
    ChartImp2.prototype.scrollToDataIndex = function(dataIndex, animationDuration) {
      var distance = (this._chartStore.getLastBarRightSideDiffBarCount() + (this.getDataList().length - 1 - dataIndex)) * this._chartStore.getBarSpace().bar;
      this.scrollByDistance(distance, animationDuration);
    };
    ChartImp2.prototype.scrollToTimestamp = function(timestamp, animationDuration) {
      var dataIndex = binarySearchNearest(this.getDataList(), "timestamp", timestamp);
      this.scrollToDataIndex(dataIndex, animationDuration);
    };
    ChartImp2.prototype.zoomAtCoordinate = function(scale, coordinate, animationDuration) {
      var _this = this;
      var duration = isNumber(animationDuration) && animationDuration > 0 ? animationDuration : 0;
      var barSpace = this._chartStore.getBarSpace().bar;
      var scaleBarSpace = barSpace * scale;
      var difSpace = scaleBarSpace - barSpace;
      if (duration > 0) {
        var prevProgressBarSpace_1 = 0;
        var animation = new Animation({ duration });
        animation.doFrame(function(frameTime) {
          var progressBarSpace = difSpace * (frameTime / duration);
          var scale2 = (progressBarSpace - prevProgressBarSpace_1) / _this._chartStore.getBarSpace().bar * SCALE_MULTIPLIER;
          _this._chartStore.zoom(scale2, coordinate !== null && coordinate !== void 0 ? coordinate : null, "main");
          prevProgressBarSpace_1 = progressBarSpace;
        });
        animation.start();
      } else {
        this._chartStore.zoom(difSpace / barSpace * SCALE_MULTIPLIER, coordinate !== null && coordinate !== void 0 ? coordinate : null, "main");
      }
    };
    ChartImp2.prototype.zoomAtDataIndex = function(scale, dataIndex, animationDuration) {
      var x = this._chartStore.dataIndexToCoordinate(dataIndex);
      this.zoomAtCoordinate(scale, { x, y: 0 }, animationDuration);
    };
    ChartImp2.prototype.zoomAtTimestamp = function(scale, timestamp, animationDuration) {
      var dataIndex = binarySearchNearest(this.getDataList(), "timestamp", timestamp);
      this.zoomAtDataIndex(scale, dataIndex, animationDuration);
    };
    ChartImp2.prototype.convertToPixel = function(points, filter) {
      var _this = this;
      var _a;
      var _b = filter !== null && filter !== void 0 ? filter : {}, _c = _b.paneId, paneId = _c === void 0 ? PaneIdConstants.CANDLE : _c, _d = _b.absolute, absolute = _d === void 0 ? false : _d;
      var coordinates = [];
      if (paneId !== PaneIdConstants.X_AXIS) {
        var pane = this.getDrawPaneById(paneId);
        if (pane !== null) {
          var bounding_1 = pane.getBounding();
          var ps = [].concat(points);
          var xAxis_1 = this._xAxisPane.getAxisComponent();
          var yAxis_1 = pane.getAxisComponent();
          coordinates = ps.map(function(point) {
            var coordinate = {};
            var dataIndex = point.dataIndex;
            if (isNumber(point.timestamp)) {
              dataIndex = _this._chartStore.timestampToDataIndex(point.timestamp);
            }
            if (isNumber(dataIndex)) {
              coordinate.x = xAxis_1.convertToPixel(dataIndex);
            }
            if (isNumber(point.value)) {
              var y = yAxis_1.convertToPixel(point.value);
              coordinate.y = absolute ? bounding_1.top + y : y;
            }
            return coordinate;
          });
        }
      }
      return isArray(points) ? coordinates : (_a = coordinates[0]) !== null && _a !== void 0 ? _a : {};
    };
    ChartImp2.prototype.convertFromPixel = function(coordinates, filter) {
      var _this = this;
      var _a;
      var _b = filter !== null && filter !== void 0 ? filter : {}, _c = _b.paneId, paneId = _c === void 0 ? PaneIdConstants.CANDLE : _c, _d = _b.absolute, absolute = _d === void 0 ? false : _d;
      var points = [];
      if (paneId !== PaneIdConstants.X_AXIS) {
        var pane = this.getDrawPaneById(paneId);
        if (pane !== null) {
          var bounding_2 = pane.getBounding();
          var cs = [].concat(coordinates);
          var xAxis_2 = this._xAxisPane.getAxisComponent();
          var yAxis_2 = pane.getAxisComponent();
          points = cs.map(function(coordinate) {
            var _a2;
            var point = {};
            if (isNumber(coordinate.x)) {
              var dataIndex = xAxis_2.convertFromPixel(coordinate.x);
              point.dataIndex = dataIndex;
              point.timestamp = (_a2 = _this._chartStore.dataIndexToTimestamp(dataIndex)) !== null && _a2 !== void 0 ? _a2 : void 0;
            }
            if (isNumber(coordinate.y)) {
              var y = absolute ? coordinate.y - bounding_2.top : coordinate.y;
              point.value = yAxis_2.convertFromPixel(y);
            }
            return point;
          });
        }
      }
      return isArray(coordinates) ? points : (_a = points[0]) !== null && _a !== void 0 ? _a : {};
    };
    ChartImp2.prototype.executeAction = function(type, data) {
      var _a;
      switch (type) {
        case "onCrosshairChange": {
          var crosshair = __assign({}, data);
          (_a = crosshair.paneId) !== null && _a !== void 0 ? _a : crosshair.paneId = PaneIdConstants.CANDLE;
          this._chartStore.setCrosshair(crosshair, { notExecuteAction: true });
          break;
        }
      }
    };
    ChartImp2.prototype.subscribeAction = function(type, callback) {
      this._chartStore.subscribeAction(type, callback);
    };
    ChartImp2.prototype.unsubscribeAction = function(type, callback) {
      this._chartStore.unsubscribeAction(type, callback);
    };
    ChartImp2.prototype.getConvertPictureUrl = function(includeOverlay, type, backgroundColor) {
      var _this = this;
      var _a = this._chartBounding, width = _a.width, height = _a.height;
      var canvas = createDom("canvas", {
        width: "".concat(width, "px"),
        height: "".concat(height, "px"),
        boxSizing: "border-box"
      });
      var ctx = canvas.getContext("2d");
      var pixelRatio = getPixelRatio(canvas);
      canvas.width = width * pixelRatio;
      canvas.height = height * pixelRatio;
      ctx.scale(pixelRatio, pixelRatio);
      ctx.fillStyle = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : "#FFFFFF";
      ctx.fillRect(0, 0, width, height);
      var overlayFlag = includeOverlay !== null && includeOverlay !== void 0 ? includeOverlay : false;
      this._drawPanes.forEach(function(pane) {
        var separatorPane = _this._separatorPanes.get(pane);
        if (isValid(separatorPane)) {
          var separatorBounding = separatorPane.getBounding();
          ctx.drawImage(separatorPane.getImage(overlayFlag), separatorBounding.left, separatorBounding.top, separatorBounding.width, separatorBounding.height);
        }
        var bounding = pane.getBounding();
        ctx.drawImage(pane.getImage(overlayFlag), 0, bounding.top, width, bounding.height);
      });
      return canvas.toDataURL("image/".concat(type !== null && type !== void 0 ? type : "jpeg"));
    };
    ChartImp2.prototype.resize = function() {
      this._cacheChartBounding();
      this.layout({
        measureHeight: true,
        measureWidth: true,
        update: true,
        buildYAxisTick: true,
        forceBuildYAxisTick: true
      });
    };
    ChartImp2.prototype.destroy = function() {
      this._chartEvent.destroy();
      this._drawPanes.forEach(function(pane) {
        pane.destroy();
      });
      this._drawPanes = [];
      this._separatorPanes.clear();
      this._chartStore.destroy();
      this._container.removeChild(this._chartContainer);
    };
    return ChartImp2;
  }()
);
var charts = /* @__PURE__ */ new Map();
var chartBaseId = 1;
function version() {
  return "10.0.0-beta1";
}
function init(ds, options) {
  logTag();
  var dom = null;
  if (isString(ds)) {
    dom = document.getElementById(ds);
  } else {
    dom = ds;
  }
  if (dom === null) {
    logError("", "", "The chart cannot be initialized correctly. Please check the parameters. The chart container cannot be null and child elements need to be added!!!");
    return null;
  }
  var chart = charts.get(dom.id);
  if (isValid(chart)) {
    logWarn("", "", "The chart has been initialized on the domÔºÅÔºÅÔºÅ");
    return chart;
  }
  var id = "k_line_chart_".concat(chartBaseId++);
  chart = new ChartImp(dom, options);
  chart.id = id;
  dom.setAttribute("k-line-chart-id", id);
  charts.set(id, chart);
  return chart;
}
function dispose(dcs) {
  var _a, _b;
  var id = null;
  if (dcs instanceof ChartImp) {
    id = dcs.id;
  } else {
    var dom = null;
    if (isString(dcs)) {
      dom = document.getElementById(dcs);
    } else {
      dom = dcs;
    }
    id = (_a = dom === null || dom === void 0 ? void 0 : dom.getAttribute("k-line-chart-id")) !== null && _a !== void 0 ? _a : null;
  }
  if (id !== null) {
    (_b = charts.get(id)) === null || _b === void 0 ? void 0 : _b.destroy();
    charts.delete(id);
  }
}
var utils = {
  clone,
  merge,
  isString,
  isNumber,
  isValid,
  isObject,
  isArray,
  isFunction,
  isBoolean,
  formatValue,
  formatPrecision,
  formatBigNumber,
  formatDate: formatTimestampByTemplate,
  formatThousands,
  formatFoldDecimal,
  calcTextWidth,
  getLinearSlopeIntercept,
  getLinearYFromSlopeIntercept,
  getLinearYFromCoordinates,
  checkCoordinateOnArc,
  checkCoordinateOnCircle,
  checkCoordinateOnLine,
  checkCoordinateOnPolygon,
  checkCoordinateOnRect,
  checkCoordinateOnText
};
export {
  dispose,
  getFigureClass,
  getOverlayClass,
  getSupportedFigures,
  getSupportedIndicators,
  getSupportedLocales,
  getSupportedOverlays,
  init,
  registerFigure,
  registerIndicator,
  registerLocale,
  registerOverlay,
  registerStyles,
  registerXAxis,
  registerYAxis,
  utils,
  version
};
/*! Bundled license information:

klinecharts/dist/index.esm.js:
  (**
       * @license
       * KLineChart v10.0.0-beta1
       * Copyright (c) 2019 lihu.
       * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
       *)
*/
//# sourceMappingURL=klinecharts.js.map
